
=== FILE: ./next-env.d.ts ===

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/building-your-application/configuring/typescript for more information.

=== FILE: ./scripts/set-password.ts ===

import fs from 'fs';
import path from 'path';
import readline from 'readline';
import { encryptPassword } from '../src/lib/encryption';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt');

rl.question('Enter the new password: ', (password) => {
  // Encrypt the password
  const encryptedPassword = encryptPassword(password);

  // Save the encrypted password
  fs.writeFileSync(encryptedPasswordPath, encryptedPassword);

  console.log('Password encrypted and saved successfully.');
  rl.close();
});

=== FILE: ./scripts/encrypt-password.ts ===

import fs from 'fs';
import path from 'path';
import { encryptPassword } from '../src/lib/encryption';

const passwordPath = path.join(process.cwd(), 'secret', 'password.txt');
const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt');

// Read the plain text password
const password = fs.readFileSync(passwordPath, 'utf8').trim();

// Encrypt the password
const encryptedPassword = encryptPassword(password);

// Save the encrypted password
fs.writeFileSync(encryptedPasswordPath, encryptedPassword);

console.log('Password encrypted and saved successfully.');

=== FILE: ./Dockerfile ===

# Use an official Node runtime as the base image
FROM node:18

# Set the working directory in the container
WORKDIR /app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm install

# Install Tailwind CSS CLI globally
RUN npm install -g tailwindcss

# Copy the rest of the application code
COPY . .

# Copy .env.local and load-env.js files
COPY .env.local .env.local
COPY load-env.js load-env.js

# Generate Prisma client
RUN npx prisma generate

# Build Tailwind CSS
RUN npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css

# Expose the ports the app and script server run on
EXPOSE 8080 5000

# Command to run the app in development mode and watch for Tailwind changes
CMD ["sh", "-c", "npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch & npm run dev"]

=== FILE: ./src/lib/utils/apiUtils.ts ===

import { WikiError } from '@/lib/errors/wikiError';

export const handleApiResponse = async (response: Response, errorMessage: string) => {
  if (!response.ok) {
    throw new Error(errorMessage);
  }
  return response.json();
};
=== FILE: ./src/lib/crypto.ts ===

// This is a simplified example and should not be used in production without proper security review

const encoder = new TextEncoder();
const decoder = new TextDecoder();

async function generateKey(): Promise<CryptoKey> {
  return await window.crypto.subtle.generateKey(
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt", "decrypt"]
  );
}

export async function encryptPassword(password: string): Promise<string> {
  const key = await generateKey();
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const encodedPassword = encoder.encode(password);

  const encryptedContent = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv: iv },
    key,
    encodedPassword
  );

  const encryptedContentArray = new Uint8Array(encryptedContent);
  const combinedArray = new Uint8Array(iv.length + encryptedContentArray.length);
  combinedArray.set(iv);
  combinedArray.set(encryptedContentArray, iv.length);

  return btoa(String.fromCharCode.apply(null, combinedArray as any));
}

export async function decryptPassword(encryptedPassword: string): Promise<string> {
  const combinedArray = new Uint8Array(atob(encryptedPassword).split('').map(char => char.charCodeAt(0)));
  const iv = combinedArray.slice(0, 12);
  const encryptedContentArray = combinedArray.slice(12);

  const key = await generateKey();

  const decryptedContent = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv: iv },
    key,
    encryptedContentArray
  );

  return decoder.decode(decryptedContent);
}

=== FILE: ./src/lib/utils.ts ===

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

=== FILE: ./src/lib/config/keyboardShortcuts.ts ===

// @/lib/config/keyboardShortcuts.ts
export interface KeyBinding {
    key: string;
    description: string;
    group: string;
    action: () => void;
  }
  
  export interface KeyboardShortcuts {
    [key: string]: KeyBinding;
  }
  
  export const createKeyboardShortcuts = (actions: {
    onNewDocument: () => void;
    onToggleCategory: () => void;
    onEditDocument: () => void;
    onSearch: () => void;
    onToggleLock: () => void;
    onSave: () => void;
    onCancel: () => void;
  }): KeyboardShortcuts => ({
    newDocument: {
      key: 'shift+n',
      description: 'Create new document',
      group: 'Documents',
      action: actions.onNewDocument
    },
    toggleCategory: {
      key: 'shift+/',
      description: 'Toggle category expansion',
      group: 'Navigation',
      action: actions.onToggleCategory
    },
    editDocument: {
      key: 'shift+e',
      description: 'Edit current document',
      group: 'Documents',
      action: actions.onEditDocument
    },
    search: {
      key: 'ctrl+space',
      description: 'Open search',
      group: 'Navigation',
      action: actions.onSearch
    },
    toggleLock: {
      key: 'shift+l',
      description: 'Toggle document lock',
      group: 'Security',
      action: actions.onToggleLock
    },
    save: {
      key: 'ctrl+s',
      description: 'Save document',
      group: 'Documents',
      action: actions.onSave
    },
    cancel: {
      key: 'escape',
      description: 'Cancel current action',
      group: 'General',
      action: actions.onCancel
    }
  });
=== FILE: ./src/lib/middlewares/caching.ts ===

// src/lib/middlewares/caching.ts
import { NextApiRequest, NextApiResponse } from 'next';

const CACHE_DURATION = 60 * 1000; // 1 minute
const cache = new Map<string, { data: any; timestamp: number }>();

export function withCache(handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    // Only cache GET requests
    if (req.method !== 'GET') {
      return handler(req, res);
    }

    const cacheKey = req.url!;
    const cached = cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      return res.status(200).json(cached.data);
    }

    // Modify response to intercept the JSON data
    const originalJson = res.json;
    res.json = function(data: any) {
      cache.set(cacheKey, {
        data,
        timestamp: Date.now()
      });
      return originalJson.call(this, data);
    };

    return handler(req, res);
  };
}
=== FILE: ./src/lib/search.ts ===

import Fuse from 'fuse.js';

export interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
}

export function createSearchIndex(documents: Document[]) {
  return new Fuse(documents, {
    keys: [
      { name: 'title', weight: 2 },
      { name: 'content', weight: 1 },
      { name: 'category', weight: 0.5 }
    ],
    includeMatches: true,
    threshold: 0.4,           // More lenient matching
    minMatchCharLength: 1,    // Changed from 2 to 1 to allow single-character searches
    distance: 100,
    ignoreLocation: true,
    useExtendedSearch: true,
    findAllMatches: true      // Added to ensure we get all possible matches
  });
}

export function searchDocuments(searchIndex: Fuse<Document>, query: string) {
  if (!query) return [];
  
  return searchIndex.search(query);
}
=== FILE: ./src/lib/create-style-context.ts ===

// src/lib/create-style-context.ts
'use client'

import { createContext, useContext } from 'react'

export const createStyleContext = (recipe: any) => {
  const StyleContext = createContext<string | null>(null)

  const withProvider = <T,>(Component: T, part: string) => {
    const Comp = Component as any
    return (props: any) => {
      const className = recipe({ ...props, className: props.className })
      const finalClassName = className?.[part] || className

      return (
        <StyleContext.Provider value={className}>
          <Comp {...props} className={finalClassName} />
        </StyleContext.Provider>
      )
    }
  }

  const withContext = <T,>(Component: T, part: string) => {
    const Comp = Component as any
    return (props: any) => {
      const className = useContext(StyleContext)
      const finalClassName = className?.[part] || className

      return <Comp {...props} className={finalClassName} />
    }
  }

  return {
    withProvider,
    withContext,
  }
}

=== FILE: ./src/lib/errors/wikiError.ts ===

export class WikiError extends Error {
    constructor(
      message: string,
      public status?: number,
      public info?: any
    ) {
      super(message);
      this.name = 'WikiError';
      // This is needed for instanceof to work properly
      Object.setPrototypeOf(this, WikiError.prototype);
    }
  }
=== FILE: ./src/lib/hooks/useKeyboardShortcuts.ts ===

// @/lib/hooks/useKeyboardShortcuts.ts
// Contains the hook
import { useHotkeys } from 'react-hotkeys-hook';
import { KeyboardShortcuts } from '@/lib/config/keyboardShortcuts';

export const useKeyboardShortcuts = (shortcuts: KeyboardShortcuts) => {
  Object.entries(shortcuts).forEach(([name, binding]) => {
    useHotkeys(binding.key, (e) => {
      e.preventDefault();
      binding.action();
    });
  });
};
=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useEffect, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import Fuse from 'fuse.js';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Fuse.FuseResult<Document>[]>([]);

  // Enhanced Fuse configuration
  const searchIndex = useMemo(() => {
    return new Fuse(documents, {
      keys: [
        { 
          name: 'title',
          weight: 3.0  // Increased weight for titles
        },
        {
          name: 'content',
          weight: 1.0
        },
        {
          name: 'category',
          weight: 2.0
        }
      ],
      includeMatches: true,
      shouldSort: true,
      threshold: 0.3,      // Lower threshold for stricter matching
      location: 0,         // Start searching at beginning of strings
      distance: 200,       // Allow more distance for matches
      minMatchCharLength: 2,  // Minimum length for matches
      useExtendedSearch: true,
      ignoreLocation: false,  // Consider location in string for relevance
      findAllMatches: true,   // Find all matching instances
      // Add Swedish diacritics to equivalent chars
      getFn: (obj, path) => {
        const value = Fuse.config.getFn(obj, path);
        if (typeof value === 'string') {
          return value.toLowerCase()
            .replace(/[åä]/g, 'a')
            .replace(/ö/g, 'o');
        }
        return value;
      }
    });
  }, [documents]);

  // Add keyboard shortcut handler
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.code === 'Space') {
        e.preventDefault();
        setIsSearchOpen(true);
      }

      if (e.key === 'Escape' && isSearchOpen) {
        e.preventDefault();
        setIsSearchOpen(false);
        setSearchResults([]);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isSearchOpen]);

  const handleSearch = useCallback((query: string) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    // Use extended search syntax for better matching
    const searchPattern = query.split(' ').map(term => {
      // Exact match for terms with quotes
      if (term.startsWith('"') && term.endsWith('"')) {
        return `'${term.slice(1, -1)}`;
      }
      // Fuzzy matching for other terms
      return `${term}`;
    }).join(' ');

    const results = searchIndex.search(searchPattern);
    setSearchResults(results);
  }, [searchIndex]);

  // Add a cleanup function for when the search modal is closed
  const handleClose = useCallback(() => {
    setIsSearchOpen(false);
    setSearchResults([]);
  }, []);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch,
    handleClose
  };
};

// Add type exports if needed
export type SearchResult = Fuse.FuseResult<Document>;
=== FILE: ./src/lib/context/WikiContext.tsx ===

import React, { 
  createContext, 
  useContext, 
  useState, 
  useCallback, 
  useEffect,
  useMemo 
} from 'react';
import { toast } from 'sonner';
import { 
  Document, 
  Category, 
  CategoryWithHierarchy, 
  Tag,
  DocumentUpdate,
  WikiState,
  DocumentFilter,
  SortOption
} from '@/lib/types/wiki';

interface WikiContextType extends WikiState {
  // Document actions
  selectDocument: (id: number | null) => void;
  createDocument: (title: string, category: string, restricted: boolean, content?: string) => Promise<void>;
  updateDocument: (id: number, updates: DocumentUpdate) => Promise<void>;
  deleteDocument: (id: number) => Promise<void>;
  
  // Category actions
  createCategory: (name: string, parentId?: number) => Promise<void>;
  updateCategory: (id: number, name: string) => Promise<void>;
  deleteCategory: (id: number) => Promise<void>;
  reorderCategory: (id: number, newOrder: number) => Promise<void>;
  
  // Tag actions
  createTag: (name: string, color: string) => Promise<void>;
  deleteTag: (id: number) => Promise<void>;
  updateDocumentTags: (documentId: number, tagIds: number[]) => Promise<void>;
  
  // UI State actions
  setIsEditing: (value: boolean) => void;
  setIsUnlocked: (value: boolean) => void;
  
  // Search and filter
  filterDocuments: (filter: DocumentFilter) => void;
  sortDocuments: (sort: SortOption) => void;
  
  // Auth
  isPasswordPromptOpen: boolean;
  setIsPasswordPromptOpen: (value: boolean) => void;
  handlePasswordSubmit: (password: string) => Promise<void>;

  // Additional UI state
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
}

const WikiContext = createContext<WikiContextType | null>(null);

export function useWiki() {
  const context = useContext(WikiContext);
  if (!context) {
    throw new Error('useWiki must be used within a WikiProvider');
  }
  return context;
}

const buildCategoryHierarchy = (
  categories: Category[],
  documents: Document[],
  parentId: number | null = null,
  level: number = 0
): CategoryWithHierarchy[] => {
  return categories
    .filter(cat => cat.parentId === parentId)
    .map(cat => ({
      ...cat,
      level,
      children: buildCategoryHierarchy(categories, documents, cat.id, level + 1),
      documentCount: documents.filter(doc => doc.category === cat.name).length
    }))
    .sort((a, b) => a.order - b.order);
};

export function WikiProvider({ children }: { children: React.ReactNode }) {
  // State
  const [documents, setDocuments] = useState<Document[]>([]);
  const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
  const [categories, setCategories] = useState<Category[]>([]);
  const [tags, setTags] = useState<Tag[]>([]);
  const [isEditing, setIsEditing] = useState(false);
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [filter, setFilter] = useState<DocumentFilter>({});
  const [sort, setSort] = useState<SortOption>({ field: 'updatedAt', direction: 'desc' });

  // Compute category hierarchy
  const categoryHierarchy = useMemo(() => 
    buildCategoryHierarchy(categories, documents),
    [categories, documents]
  );

  // Fetch initial data
  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const [docsRes, catsRes, tagsRes] = await Promise.all([
        fetch('/api/wiki/wiki'),
        fetch('/api/wiki/categories'),
        fetch('/api/wiki/tags')
      ]);

      if (!docsRes.ok || !catsRes.ok || !tagsRes.ok) {
        throw new Error('Failed to fetch data');
      }

      const [docsData, catsData, tagsData] = await Promise.all([
        docsRes.json(),
        catsRes.json(),
        tagsRes.json()
      ]);

      setDocuments(docsData);
      setCategories(catsData);
      setTags(tagsData);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch data';
      console.error('Error fetching data:', err);
      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Document actions
  const selectDocument = useCallback((id: number | null) => {
    const doc = id ? documents.find(d => d.id === id) || null : null;
    setSelectedDocument(doc);
    setIsEditing(false);
  }, [documents]);

  const createDocument = useCallback(async (
    title: string,
    category: string,
    restricted: boolean,
    content: string = ''
  ) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to create document');
      }

      await fetchData();
      toast.success('Document created successfully');
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create document');
      throw error;
    }
  }, [fetchData]);

  const updateDocument = useCallback(async (
    id: number,
    updates: DocumentUpdate
  ) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, { // Add id to URL
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      });
  
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update document');
      }
  
      const updatedDoc = await response.json();
      
      // Update local state
      setDocuments(prevDocs => 
        prevDocs.map(doc => 
          doc.id === id ? { ...doc, ...updatedDoc } : doc
        )
      );
  
      if (selectedDocument?.id === id) {
        setSelectedDocument(prev => 
          prev ? { ...prev, ...updatedDoc } : null
        );
      }
  
      toast.success('Document updated successfully');
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to update document');
      throw error;
    }
  }, [selectedDocument?.id]);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete document');
      }

      await fetchData();
      if (selectedDocument?.id === id) {
        setSelectedDocument(null);
      }
      toast.success('Document deleted successfully');
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to delete document');
      throw error;
    }
  }, [fetchData, selectedDocument?.id]);

  // Category actions
  const createCategory = useCallback(async (name: string, parentId?: number) => {
    try {
      const response = await fetch('/api/wiki/categories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, parentId }),
      });

      if (!response.ok) throw new Error('Failed to create category');
      await fetchData();
      toast.success('Category created successfully');
    } catch (error) {
      console.error('Error creating category:', error);
      toast.error('Failed to create category');
      throw error;
    }
  }, [fetchData]);

  const updateCategory = useCallback(async (id: number, name: string) => {
    try {
      const response = await fetch('/api/wiki/categories', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, name }),
      });

      if (!response.ok) throw new Error('Failed to update category');
      await fetchData();
      toast.success('Category updated successfully');
    } catch (error) {
      console.error('Error updating category:', error);
      toast.error('Failed to update category');
      throw error;
    }
  }, [fetchData]);

  const deleteCategory = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/categories?id=${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) throw new Error('Failed to delete category');
      await fetchData();
      toast.success('Category deleted successfully');
    } catch (error) {
      console.error('Error deleting category:', error);
      toast.error('Failed to delete category');
      throw error;
    }
  }, [fetchData]);

  const reorderCategory = useCallback(async (id: number, newOrder: number) => {
    try {
      const response = await fetch('/api/wiki/categories', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, order: newOrder }),
      });

      if (!response.ok) throw new Error('Failed to reorder category');
      await fetchData();
    } catch (error) {
      console.error('Error reordering category:', error);
      toast.error('Failed to reorder category');
      throw error;
    }
  }, [fetchData]);

  // Tag actions
  const createTag = useCallback(async (name: string, color: string) => {
    try {
      const response = await fetch('/api/wiki/tags', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, color }),
      });

      if (!response.ok) throw new Error('Failed to create tag');
      await fetchData();
      toast.success('Tag created successfully');
    } catch (error) {
      console.error('Error creating tag:', error);
      toast.error('Failed to create tag');
      throw error;
    }
  }, [fetchData]);

  const deleteTag = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/tags?id=${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) throw new Error('Failed to delete tag');
      await fetchData();
      toast.success('Tag deleted successfully');
    } catch (error) {
      console.error('Error deleting tag:', error);
      toast.error('Failed to delete tag');
      throw error;
    }
  }, [fetchData]);

  const updateDocumentTags = useCallback(async (documentId: number, tagIds: number[]) => {
    try {
      const response = await fetch('/api/wiki/tags', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentId, tagIds }),
      });

      if (!response.ok) throw new Error('Failed to update document tags');
      await fetchData();
      toast.success('Tags updated successfully');
    } catch (error) {
      console.error('Error updating document tags:', error);
      toast.error('Failed to update document tags');
      throw error;
    }
  }, [fetchData]);

  // Search and filter
  const filterDocuments = useCallback((newFilter: DocumentFilter) => {
    setFilter(newFilter);
  }, []);

  const sortDocuments = useCallback((newSort: SortOption) => {
    setSort(newSort);
  }, []);

  // Auth
  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });
  
      if (!response.ok) {
        throw new Error('Invalid password');
      }
  
      setIsUnlocked(true);
      setIsPasswordPromptOpen(false);
      toast.success('Successfully unlocked');
    } catch (error) {
      // Don't close the modal on error
      throw error; // Let the PasswordPromptModal handle the error display
    }
  }, []);

  const value = {
    // State
    documents,
    selectedDocument,
    categories: categoryHierarchy,
    tags,
    isEditing,
    isUnlocked,
    isLoading,
    error,
    isPasswordPromptOpen,
    isAddDocumentOpen,
    isUploadDialogOpen,

    // Actions
    selectDocument,
    createDocument,
    updateDocument,
    deleteDocument,
    createCategory,
    updateCategory,
    deleteCategory,
    reorderCategory,
    createTag,
    deleteTag,
    updateDocumentTags,

    // UI State actions
    setIsEditing,
    setIsUnlocked,
    setIsPasswordPromptOpen,
    setIsAddDocumentOpen,
    setIsUploadDialogOpen,
    filterDocuments,
    sortDocuments,
    handlePasswordSubmit,
  };

  return (
    <WikiContext.Provider value={value}>
      {children}
    </WikiContext.Provider>
  );
}
=== FILE: ./src/lib/context/ModalContext.tsx ===

import React, { createContext, useContext, useReducer, useCallback } from 'react';

type ModalType = string;

interface ModalState {
  stack: ModalType[];
}

type ModalAction = 
  | { type: 'PUSH_MODAL'; payload: ModalType }
  | { type: 'POP_MODAL' }
  | { type: 'CLOSE_ALL' };

interface ModalContextType {
  modalStack: ModalType[];
  pushModal: (modal: ModalType) => void;
  popModal: () => void;
  closeAllModals: () => void;
  isTopModal: (modal: ModalType) => boolean;
}

const ModalContext = createContext<ModalContextType | null>(null);

function modalReducer(state: ModalState, action: ModalAction): ModalState {
  switch (action.type) {
    case 'PUSH_MODAL':
      return {
        ...state,
        stack: [...state.stack, action.payload]
      };
    case 'POP_MODAL':
      return {
        ...state,
        stack: state.stack.slice(0, -1)
      };
    case 'CLOSE_ALL':
      return {
        ...state,
        stack: []
      };
    default:
      return state;
  }
}

export function ModalProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(modalReducer, { stack: [] });

  const pushModal = useCallback((modal: ModalType) => {
    dispatch({ type: 'PUSH_MODAL', payload: modal });
  }, []);

  const popModal = useCallback(() => {
    dispatch({ type: 'POP_MODAL' });
  }, []);

  const closeAllModals = useCallback(() => {
    dispatch({ type: 'CLOSE_ALL' });
  }, []);

  const isTopModal = useCallback((modal: ModalType) => {
    return state.stack[state.stack.length - 1] === modal;
  }, [state.stack]);

  React.useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && state.stack.length > 0) {
        e.preventDefault();
        popModal();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [popModal]);

  const value = {
    modalStack: state.stack,
    pushModal,
    popModal,
    closeAllModals,
    isTopModal
  };

  return (
    <ModalContext.Provider value={value}>
      {children}
    </ModalContext.Provider>
  );
}

export function useModal() {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error('useModal must be used within a ModalProvider');
  }
  return context;
}
=== FILE: ./src/lib/prisma.ts ===

import { PrismaClient } from '@prisma/client'

let prisma: PrismaClient

if (process.env.NODE_ENV === 'production') {
  prisma = new PrismaClient()
} else {
  if (!global.prisma) {
    global.prisma = new PrismaClient()
  }
  prisma = global.prisma
}

export default prisma

=== FILE: ./src/lib/types/wiki.ts ===

export interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
  createdAt: Date;
  updatedAt: Date;
  tags?: Array<{
    id: number;
    name: string;
    color: string;
  }>;
}

export interface Tag {
  id: number;
  name: string;
  color: string;
}

export interface Category {
  id: number;
  name: string;
  parentId: number | null;
  order: number;
}

export interface CategoryWithHierarchy extends Category {
  level: number;
  children: CategoryWithHierarchy[];
  documentCount: number;
}

export interface DocumentUpdate {
  title?: string;
  content?: string;
  category?: string;
  restricted?: boolean;
}

export interface SearchResult {
  document: Document;
  matches: {
    indices: [number, number][];
    key: string;
    value: string;
  }[];
  score: number;
}

export interface TOCItem {
  id: string;
  text: string;
  level: number;
}

// API Response Types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface DocumentResponse extends ApiResponse<Document> {}
export interface DocumentsResponse extends ApiResponse<Document[]> {}
export interface CategoryResponse extends ApiResponse<Category> {}
export interface CategoriesResponse extends ApiResponse<Category[]> {}
export interface TagResponse extends ApiResponse<Tag> {}
export interface TagsResponse extends ApiResponse<Tag[]> {}

// State Types for context
export interface WikiState {
  documents: Document[];
  selectedDocument: Document | null;
  categories: CategoryWithHierarchy[];
  tags: Tag[];
  isEditing: boolean;
  isUnlocked: boolean;
  isLoading: boolean;
  error: string | null;
}

// Additional Types for specific features
export interface DocumentFilter {
  category?: string;
  tag?: string;
  searchQuery?: string;
  restricted?: boolean;
}

export interface SortOption {
  field: keyof Document;
  direction: 'asc' | 'desc';
}

export interface DocumentStats {
  totalCount: number;
  restrictedCount: number;
  categoryCounts: Record<string, number>;
  tagCounts: Record<string, number>;
  lastUpdated: Date;
}
=== FILE: ./src/lib/types/types.ts ===

// @/lib/types/wiki.ts
export interface Document {
  id: number;
  title: string;
  content: string;
  category: string;
  restricted: boolean;
}
=== FILE: ./src/lib/encryption.ts ===

import crypto from 'crypto';
import fs from 'fs';
import path from 'path';

const algorithm = 'aes-256-cbc';
const keyPath = path.join(process.cwd(), 'secret', 'encryption_key.txt');
const ivPath = path.join(process.cwd(), 'secret', 'encryption_iv.txt');

function getEncryptionKey(): Buffer {
  if (!fs.existsSync(keyPath)) {
    const key = crypto.randomBytes(32);
    fs.writeFileSync(keyPath, key);
    return key;
  }
  return fs.readFileSync(keyPath);
}

function getIV(): Buffer {
  if (!fs.existsSync(ivPath)) {
    const iv = crypto.randomBytes(16);
    fs.writeFileSync(ivPath, iv);
    return iv;
  }
  return fs.readFileSync(ivPath);
}

export function encryptPassword(password: string): string {
  const key = getEncryptionKey();
  const iv = getIV();
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let encrypted = cipher.update(password, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}

export function decryptPassword(encryptedPassword: string): string {
  const key = getEncryptionKey();
  const iv = getIV();
  const decipher = crypto.createDecipheriv(algorithm, key, iv);
  let decrypted = decipher.update(encryptedPassword, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

=== FILE: ./src/lib/cn.ts ===

import { ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
 
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    // Create documents table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN,
        isPinned BOOLEAN DEFAULT 0,
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);

    // Check and add category column to documents
    const documentsInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = documentsInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }

    // Create categories table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        parentId INTEGER,
        orderIndex INTEGER DEFAULT 0,
        FOREIGN KEY (parentId) REFERENCES categories(id)
      );
    `);

    // Create tags table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        color TEXT NOT NULL
      );
    `);

    // Create document_tags table for many-to-many relationship
    await db.exec(`
      CREATE TABLE IF NOT EXISTS document_tags (
        documentId INTEGER,
        tagId INTEGER,
        PRIMARY KEY (documentId, tagId),
        FOREIGN KEY (documentId) REFERENCES documents(id) ON DELETE CASCADE,
        FOREIGN KEY (tagId) REFERENCES tags(id) ON DELETE CASCADE
      );
    `);
  }
  return db;
}

// Rest of your existing functions remain the same...

export async function getCategories(): Promise<Category[]> {
  const db = await openDb();
  return db.all(`
    SELECT 
      c.id, 
      c.name, 
      c.parentId,
      c.orderIndex,
      COUNT(d.id) as documentCount
    FROM categories c
    LEFT JOIN documents d ON d.category = c.name
    GROUP BY c.id
    ORDER BY c.orderIndex
  `);
}

export async function createCategory(name: string, parentId?: number): Promise<Category> {
  const db = await openDb();
  const maxOrder = await db.get('SELECT MAX(orderIndex) as maxOrder FROM categories');
  const result = await db.run(
    'INSERT INTO categories (name, parentId, orderIndex) VALUES (?, ?, ?)',
    name,
    parentId || null,
    (maxOrder?.maxOrder || 0) + 1
  );
  return {
    id: result.lastID!,
    name,
    parentId: parentId || null,
    order: (maxOrder?.maxOrder || 0) + 1
  };
}

export async function updateCategory(id: number, name: string): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET name = ? WHERE id = ?', name, id);
}

export async function deleteCategory(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM categories WHERE id = ?', id);
}

export async function reorderCategory(id: number, newOrder: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET orderIndex = ? WHERE id = ?', newOrder, id);
}

export async function getTags(): Promise<Tag[]> {
  const db = await openDb();
  return db.all('SELECT * FROM tags');
}

export async function createTag(name: string, color: string): Promise<Tag> {
  const db = await openDb();
  const result = await db.run(
    'INSERT INTO tags (name, color) VALUES (?, ?)',
    name,
    color
  );
  return { id: result.lastID!, name, color };
}

export async function deleteTag(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM tags WHERE id = ?', id);
}

export async function updateDocumentTags(documentId: number, tagIds: number[]): Promise<void> {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    await db.run('DELETE FROM document_tags WHERE documentId = ?', documentId);
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        documentId,
        tagId
      );
    }
    await db.run('COMMIT');
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

// Update existing document functions to include new fields
export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  const documents = await db.all(`
    SELECT 
      d.*,
      GROUP_CONCAT(t.id) as tagIds,
      GROUP_CONCAT(t.name) as tagNames,
      GROUP_CONCAT(t.color) as tagColors
    FROM documents d
    LEFT JOIN document_tags dt ON d.id = dt.documentId
    LEFT JOIN tags t ON dt.tagId = t.id
    ${includeRestricted ? '' : 'WHERE d.restricted = 0'}
    GROUP BY d.id
    ORDER BY d.isPinned DESC, d.updatedAt DESC
  `);

  return documents.map(doc => ({
    ...doc,
    tags: doc.tagIds ? doc.tagIds.split(',').map((id: string, index: number) => ({
      id: parseInt(id),
      name: doc.tagNames.split(',')[index],
      color: doc.tagColors.split(',')[index]
    })) : []
  }));
}

export async function createDocument(
  title: string,
  content: string,
  restricted: boolean,
  categoryId: number,
  tagIds: number[] = []
) {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    const result = await db.run(
      `INSERT INTO documents (
        title, content, restricted, categoryId, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
      title,
      content,
      restricted ? 1 : 0,
      categoryId
    );
    
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        result.lastID,
        tagId
      );
    }
    
    await db.run('COMMIT');
    return result.lastID;
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

export async function toggleDocumentPin(id: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE documents SET isPinned = NOT isPinned WHERE id = ?', id);
}
=== FILE: ./src/config.ts ===

// src/config.ts
export const API_URL = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL || 'http://node:5000';

=== FILE: ./src/components/layout.tsx ===

// src/components/layout.tsx
"use client"
import React, { ReactNode } from 'react'
import { ThemeToggle } from '@/components/dashboard/ThemeToggle';

interface LayoutProps {
  children: ReactNode
}

export default function Layout({ children }: LayoutProps) {
  return (
    <div className="flex flex-col w-screen h-screen">
      <header className="p-4 flex justify-between items-center absolute top-0 left-0 right-0 z-50 bg-transparent">
        <h1 className="text-2xl font-bold"></h1>
        <ThemeToggle />
      </header>
      <main className="flex-grow">
        {children}
      </main>
    </div>
  )
}
=== FILE: ./src/components/hostapps/SftpUserCreationForm.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { AlertDialog, AlertDialogAction, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog"
import { Label } from "@/components/ui/label"

interface FormData {
  username: string
  firstName: string
  lastName: string
  userType: string
  department: string
  company: string
  responsibleFirstName: string
  responsibleLastName: string
  deletionTime: string
}

interface SftpUserCreationFormProps {
  onUserCreated: () => void
}

export default function SftpUserCreationForm({ onUserCreated }: SftpUserCreationFormProps) {
  const [formData, setFormData] = useState<FormData>({
    username: '',
    firstName: '',
    lastName: '',
    userType: '',
    department: '',
    company: '',
    responsibleFirstName: '',
    responsibleLastName: '',
    deletionTime: '',
  })

  const [message, setMessage] = useState<string>('')
  const [errorDetails, setErrorDetails] = useState<string>('')
  const [isAlertOpen, setIsAlertOpen] = useState<boolean>(false)
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [isError, setIsError] = useState<boolean>(false)

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setFormData(prevData => ({ ...prevData, [name]: value }))
  }

  const handleSelectChange = (name: string, value: string) => {
    setFormData(prevData => ({ ...prevData, [name]: value }))
  }

  const handleCreateUser = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setIsError(false)
    setErrorDetails('')

    const userData = {
      username: formData.username,
      user_info: {
        "First name": formData.firstName,
        "Last name": formData.lastName,
        "User Type": formData.userType,
        ...(formData.userType === 'internal' ? {
          "Department": formData.department,
          "Email": `${formData.firstName.toLowerCase()}.${formData.lastName.toLowerCase()}@karlshamnenergi.se`,
        } : {
          "Company": formData.company,
          "Handled by department": formData.department,
          "Responsible internally first name": formData.responsibleFirstName,
          "Responsible internally last name": formData.responsibleLastName,
          "Responsible internally email": `${formData.responsibleFirstName.toLowerCase()}.${formData.responsibleLastName.toLowerCase()}@karlshamnenergi.se`,
        }),
      },
      deletion_time: formData.deletionTime,
    }

    try {
      const response = await fetch('/api/hostapps/create_user', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.details || data.error || 'Failed to create user')
      }

      setMessage(data.message || 'User created successfully')
      setIsError(false)
      setIsAlertOpen(true)
      onUserCreated()

      // Clear form on success
      setFormData({
        username: '',
        firstName: '',
        lastName: '',
        userType: '',
        department: '',
        company: '',
        responsibleFirstName: '',
        responsibleLastName: '',
        deletionTime: '',
      })
    } catch (error) {
      console.error('Error creating user:', error)
      setIsError(true)
      setMessage('Failed to create user')
      setErrorDetails((error as Error).message)
      setIsAlertOpen(true)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleCreateUser} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="username">Username</Label>
        <Input
          id="username"
          name="username"
          value={formData.username}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="firstName">First Name</Label>
        <Input
          id="firstName"
          name="firstName"
          value={formData.firstName}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="lastName">Last Name</Label>
        <Input
          id="lastName"
          name="lastName"
          value={formData.lastName}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="userType">User Type</Label>
        <Select
          name="userType"
          value={formData.userType}
          onValueChange={(value) => handleSelectChange('userType', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select User Type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="internal">Internal</SelectItem>
            <SelectItem value="external">External</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label htmlFor="department">Department</Label>
        <Select
          name="department"
          value={formData.department}
          onValueChange={(value) => handleSelectChange('department', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select Department" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="Digit">Digit</SelectItem>
            <SelectItem value="El">El</SelectItem>
            <SelectItem value="Fjarrvarme">Fjarrvarme</SelectItem>
            <SelectItem value="Marknad">Marknad</SelectItem>
            <SelectItem value="Vatten">Vatten</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {formData.userType === 'external' && (
        <>
          <div className="space-y-2">
            <Label htmlFor="company">Company</Label>
            <Input
              id="company"
              name="company"
              value={formData.company}
              onChange={handleInputChange}
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="responsibleFirstName">Responsible First Name</Label>
            <Input
              id="responsibleFirstName"
              name="responsibleFirstName"
              value={formData.responsibleFirstName}
              onChange={handleInputChange}
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="responsibleLastName">Responsible Last Name</Label>
            <Input
              id="responsibleLastName"
              name="responsibleLastName"
              value={formData.responsibleLastName}
              onChange={handleInputChange}
              required
            />
          </div>
        </>
      )}

      <div className="space-y-2">
        <Label htmlFor="deletionTime">Deletion Time</Label>
        <Select
          name="deletionTime"
          value={formData.deletionTime}
          onValueChange={(value) => handleSelectChange('deletionTime', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select Deletion Time" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="0">No deletion</SelectItem>
            <SelectItem value="10">10 minutes</SelectItem>
            <SelectItem value="60">1 hour</SelectItem>
            <SelectItem value="1440">1 day</SelectItem>
            <SelectItem value="43200">30 days</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? 'Creating User...' : 'Create User'}
      </Button>

      <AlertDialog open={isAlertOpen} onOpenChange={setIsAlertOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{isError ? 'Error' : 'Success'}</AlertDialogTitle>
            <AlertDialogDescription>
              {message}
              {errorDetails && (
                <div className="mt-2 text-sm text-red-600">
                  Details: {errorDetails}
                </div>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogAction onClick={() => setIsAlertOpen(false)}>Okay</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </form>
  )
}

=== FILE: ./src/components/hostapps/PasswordPrompt.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Form, FormField, FormItem, FormControl } from "@/components/ui/form"
import { toast } from "sonner"

interface PasswordPromptProps {
  isOpen: boolean
  onPasswordSubmit: (password: string) => void
  onClose: () => void
}

const formSchema = z.object({
  password: z.string().min(1, "Password is required")
})

type FormValues = z.infer<typeof formSchema>

export function PasswordPrompt({ isOpen, onPasswordSubmit, onClose }: PasswordPromptProps) {
  const [isValidating, setIsValidating] = useState(false)
  
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      password: ""
    }
  })

  const onSubmit = async (values: FormValues) => {
    try {
      setIsValidating(true)

      const response = await fetch('/api/hostapps/handbrake?action=list_files', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          password: values.password 
        })
      });

      const data = await response.json();

      if (!response.ok) {
        if (response.status === 503 || response.status === 502) {
          throw new Error('Server is currently unavailable. Please try again later.');
        }
        throw new Error(data.error || data.details || 'Invalid password');
      }

      // If we got here, the password is valid
      onPasswordSubmit(values.password);
      form.reset();
    } catch (error) {
      console.error('Password validation error:', error);
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Failed to validate password. Please try again.';
      
      toast.error(errorMessage);
    } finally {
      setIsValidating(false);
    }
  }

  const handleClose = () => {
    form.reset();
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="password">Password</Label>
                  <FormControl>
                    <Input 
                      id="password"
                      type="password" 
                      placeholder="Enter SFTP password"
                      {...field}
                      autoComplete="off"
                      disabled={isValidating}
                    />
                  </FormControl>
                </FormItem>
              )}
            />
            <div className="flex gap-2 justify-end">
              <Button 
                type="button" 
                variant="outline" 
                onClick={handleClose}
                disabled={isValidating}
              >
                Cancel
              </Button>
              <Button 
                type="submit" 
                disabled={isValidating}
              >
                {isValidating ? "Validating..." : "Continue"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/hostapps/VideoProcessorCard.tsx ===

import React from 'react'
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
import { MultiStepLoader } from "@/components/ui/multi-step-loader"
import { cn } from "@/lib/utils"
import { Repeat } from "lucide-react"

interface ProcessingState {
  isProcessing: boolean
  currentStep: number
  progress: number
  steps: {
    title: string
    description: string
  }[]
}

interface VideoProcessorCardProps {
  onClick: () => void
  processingState: ProcessingState | null
}

export function VideoProcessorCard({ onClick, processingState }: VideoProcessorCardProps) {
  return (
    <Card 
      onClick={!processingState?.isProcessing ? onClick : undefined}
      className={cn(
        "relative group hover:shadow-md transition-all duration-300",
        !processingState?.isProcessing && "cursor-pointer hover:border-primary",
        processingState?.isProcessing && "border-primary"
      )}
    >
      {processingState?.isProcessing ? (
        <>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Repeat className="h-5 w-5 animate-pulse" />
              Processing Video
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <MultiStepLoader
                steps={processingState.steps}
                currentStep={processingState.currentStep}
              />
              <div className="space-y-2">
                <Progress 
                  value={processingState.progress} 
                  className="h-2"
                />
                <div className="flex justify-between text-sm text-muted-foreground">
                  <span>
                    {processingState.steps[processingState.currentStep].title}
                  </span>
                  <span>
                    {Math.round(processingState.progress)}%
                  </span>
                </div>
              </div>
            </div>
          </CardContent>
        </>
      ) : (
        <>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Repeat className="h-5 w-5 text-mprimary" />
              Video Processor
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Convert and process video files using HandBrake
            </p>
          </CardContent>
        </>
      )}
    </Card>
  )
}
=== FILE: ./src/components/hostapps/HandbrakeProcessorForm.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { toast } from "sonner"
import { Form, FormField, FormItem, FormControl } from "@/components/ui/form"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"

interface HandbrakeProcessorFormProps {
  password: string
  onProcessingStart: (file: File, preset: number) => void
  onCancel: () => void
  presets: Array<{ name: string; path: string | null }>
}

const formSchema = z.object({
  file: z.string().min(1, "Please select a file"),
  preset: z.string().min(1, "Please select a preset")
})

type FormValues = z.infer<typeof formSchema>

export function HandbrakeProcessorForm({ 
  password, 
  onProcessingStart,
  onCancel,
  presets 
}: HandbrakeProcessorFormProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null)

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      file: "",
      preset: "0"
    }
  })

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      const file = event.target.files[0]
      setSelectedFile(file)
      form.setValue('file', file.name)
    }
  }

  const onSubmit = async (values: FormValues) => {
    if (!selectedFile) {
      toast.error("Please select a file")
      return
    }
  
    try {
      const formData = new FormData()
      formData.append('file', selectedFile)
      formData.append('password', password)
  
      onProcessingStart(selectedFile, parseInt(values.preset))
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <div className="space-y-2">
          <Label>Select File</Label>
          <Input 
            type="file" 
            onChange={handleFileSelect}
          />
        </div>

        <FormField
          control={form.control}
          name="preset"
          render={({ field }) => (
            <FormItem>
              <Label>Select Preset</Label>
              <FormControl>
                <Select
                  value={field.value}
                  onValueChange={field.onChange}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Choose a preset" />
                  </SelectTrigger>
                  <SelectContent>
                    {presets.map((preset, index) => (
                      <SelectItem key={index} value={index.toString()}>
                        {preset.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </FormControl>
            </FormItem>
          )}
        />

        <div className="flex gap-2">
          <Button type="button" variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button type="submit">
            Start Processing
          </Button>
        </div>
      </form>
    </Form>
  )
}
=== FILE: ./src/components/hostapps/PasswordPromptDialog.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { usePasswordPromptStore } from '@/pages/hostapps/videoProcessor'

export function PasswordPromptDialog() {
  const [password, setPassword] = useState("")
  const { isOpen, setIsOpen, setPassword: storePassword, reset } = usePasswordPromptStore()

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    storePassword(password)
    setPassword("")
    setIsOpen(false)
  }

  const handleClose = () => {
    setPassword("")
    reset()
  }

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) handleClose()
    }}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
          <DialogDescription>
            Please provide your SFTP password to continue.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
=== FILE: ./src/components/head.tsx ===

import Head from 'next/head'

export default function CustomHead() {
  return (
    <Head>
      <title>Wiki</title>
      <link
        rel="stylesheet"
        href="https://unpkg.com/@tailwindcss/typography@0.5.9/dist/typography.min.css"
      />
    </Head>
  )
}

=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/ThemeToggle.tsx ===

// src/components/dashboard/ThemeToggle.tsx
import React, { useState, useEffect } from 'react';
import { Check, Moon, Sun, Palette } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const themes = [
  { id: 'light', name: 'Nord Light', icon: '🌕' },
  { id: 'dark', name: 'Nord Dark', icon: '🌑' },
  { id: 'theme-rosepine', name: 'Rose Pine', icon: '🌹' },
  { id: 'theme-catppuccin', name: 'Catppuccin', icon: '🐱' },
  { id: 'theme-onedark', name: 'One Dark', icon: '🌌' },
  { id: 'theme-kanagawa', name: 'Kanagawa', icon: '🌊' },
  { id: 'theme-dracula', name: 'Dracula', icon: '🧛' },
];

export const ThemeToggle = () => {
  const [isDark, setIsDark] = useState(false);
  const [showThemePicker, setShowThemePicker] = useState(false);
  const [currentTheme, setCurrentTheme] = useState('light');

  useEffect(() => {
    // Initialize theme from localStorage or system preference
    const savedTheme = localStorage.getItem('theme');
    const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (savedTheme) {
      applyTheme(savedTheme);
      setIsDark(savedTheme.includes('dark'));
    } else {
      setIsDark(systemDark);
      applyTheme(systemDark ? 'dark' : 'light');
    }
  }, []);

  const applyTheme = (themeId) => {
    // Remove all theme classes
    document.documentElement.classList.remove('light', 'dark', ...themes.map(t => t.id));
    
    // Apply new theme
    document.documentElement.classList.add(themeId);
    localStorage.setItem('theme', themeId);
    setCurrentTheme(themeId);
  };

  return (
    <div className="relative">
      <div className="flex items-center gap-2">
        <button
          onClick={() => setShowThemePicker(!showThemePicker)}
          className="p-2 rounded-lg hover:bg-muted transition-colors"
        >
          <Palette className="w-5 h-5 text-muted-foreground" />
        </button>
      </div>

      <AnimatePresence>
        {showThemePicker && (
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
            className="absolute right-0 mt-2 w-48 py-2 bg-popover border border-border rounded-lg shadow-lg z-50"
          >
            {themes.map((theme) => (
              <button
                key={theme.id}
                onClick={() => {
                  applyTheme(theme.id);
                  setShowThemePicker(false);
                  setIsDark(theme.id.includes('dark'));
                }}
                className="flex items-center w-full px-4 py-2 text-base-content hover:bg-muted transition-colors"
              >
                <span className="mr-2">{theme.icon}</span>
                <span className="flex-grow text-left">{theme.name}</span>
                {currentTheme === theme.id && (
                  <Check className="w-4 h-4 text-primary" />
                )}
              </button>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default ThemeToggle;
=== FILE: ./src/components/dashboard/ShortcutsModal.tsx ===

// @/components/dashboard/ShortcutsModal.tsx
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ShortcutsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export const ShortcutsModal = ({ isOpen, onClose }: ShortcutsModalProps) => (
  <AnimatePresence>
    {isOpen && (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 z-50 flex items-center justify-center bg-background/50 backdrop-blur-sm"
        onClick={onClose}
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.95, opacity: 0 }}
          className="w-full max-w-md p-6 bg-base-200 rounded-xl shadow-xl"
          onClick={(e) => e.stopPropagation()}
        >
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-semibold text-[#ECEFF4]">Keyboard Shortcuts</h2>
            <button 
              onClick={onClose}
              className="p-2 rounded-lg hover:bg-[#434C5E] transition-colors"
            >
              <X className="w-5 h-5 text-[#D8DEE9]" />
            </button>
          </div>
          <div className="space-y-3">
            {[
              { keys: ["Alt", "1-3"], description: "Open applications" },
              { keys: ["?"], description: "Show shortcuts" },
              { keys: ["Esc"], description: "Close windows" },
            ].map((shortcut, i) => (
              <div key={i} className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  {shortcut.keys.map((key, j) => (
                    <kbd key={j} className="px-2 py-1 rounded bg-[#4C566A] text-[#ECEFF4] text-sm">
                      {key}
                    </kbd>
                  ))}
                </div>
                <span className="text-[#D8DEE9]">{shortcut.description}</span>
              </div>
            ))}
          </div>
        </motion.div>
      </motion.div>
    )}
  </AnimatePresence>
);

export default ShortcutsModal;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 w-full">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              "hover:scale-[1.02]",
              item.className,
              item.hoverColor
            )}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/dashboard/CommandItem.tsx ===

// src/components/dashboard/CommandItem.tsx
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandItemProps {
  command: CommandItemType;
  onSelect: () => void;
}

export const CommandItem = ({ command, onSelect }: CommandItemProps) => (
  <Command.Item
    value={command.name}
    onSelect={onSelect}
    className="flex flex-col px-4 py-2 hover:bg-[#434C5E] aria-selected:bg-[#434C5E]"
  >
    <div className="flex items-center justify-between">
      <div className="flex items-center gap-2">
        <span className="font-medium text-[#ECEFF4]">{command.name}</span>
      </div>
      {command.shortcut && (
        <kbd className="px-2 py-1 rounded bg-[#4C566A] text-[#D8DEE9] text-xs">
          {command.shortcut}
        </kbd>
      )}
    </div>
    {command.description && (
      <p className="text-sm text-[#D8DEE9]/70 mt-1">{command.description}</p>
    )}
  </Command.Item>
);

export default CommandItem;
=== FILE: ./src/components/dashboard/Window.tsx ===

// @/components/dashboard/Window.tsx
import { useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';
import { Card } from "@/components/ui/card";

interface WindowProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  title: string;
}

export const Window = ({ isOpen, onClose, children, title }: WindowProps) => {
  useEffect(() => {
    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    
    window.addEventListener('keydown', handleEsc);
    return () => window.removeEventListener('keydown', handleEsc);
  }, [onClose]);

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div 
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.2 }}
        className="fixed inset-0 z-50 flex items-center justify-center bg-[#2E3440]/80 backdrop-blur-sm"
        onClick={onClose}
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.95, opacity: 0 }}
          transition={{ duration: 0.2 }}
          onClick={(e) => e.stopPropagation()}
          className="w-[90vw] h-[90vh]"
        >
          <Card className="relative w-full h-full bg-[#3B4252] rounded-xl shadow-xl flex flex-col border border-[#4C566A]">
            <div className="flex items-center justify-between p-4 border-b border-[#4C566A]">
              <h2 className="text-lg font-medium text-[#ECEFF4]">{title}</h2>
              <button 
                onClick={onClose}
                className="p-2 rounded-lg hover:bg-[#434C5E] transition-colors"
              >
                <X className="w-5 h-5 text-[#D8DEE9]" />
              </button>
            </div>
            <div className="flex-1 p-4 overflow-auto custom-scrollbar">
              {children}
            </div>
          </Card>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};

export default Window;
=== FILE: ./src/components/dashboard/types/index.ts ===

import { ReactNode } from 'react';

export interface CommandItem {
  id: string;
  name: string;
  description?: string;
  shortcut?: string;
  action: () => void;
  category: 'navigation';
}

export interface BentoItem {
  title: string;
  description: string;
  icon: ReactNode;
  className: string;
  component: ReactNode;
  hoverColor: string;
}
=== FILE: ./src/components/dashboard/NordicBackground.tsx ===

// @/components/dashboard/NordicBackground.tsx
import { motion } from "framer-motion";

export const NordicBackground = () => (
  <>
    <div className="absolute inset-0 bg-gradient-to-b from-background to-base-200">
      {[1, 2, 3].map((i) => (
        <motion.div
          key={i}
          className="absolute inset-0"
          animate={{
            opacity: [0.3, 0.5, 0.3],
            scale: [1, 1.1, 1],
            x: [0, 10, 0],
            y: [0, -10, 0],
          }}
          transition={{
            duration: 8 + i * 2,
            repeat: Infinity,
            repeatType: "reverse",
          }}
        >
          <div className={`absolute inset-0 bg-[radial-gradient(circle_at_${10 + i * 20}%_${-20 + i * 10}%,hsl(var(--info)),transparent_${10 + i * 10}%)]`} />
        </motion.div>
      ))}
    </div>
    
    <div className="absolute inset-0">
      {[...Array(20)].map((_, i) => (
        <motion.div
          key={i}
          className="absolute w-1 h-1 bg-info/30 rounded-full"
          style={{
            top: `${Math.random() * 100}%`,
            left: `${Math.random() * 100}%`,
          }}
          animate={{
            y: [-20, 20],
            opacity: [0, 1, 0],
          }}
          transition={{
            duration: 3 + Math.random() * 2,
            repeat: Infinity,
            delay: Math.random() * 2,
          }}
        />
      ))}
    </div>
    
    <div className="absolute inset-0 bg-[linear-gradient(to_right,hsl(var(--base-300))_1px,transparent_1px),linear-gradient(to_bottom,hsl(var(--base-300))_1px,transparent_1px)] bg-[size:4rem_4rem] opacity-10" />
  </>
);

export default NordicBackground;
=== FILE: ./src/components/wiki/WikiWelcome.tsx ===

import React from 'react';
import { Card } from "@/components/ui/card";
import { Pin, Clock, Tag, FolderOpen } from "lucide-react";
import { useWiki } from '@/lib/context/WikiContext';
import { formatDistanceToNow } from 'date-fns';

export default function WelcomeScreen() {
  const { documents, selectDocument } = useWiki();

  const pinnedDocs = documents.filter(doc => doc.isPinned);
  const recentDocs = documents
    .filter(doc => !doc.isPinned)
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
    .slice(0, 5);

  // Calculate statistics
  const totalDocs = documents.length;
  const publicDocs = documents.filter(doc => !doc.restricted).length;
  const categories = [...new Set(documents.map(doc => doc.category))];

  return (
    <div className="p-8 max-w-6xl mx-auto">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold mb-4">Welcome to the Wiki</h1>
        <p className="text-xl text-muted-foreground">
          Your central hub for documentation and knowledge sharing
        </p>
      </div>

      {/* Quick Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12">
        <div className="bg-primary/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-primary mb-2">{totalDocs}</h3>
          <p className="text-sm text-muted-foreground">Total Documents</p>
        </div>
        <div className="bg-secondary/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-secondary mb-2">{categories.length}</h3>
          <p className="text-sm text-muted-foreground">Categories</p>
        </div>
        <div className="bg-accent/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-accent mb-2">{publicDocs}</h3>
          <p className="text-sm text-muted-foreground">Public Documents</p>
        </div>
      </div>

      {pinnedDocs.length > 0 && (
        <div className="mb-8">
          <div className="flex items-center gap-2 mb-4">
            <Pin className="w-5 h-5" />
            <h2 className="text-xl font-semibold">Pinned Documents</h2>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {pinnedDocs.map(doc => (
              <Card
                key={doc.id}
                className="p-4 cursor-pointer hover:bg-muted/50 transition-colors"
                onClick={() => selectDocument(doc.id)}
              >
                <h3 className="font-medium mb-2">{doc.title}</h3>
                <div className="text-sm text-muted-foreground mb-2 flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {doc.category}
                </div>
                {doc.tags && doc.tags.length > 0 && (
                  <div className="flex items-center gap-2 text-sm text-muted-foreground">
                    <Tag className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </Card>
            ))}
          </div>
        </div>
      )}

      <div>
        <div className="flex items-center gap-2 mb-4">
          <Clock className="w-5 h-5" />
          <h2 className="text-xl font-semibold">Recently Updated</h2>
        </div>
        <div className="space-y-2">
          {recentDocs.map(doc => (
            <div
              key={doc.id}
              className="p-4 border rounded-lg cursor-pointer hover:bg-muted/50 transition-colors"
              onClick={() => selectDocument(doc.id)}
            >
              <div className="flex items-center justify-between mb-1">
                <h3 className="font-medium">{doc.title}</h3>
                <span className="text-sm text-muted-foreground">
                  {formatDistanceToNow(new Date(doc.updatedAt), { addSuffix: true })}
                </span>
              </div>
              <div className="flex items-center gap-4 text-sm text-muted-foreground">
                <div className="flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {doc.category}
                </div>
                {doc.tags && doc.tags.length > 0 && (
                  <div className="flex items-center gap-2">
                    <Tag className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { useWiki } from '@/lib/context/WikiContext';

export function WikiHeader() {
  const { 
    isUnlocked,
    setIsUnlocked,
    setIsPasswordPromptOpen,
    setIsAddDocumentOpen,
    setIsUploadDialogOpen
  } = useWiki();

  const handleUnlockToggle = (checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  };

  const handleAddDocument = () => {
    if (!isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else {
      setIsAddDocumentOpen(true);
    }
  };

  const handleUploadDocument = () => {
    if (!isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else {
      setIsUploadDialogOpen(true);
    }
  };

  return (
    <div className="flex-shrink-0 p-4 bg-base-300 border-b">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <h1 className="text-2xl font-bold">Wiki Documents</h1>
          <p className="text-[#D8DEE9]/80">
            Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to search
          </p>
        </div>
        
        <div className="flex items-center space-x-4">
          <Button onClick={handleAddDocument}>
            Add New Page
          </Button>
          <Button variant="outline" onClick={handleUploadDocument}>
            Upload Word Document
          </Button>
          <div className="flex items-center space-x-2">
            <Switch
              id="lock-mode"
              checked={isUnlocked}
              onCheckedChange={handleUnlockToggle}
            />
            <Label htmlFor="lock-mode">
              {isUnlocked ? 'Unlocked' : 'Locked'}
            </Label>
          </div>
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/CategoryManager.tsx ===

// @/components/wiki/CategoryManager.tsx
import React, { useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus, Edit2, Trash2, GripVertical, ChevronRight, ChevronDown } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { CategoryWithHierarchy, Tag } from '@/lib/types/wiki';
import { cn } from "@/lib/utils";

interface CategoryManagerProps {
  categories: CategoryWithHierarchy[];
  onCategoryCreate: (name: string, parentId?: number) => Promise<void>;
  onCategoryUpdate: (id: number, name: string) => Promise<void>;
  onCategoryDelete: (id: number) => Promise<void>;
  onCategoryMove: (id: number, parentId: number | null) => Promise<void>;
  onCategoryReorder: (id: number, newOrder: number) => Promise<void>;
}

const CategoryManager: React.FC<CategoryManagerProps> = ({
  categories,
  onCategoryCreate,
  onCategoryUpdate,
  onCategoryDelete,
  onCategoryMove,
  onCategoryReorder,
}) => {
  const [expandedCategories, setExpandedCategories] = useState<Set<number>>(new Set());
  const [draggedCategory, setDraggedCategory] = useState<number | null>(null);
  const [editCategory, setEditCategory] = useState<{ id: number; name: string } | null>(null);
  const [newCategoryName, setNewCategoryName] = useState("");
  const [selectedParentId, setSelectedParentId] = useState<number | null>(null);

  const toggleExpanded = (categoryId: number) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      if (newSet.has(categoryId)) {
        newSet.delete(categoryId);
      } else {
        newSet.add(categoryId);
      }
      return newSet;
    });
  };

  const handleDragStart = (e: React.DragEvent, categoryId: number) => {
    setDraggedCategory(categoryId);
    e.dataTransfer.setData('text/plain', categoryId.toString());
  };

  const handleDragOver = (e: React.DragEvent, categoryId: number) => {
    e.preventDefault();
    if (draggedCategory === categoryId) return;
    
    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;
    
    target.classList.remove('border-t-2', 'border-b-2');
    if (y < rect.height / 3) {
      target.classList.add('border-t-2');
    } else if (y > (rect.height * 2) / 3) {
      target.classList.add('border-b-2');
    }
  };

  const handleDrop = async (e: React.DragEvent, targetId: number) => {
    e.preventDefault();
    if (!draggedCategory) return;

    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;

    if (y < rect.height / 3) {
      // Drop above
      await onCategoryReorder(draggedCategory, targetId - 0.5);
    } else if (y > (rect.height * 2) / 3) {
      // Drop below
      await onCategoryReorder(draggedCategory, targetId + 0.5);
    } else {
      // Drop as child
      await onCategoryMove(draggedCategory, targetId);
    }

    setDraggedCategory(null);
    target.classList.remove('border-t-2', 'border-b-2');
  };

  const renderCategory = (category: CategoryWithHierarchy) => {
    const isExpanded = expandedCategories.has(category.id);
    
    return (
      <div key={category.id}>
        <div
          className={cn(
            "flex items-center p-2 rounded-lg hover:bg-muted/50 cursor-pointer",
            draggedCategory === category.id && "opacity-50"
          )}
          draggable
          onDragStart={(e) => handleDragStart(e, category.id)}
          onDragOver={(e) => handleDragOver(e, category.id)}
          onDrop={(e) => handleDrop(e, category.id)}
          style={{ marginLeft: `${category.level * 1.5}rem` }}
        >
          <button
            className="mr-2"
            onClick={() => toggleExpanded(category.id)}
          >
            {category.children.length > 0 && (
              isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />
            )}
          </button>
          
          <GripVertical className="w-4 h-4 mr-2 cursor-grab" />
          
          <span className="flex-1">{category.name}</span>
          
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                setEditCategory({ id: category.id, name: category.name });
              }}
            >
              <Edit2 size={16} />
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                onCategoryDelete(category.id);
              }}
            >
              <Trash2 size={16} />
            </Button>
          </div>
        </div>
        
        {isExpanded && (
          <motion.div
            initial={{ height: 0 }}
            animate={{ height: "auto" }}
            exit={{ height: 0 }}
          >
            {category.children.map(renderCategory)}
          </motion.div>
        )}
      </div>
    );
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Categories</h2>
        <Button onClick={() => setEditCategory({ id: -1, name: '' })}>
          <Plus size={16} className="mr-2" />
          Add Category
        </Button>
      </div>

      <div className="space-y-1">
        {categories.map(renderCategory)}
      </div>

      <Dialog open={!!editCategory} onOpenChange={() => setEditCategory(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {editCategory?.id === -1 ? 'Add Category' : 'Edit Category'}
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={editCategory?.name ?? ''}
                onChange={(e) => setEditCategory(prev => prev ? { ...prev, name: e.target.value } : null)}
                placeholder="Category name"
              />
            </div>

            {editCategory?.id === -1 && (
              <div>
                <select
                  value={selectedParentId?.toString() ?? ''}
                  onChange={(e) => setSelectedParentId(e.target.value ? Number(e.target.value) : null)}
                  className="w-full p-2 rounded-md border"
                >
                  <option value="">No parent (root category)</option>
                  {categories.map(cat => (
                    <option key={cat.id} value={cat.id}>
                      {'  '.repeat(cat.level)}{cat.name}
                    </option>
                  ))}
                </select>
              </div>
            )}

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setEditCategory(null)}>
                Cancel
              </Button>
              <Button
                onClick={async () => {
                  if (editCategory) {
                    if (editCategory.id === -1) {
                      await onCategoryCreate(editCategory.name, selectedParentId ?? undefined);
                    } else {
                      await onCategoryUpdate(editCategory.id, editCategory.name);
                    }
                    setEditCategory(null);
                  }
                }}
              >
                {editCategory?.id === -1 ? 'Create' : 'Update'}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default CategoryManager;
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useWiki } from '@/lib/context/WikiContext';
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content?: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

// src/components/wiki/FileUpload.tsx
import React, { useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { toast } from 'sonner';
import { useWiki } from '@/lib/context/WikiContext';

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string;
    content: string;
    category: string;
    restricted: boolean;
  }) => void;
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const { categories } = useWiki();
  const [file, setFile] = useState<File | null>(null);
  const [title, setTitle] = useState('');
  const [category, setCategory] = useState('General');
  const [restricted, setRestricted] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    console.log('Files dropped:', acceptedFiles);
    if (acceptedFiles.length > 0) {
      const uploadedFile = acceptedFiles[0];
      console.log('File details:', {
        name: uploadedFile.name,
        size: uploadedFile.size,
        type: uploadedFile.type
      });
      setFile(uploadedFile);
      setTitle(uploadedFile.name.replace(/\.[^/.]+$/, ""));
    }
  }, []);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    },
    multiple: false,
    noKeyboard: true
  });

  const handleUpload = async () => {
    if (!file) {
      toast.error('Please select a file');
      return;
    }
    
    setIsProcessing(true);
    console.log('Starting file upload processing:', {
      fileName: file.name,
      fileSize: file.size,
      title,
      category
    });

    const formData = new FormData();
    formData.append('file', file);

    try {
      console.log('Sending file to server...');
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || errorData.details || 'Upload failed');
      }

      const data = await response.json();
      console.log('Server response:', {
        contentLength: data.content?.length,
        hasMessages: Boolean(data.messages),
        messageCount: data.messages?.length
      });

      // Validate the converted content
      if (!data.content || data.content.trim().length === 0) {
        throw new Error('Document conversion resulted in empty content');
      }

      // Process the document
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      });

      console.log('Document processed successfully');
      toast.success('File uploaded and converted successfully');
      
    } catch (error) {
      console.error('Upload/conversion error:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to process file');
    } finally {
      setIsProcessing(false);
      setFile(null);
    }
  };

  return (
    <div className="space-y-4">
      <div 
        {...getRootProps()} 
        className={`border-2 border-dashed rounded-lg p-6 text-center transition-colors cursor-pointer
          ${isDragActive ? 'border-primary bg-primary/10' : 'border-gray-300'}
          ${isProcessing ? 'opacity-50 cursor-not-allowed' : 'hover:border-primary'}`}
      >
        <input {...getInputProps()} disabled={isProcessing} />
        {isDragActive ? (
          <p>Drop the file here...</p>
        ) : (
          <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select"}</p>
        )}
      </div>

      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input 
              id="title" 
              value={title} 
              onChange={(e) => setTitle(e.target.value)}
              disabled={isProcessing}
            />
          </div>

          <div>
            <Label htmlFor="category">Category</Label>
            <Select 
              value={category} 
              onValueChange={setCategory}
              disabled={isProcessing}
            >
              <SelectTrigger>
                <SelectValue placeholder="Choose a category" />
              </SelectTrigger>
              <SelectContent>
                {categories.map((cat) => (
                  <SelectItem key={cat.id} value={cat.name}>
                    {'  '.repeat(cat.level)}{cat.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex items-center space-x-2">
            <Switch
              id="restricted"
              checked={restricted}
              onCheckedChange={setRestricted}
              disabled={isProcessing}
            />
            <Label htmlFor="restricted">Restricted</Label>
          </div>

          <Button
            onClick={handleUpload}
            disabled={isProcessing}
            className="w-full"
          >
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  );
};
=== FILE: ./src/components/wiki/TagManager.tsx ===

// @/components/wiki/TagManager.tsx
import React, { useState } from 'react';
import { Plus, X } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Tag } from '@/lib/types/wiki';

interface TagManagerProps {
  tags: Tag[];
  onTagCreate: (name: string, color: string) => Promise<void>;
  onTagDelete: (id: number) => Promise<void>;
  onTagsChange: (documentId: number, tagIds: number[]) => Promise<void>;
}

const TagManager: React.FC<TagManagerProps> = ({
  tags,
  onTagCreate,
  onTagDelete,
  onTagsChange,
}) => {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [newTag, setNewTag] = useState({ name: '', color: '#3B82F6' });

  const handleCreateTag = async () => {
    await onTagCreate(newTag.name, newTag.color);
    setNewTag({ name: '', color: '#3B82F6' });
    setIsDialogOpen(false);
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Tags</h2>
        <Button onClick={() => setIsDialogOpen(true)}>
          <Plus size={16} className="mr-2" />
          Add Tag
        </Button>
      </div>

      <div className="flex flex-wrap gap-2">
        {tags.map(tag => (
          <div
            key={tag.id}
            className="flex items-center gap-2 px-3 py-1 rounded-full"
            style={{ backgroundColor: tag.color + '20', color: tag.color }}
          >
            <span>{tag.name}</span>
            <button
              onClick={() => onTagDelete(tag.id)}
              className="hover:opacity-75"
            >
              <X size={14} />
            </button>
          </div>
        ))}
      </div>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add Tag</DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={newTag.name}
                onChange={(e) => setNewTag(prev => ({ ...prev, name: e.target.value }))}
                placeholder="Tag name"
              />
            </div>

            <div>
              <input
                type="color"
                value={newTag.color}
                onChange={(e) => setNewTag(prev => ({ ...prev, color: e.target.value }))}
                className="w-full h-10 p-1 rounded border"
              />
            </div>

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleCreateTag}>
                Create
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default TagManager;
=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import { useWiki } from '@/lib/context/WikiContext';
import { cn } from "@/lib/utils";

export default function WikiSearch() {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<Array<any>>([]);
  const searchRef = useRef<HTMLInputElement>(null);
  const { documents, selectDocument } = useWiki();

  // Handle keyboard shortcut
  export function WikiSearch({ onOpen }: { onOpen: () => void }) {
    useEffect(() => {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.ctrlKey && e.code === 'Space') {
          e.preventDefault();
          onOpen();
        }
      };

      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onOpen]);

  // Search functionality
  const handleSearch = (value: string) => {
    setSearchQuery(value);
    if (!value.trim()) {
      setSearchResults([]);
      return;
    }

    const query = value.toLowerCase();
    const results = documents.filter(doc => 
      doc.title.toLowerCase().includes(query) ||
      doc.content.toLowerCase().includes(query) ||
      doc.category.toLowerCase().includes(query)
    );

    setSearchResults(results);
  };

  return (
    <div className="relative w-full">
      <Input
        ref={searchRef}
        type="text"
        value={searchQuery}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search documents... (Ctrl + Space)"
        onFocus={() => setIsOpen(true)}
        className="pl-10 py-6 text-lg"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.map((doc) => (
                <div
                  key={doc.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    selectDocument(doc.id);
                    setIsOpen(false);
                    setSearchQuery('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">{doc.title}</span>
                      <span className="text-xs text-muted-foreground">
                        {doc.category}
                      </span>
                    </div>
                    <p className="text-sm text-muted-foreground line-clamp-2">
                      {doc.content}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// src/components/wiki/WikiContent.tsx
import dynamic from 'next/dynamic';
import { useWiki } from '@/lib/context/WikiContext';
import WikiDocument from '@/components/wiki/WikiDocument';
import WelcomeScreen from './WikiWelcome';
import { Suspense } from 'react';

// Change the dynamic import to include a longer timeout and error boundary
const MarkdownEditor = dynamic(
  () => import('@/components/wiki/MarkdownEditor').catch(err => {
    console.error('Failed to load MarkdownEditor:', err);
    // Return a fallback component
    return () => (
      <div className="p-4 text-red-500">
        Failed to load editor. Please refresh the page and try again.
      </div>
    );
  }),
  {
    loading: () => <div className="p-4">Loading editor...</div>,
    ssr: false,
    timeout: 10000  // Increase timeout to 10 seconds
  }
);

export function WikiContent() {
  const {
    selectedDocument,
    isEditing,
    isUnlocked,
    updateDocument,
    setIsEditing,
  } = useWiki();

  console.log('WikiContent rendered:', {
    selectedDocumentId: selectedDocument?.id,
    isEditing
  });

  if (!selectedDocument) {
    return <WelcomeScreen />;
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <Suspense fallback={<div className="p-4">Loading editor...</div>}>
          <MarkdownEditor
            documentId={selectedDocument.id}
            initialTitle={selectedDocument.title}
            initialContent={selectedDocument.content}
            onSave={async (title, content) => {
              await updateDocument(selectedDocument.id, { title, content });
              setIsEditing(false);
            }}
            onCancel={() => setIsEditing(false)}
          />
        </Suspense>
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={updateDocument}
        onEdit={() => setIsEditing(true)}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React, { Suspense, lazy } from 'react';
import { toast } from 'sonner';
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Breadcrumb, BreadcrumbItem, BreadcrumbLink } from "@/components/ui/breadcrumb";
import { Lock, Pencil } from 'lucide-react';
import { Document } from '@/lib/types/wiki';

// Lazy load the markdown preview component
const MarkdownPreview = lazy(() => import('@uiw/react-markdown-preview'));

interface WikiDocumentProps {
  document: Document;
  isUnlocked: boolean;
  onDocumentUpdate: (id: number, updates: Partial<Document>) => Promise<void>;
  onEdit: () => void;
}

// Loading placeholder for markdown content
const MarkdownLoading = () => (
  <div className="animate-pulse">
    <div className="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
    <div className="h-4 bg-gray-200 rounded w-1/2 mb-4"></div>
    <div className="h-4 bg-gray-200 rounded w-5/6"></div>
  </div>
);

export default function WikiDocument({ 
  document, 
  isUnlocked, 
  onDocumentUpdate,
  onEdit
}: WikiDocumentProps) {
  if (!document) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        No document selected
      </div>
    );
  }

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleString(undefined, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const canEdit = isUnlocked || !document.restricted;

  return (
    <div className="w-full h-full bg-background text-foreground">
      {/* Header section */}
      <div className="p-6 border-b">
        <Breadcrumb>
          <BreadcrumbItem>
            <BreadcrumbLink>Wiki</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem>
            <BreadcrumbLink>{document.category}</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem isCurrentPage>
            <span className="font-medium">{document.title}</span>
          </BreadcrumbItem>
        </Breadcrumb>

        <div className="mt-4 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <h1 className="text-2xl font-bold">{document.title}</h1>
            {document.restricted && (
              <Lock className="w-5 h-5 text-warning" />
            )}
          </div>

          <div className="flex items-center gap-2">
            {canEdit && (
              <Button
                variant="ghost"
                size="sm"
                onClick={onEdit}
                title="Edit document"
              >
                <Pencil className="w-4 h-4" />
              </Button>
            )}
          </div>
        </div>

        {document.tags && document.tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mt-4">
            {document.tags.map(tag => (
              <Badge
                key={tag.id}
                variant="outline"
                style={{
                  borderColor: tag.color,
                  color: tag.color,
                  backgroundColor: `${tag.color}10`
                }}
              >
                {tag.name}
              </Badge>
            ))}
          </div>
        )}

        <div className="text-sm text-muted-foreground mt-4">
          Last updated: {formatDate(document.updatedAt)}
        </div>
      </div>

      {/* Content section with lazy loading */}
      <div className="p-6 prose dark:prose-invert max-w-none">
        <Suspense fallback={<MarkdownLoading />}>
          <MarkdownPreview 
            source={document.content} 
            style={{
              backgroundColor: 'var(--background)',
              color: 'var(--foreground)',
            }}
            rehypePlugins={[]}
            remarkPlugins={[]}
          />
        </Suspense>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
import { useWiki } from '@/lib/context/WikiContext';
import { Button } from "@/components/ui/button";
import { IconFileText, IconLock, IconEdit, IconTrash } from '@tabler/icons-react';

export default function WikiDocumentList() {
  const { 
    documents,
    selectedDocument,
    isUnlocked,
    selectDocument,
    deleteDocument,
    setIsEditing,
    isLoading
  } = useWiki();

  if (isLoading) {
    return (
      <div className="p-4 text-center">Loading documents...</div>
    );
  }

  const groupedDocuments = documents.reduce((acc, doc) => {
    if (!acc[doc.category]) {
      acc[doc.category] = [];
    }
    acc[doc.category].push(doc);
    return acc;
  }, {} as Record<string, typeof documents>);

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        {Object.entries(groupedDocuments).map(([category, docs]) => (
          <div key={category} className="mb-6">
            <h2 className="text-lg font-semibold mb-2">{category}</h2>
            <div className="space-y-2">
              {docs.map((doc) => (
                <div
                  key={doc.id}
                  className={`
                    border rounded-md overflow-hidden shadow-sm
                    ${doc.restricted && !isUnlocked ? 'opacity-50' : ''}
                    ${selectedDocument?.id === doc.id ? 'ring-2 ring-primary' : ''}
                  `}
                >
                  <div
                    className={`
                      flex items-center justify-between p-2
                      ${doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'}
                    `}
                    onClick={() => {
                      if (!(doc.restricted && !isUnlocked)) {
                        selectDocument(doc.id);
                      }
                    }}
                  >
                    <span className={doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'}>
                      {doc.title}
                    </span>
                    <div className="flex items-center space-x-2">
                      {doc.restricted && (
                        <IconLock size={16} className="text-warning" />
                      )}
                      {(!doc.restricted || isUnlocked) && (
                        <>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              selectDocument(doc.id);
                              setIsEditing(true);
                            }}
                          >
                            <IconEdit size={16} />
                            <span className="sr-only">Edit</span>
                          </Button>
                          {isUnlocked && (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={(e) => {
                                e.stopPropagation();
                                deleteDocument(doc.id);
                              }}
                            >
                              <IconTrash size={16} />
                              <span className="sr-only">Delete</span>
                            </Button>
                          )}
                        </>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;
    e.stopPropagation();

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        onClose();
        break;
    }
  };

  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true);
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm flex items-center justify-center"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <motion.div
              initial={{ scale: 0.95, opacity: 0, y: -20 }}
              animate={{ scale: 1, opacity: 1, y: 0 }}
              exit={{ scale: 0.95, opacity: 0, y: -20 }}
              className="w-full max-w-5xl mx-4 bg-background rounded-xl shadow-2xl overflow-hidden"
              onClick={stopPropagation}
            >
              <div className="p-6 border-b">
                <div className="relative">
                  <Input
                    ref={searchRef}
                    type="text"
                    value={inputValue}
                    onChange={handleInputChange}
                    placeholder="Search documents..."
                    className="pl-20 py-6 text-lg"
                    autoFocus
                  />
                  <Search className="w-6 h-6 absolute left-4 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                </div>
              </div>

              <div 
                ref={resultsRef}
                className="max-h-[400px] overflow-y-auto"
              >
                {searchResults.length === 0 && inputValue.trim() !== '' && (
                  <div className="p-8 text-center text-lg text-muted-foreground">
                    No results found
                  </div>
                )}
                <div className="h-auto">
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-6 min-h-[100px]",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-3 mb-2">
                        <FileText className="w-5 h-5 flex-shrink-0 text-muted-foreground" />
                        <span className="text-lg font-medium truncate">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-sm flex-shrink-0 text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-base text-muted-foreground ml-8 line-clamp-2">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="line-clamp-1">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
                {searchResults.length > 10 && (
                  <div className="p-4 text-center text-base text-muted-foreground">
                    {searchResults.length - 10} more results...
                  </div>
                )}
              </div>
            </motion.div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useCallback, useEffect, useMemo } from 'react';
import dynamic from 'next/dynamic';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import debounce from 'lodash/debounce';
import 'easymde/dist/easymde.min.css';

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { 
  ssr: false,
  loading: () => <div className="p-4">Loading editor...</div>
});

interface MarkdownEditorProps {
  documentId: number;
  initialTitle: string;
  initialContent: string;
  onSave: (title: string, content: string) => Promise<void>;
  onCancel: () => void;
}

export default function MarkdownEditor({
  documentId,
  initialTitle,
  initialContent,
  onSave,
  onCancel
}: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle);
  const [content, setContent] = useState(initialContent);
  const [isSaving, setIsSaving] = useState(false);

  // Memoize editor options for better performance
  const options = useMemo(() => ({
    spellChecker: false,
    status: false,
    minHeight: '400px',
    maxHeight: '600px',
    autofocus: true,
    renderingConfig: {
      singleLineBreaks: false,
      codeSyntaxHighlighting: true,
    },
    previewImagesInEditor: false, // Disable image preview in editor
    sideBySideFullscreen: false,
    hideIcons: ['image', 'side-by-side', 'fullscreen'],
    showIcons: ['bold', 'italic', 'heading', 'code', 'quote', 'unordered-list', 'ordered-list', 'link'],
    toolbar: [
      'bold', 'italic', 'heading', '|',
      'quote', 'code', '|',
      'unordered-list', 'ordered-list', '|',
      'link',
      {
        name: 'custom-image',
        action: function customFunction(editor) {
          const cm = editor.codemirror;
          const url = prompt('Enter image URL (recommended max size: 1MB):');
          if (url) {
            const text = `![](${url})`;
            cm.replaceSelection(text);
          }
        },
        className: 'fa fa-picture-o',
        title: 'Add Image',
      }
    ],
  }), []);

  // Debounced content update
  const debouncedSetContent = useCallback(
    debounce((value: string) => {
      setContent(value);
    }, 150),
    []
  );

  // Handle content change
  const handleContentChange = useCallback((value: string) => {
    debouncedSetContent(value);
  }, [debouncedSetContent]);

  // Handle save
  const handleSave = async () => {
    if (isSaving) return;
    setIsSaving(true);
    try {
      await onSave(title, content);
      toast.success('Document saved successfully');
    } catch (error) {
      console.error('Error saving document:', error);
      toast.error('Failed to save document');
    } finally {
      setIsSaving(false);
    }
  };

  // Cleanup
  useEffect(() => {
    return () => {
      debouncedSetContent.cancel();
    };
  }, [debouncedSetContent]);

  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = async (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        await handleSave();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleSave, onCancel]);

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="Document Title"
          className="text-xl font-bold"
        />
      </div>

      <div className="flex-1 overflow-auto">
        <SimpleMDE
          value={content}
          onChange={handleContentChange}
          options={options}
        />
      </div>

      <div className="p-4 border-t flex justify-between items-center">
        <div className="text-sm text-muted-foreground">
          Press Ctrl + S to save
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button 
            onClick={handleSave}
            disabled={isSaving}
          >
            {isSaving ? 'Saving...' : 'Save'}
          </Button>
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/AddDocument.tsx ===

// src/components/wiki/AddDocument.tsx
import React, { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Category, Tag } from '@/lib/types/wiki';
import { X } from 'lucide-react';

interface AddDocumentProps {
  categories: Category[];
  tags: Tag[];
  onCreateDocument: (
    title: string,
    category: string,
    restricted: boolean,
    tagIds: number[],
    content?: string
  ) => Promise<void>;
  onClose?: () => void;
}

export default function AddDocument({
  categories,
  tags,
  onCreateDocument,
  onClose
}: AddDocumentProps) {
  console.log('AddDocument render with categories:', categories);
  
  const [title, setTitle] = useState("");
  const [category, setCategory] = useState("");
  const [restricted, setRestricted] = useState(false);
  const [selectedTags, setSelectedTags] = useState<number[]>([]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    console.log('Submitting document with category:', category);
    
    try {
      await onCreateDocument(title, category || "General", restricted, selectedTags);
      setTitle("");
      setCategory("");
      setRestricted(false);
      setSelectedTags([]);
      if (onClose) onClose();
    } catch (error) {
      console.error('Error creating document:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>

      <div>
        <Label htmlFor="category">Category</Label>
        <Select 
          value={category} 
          onValueChange={(value) => {
            console.log('Category selected:', value);
            setCategory(value);
          }}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="General">General</SelectItem>
            {categories.map((cat) => (
              <SelectItem key={cat.id} value={cat.name}>
                {cat.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div>
        <Label>Tags</Label>
        <div className="flex flex-wrap gap-2 mt-2">
          {tags.map(tag => (
            <Badge
              key={tag.id}
              variant={selectedTags.includes(tag.id) ? "default" : "outline"}
              className="cursor-pointer"
              style={{
                backgroundColor: selectedTags.includes(tag.id) ? tag.color + '20' : 'transparent',
                borderColor: tag.color,
                color: selectedTags.includes(tag.id) ? tag.color : 'inherit'
              }}
              onClick={() => {
                setSelectedTags(prev => 
                  prev.includes(tag.id)
                    ? prev.filter(id => id !== tag.id)
                    : [...prev, tag.id]
                );
              }}
            >
              {tag.name}
            </Badge>
          ))}
        </div>
      </div>

      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>

      <Button type="submit">Create Document</Button>
    </form>
  );
}
=== FILE: ./src/components/wiki/KeyboardShortcutsHelp.tsx ===

export const KeyboardShortcutsHelp = ({ shortcuts }: { shortcuts: KeyboardShortcuts }) => {
    const groupedShortcuts = Object.values(shortcuts).reduce((acc, shortcut) => {
      if (!acc[shortcut.group]) {
        acc[shortcut.group] = [];
      }
      acc[shortcut.group].push(shortcut);
      return acc;
    }, {} as Record<string, KeyBinding[]>);
  
    return (
      <div className="space-y-6">
        {Object.entries(groupedShortcuts).map(([group, bindings]) => (
          <div key={group}>
            <h3 className="text-lg font-medium mb-2">{group}</h3>
            <div className="space-y-2">
              {bindings.map((binding) => (
                <div key={binding.key} className="flex justify-between">
                  <span>{binding.description}</span>
                  <kbd className="px-2 py-1 bg-muted rounded text-sm">
                    {binding.key.split('+').map(k => k.charAt(0).toUpperCase() + k.slice(1)).join(' + ')}
                  </kbd>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    );
  };
=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { AlertCircle } from 'lucide-react';

interface PasswordPromptModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (password: string) => Promise<void>;
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!password.trim()) {
      setError('Please enter a password');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      await onSubmit(password);
      setPassword(''); // Clear on success
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Invalid password');
      setPassword(''); // Clear on error
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleClose = () => {
    setPassword('');
    setError(null);
    onClose();
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPassword(e.target.value);
    if (error) setError(null);
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Input
              type="password"
              value={password}
              onChange={handleInputChange}
              placeholder="Enter password"
              disabled={isSubmitting}
              autoFocus
              aria-invalid={!!error}
            />
            {error && (
              <div className="flex items-center gap-2 text-sm text-destructive">
                <AlertCircle className="h-4 w-4" />
                <span>{error}</span>
              </div>
            )}
          </div>
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Verifying...' : 'Submit'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
=== FILE: ./src/components/ui/button.tsx ===

// src/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
=== FILE: ./src/components/ui/progress.tsx ===

"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
=== FILE: ./src/components/ui/FileUploadButton.tsx ===

"use client";
import React, { useState } from "react";
import { FileUpload } from "@/components/ui/FileUpload";

export function FileUploadButton() {
  const [files, setFiles] = useState<File[]>([]);
  const handleFileUpload = (files: File[]) => {
    setFiles(files);
    console.log(files);
  };

  return (
    <div className="w-full max-w-4xl mx-auto min-h-96 border border-dashed bg-white dark:bg-black border-neutral-200 dark:border-neutral-800 rounded-lg">
      <FileUpload onChange={handleFileUpload} />
    </div>
  );
}

=== FILE: ./src/components/ui/card.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

=== FILE: ./src/components/ui/theme-toggle.tsx ===

import React from 'react';
import { useTheme } from 'next-themes';
import { Switch } from '@/components/ui/switch';
import { Sun, Moon } from 'lucide-react';

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();
  const [mounted, setMounted] = React.useState(false);

  // Prevent hydration mismatch
  React.useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) return null;

  const isLight = theme === 'nordlight';

  return (
    <div className="flex items-center space-x-2">
      <Sun className={`h-4 w-4 transition-all ${isLight ? 'text-primary' : 'text-muted-foreground'}`} />
      <Switch
        checked={!isLight}
        onCheckedChange={(checked) => {
          setTheme(checked ? 'norddark' : 'nordlight');
        }}
        className="data-[state=checked]:bg-primary"
      />
      <Moon className={`h-4 w-4 transition-all ${!isLight ? 'text-primary' : 'text-muted-foreground'}`} />
    </div>
  );
}

=== FILE: ./src/components/ui/background-gradient.tsx ===

import { cn } from "@/lib/utils";
import React from "react";
import { motion } from "framer-motion";

export const BackgroundGradient = ({
  children,
  className,
  containerClassName,
  animate = true,
}: {
  children?: React.ReactNode;
  className?: string;
  containerClassName?: string;
  animate?: boolean;
}) => {
  const variants = {
    initial: {
      backgroundPosition: "0 50%",
    },
    animate: {
      backgroundPosition: ["0, 50%", "100% 50%", "0 50%"],
    },
  };
  return (
    <div className={cn("relative p-[4px] group", containerClassName)}>
      <motion.div
        variants={animate ? variants : undefined}
        initial={animate ? "initial" : undefined}
        animate={animate ? "animate" : undefined}
        transition={
          animate
            ? {
                duration: 5,
                repeat: Infinity,
                repeatType: "reverse",
              }
            : undefined
        }
        style={{
          backgroundSize: animate ? "400% 400%" : undefined,
        }}
        className={cn(
          "absolute inset-0 rounded-3xl z-[1] opacity-60 group-hover:opacity-100 blur-xl  transition duration-500 will-change-transform",
          " bg-[radial-gradient(circle_farthest-side_at_0_100%,#00ccb1,transparent),radial-gradient(circle_farthest-side_at_100%_0,#7b61ff,transparent),radial-gradient(circle_farthest-side_at_100%_100%,#ffc414,transparent),radial-gradient(circle_farthest-side_at_0_0,#1ca0fb,#141316)]"
        )}
      />
      <motion.div
        variants={animate ? variants : undefined}
        initial={animate ? "initial" : undefined}
        animate={animate ? "animate" : undefined}
        transition={
          animate
            ? {
                duration: 5,
                repeat: Infinity,
                repeatType: "reverse",
              }
            : undefined
        }
        style={{
          backgroundSize: animate ? "400% 400%" : undefined,
        }}
        className={cn(
          "absolute inset-0 rounded-3xl z-[1] will-change-transform",
          "bg-[radial-gradient(circle_farthest-side_at_0_100%,#00ccb1,transparent),radial-gradient(circle_farthest-side_at_100%_0,#7b61ff,transparent),radial-gradient(circle_farthest-side_at_100%_100%,#ffc414,transparent),radial-gradient(circle_farthest-side_at_0_0,#1ca0fb,#141316)]"
        )}
      />

      <div className={cn("relative z-10", className)}>{children}</div>
    </div>
  );
};


=== FILE: ./src/components/ui/breadcrumb.tsx ===

// src/components/ui/breadcrumb.tsx
import * as React from "react"
import { ChevronRight } from "lucide-react"
import { cn } from "@/lib/utils"

export interface BreadcrumbProps extends React.ComponentPropsWithoutRef<"nav"> {
  separator?: React.ReactNode
  children: React.ReactNode
}

export interface BreadcrumbItemProps extends React.ComponentPropsWithoutRef<"li"> {
  isCurrentPage?: boolean
  children: React.ReactNode
}

export interface BreadcrumbLinkProps extends React.ComponentPropsWithoutRef<"a"> {
  children: React.ReactNode
}

const Breadcrumb = React.forwardRef<HTMLElement, BreadcrumbProps>(
  ({ separator = <ChevronRight className="h-4 w-4" />, className, ...props }, ref) => (
    <nav
      ref={ref}
      aria-label="breadcrumb"
      className={cn("relative break-words", className)}
      {...props}
    >
      <ol className="flex items-center gap-2 text-sm text-muted-foreground">{props.children}</ol>
    </nav>
  )
)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbItem = React.forwardRef<HTMLLIElement, BreadcrumbItemProps>(
  ({ isCurrentPage, className, children, ...props }, ref) => (
    <li
      ref={ref}
      className={cn("inline-flex items-center gap-2", className)}
      aria-current={isCurrentPage ? "page" : undefined}
      {...props}
    >
      {children}
    </li>
  )
)
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<HTMLAnchorElement, BreadcrumbLinkProps>(
  ({ className, ...props }, ref) => (
    <a
      ref={ref}
      className={cn(
        "transition-colors hover:text-foreground",
        className
      )}
      {...props}
    >
      {props.children}
    </a>
  )
)
BreadcrumbLink.displayName = "BreadcrumbLink"

export { Breadcrumb, BreadcrumbItem, BreadcrumbLink }
=== FILE: ./src/components/ui/alert.tsx ===

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

=== FILE: ./src/components/ui/form.tsx ===

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/components/ui/context-menu.tsx ===

"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[24rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[24rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

=== FILE: ./src/components/ui/badge.tsx ===

import React from "react";
import { cva } from "class-variance-authority";
import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        success: 
          "border-transparent bg-green-500 text-white hover:bg-green-600",
        warning:
          "border-transparent bg-yellow-500 text-white hover:bg-yellow-600",
        info:
          "border-transparent bg-blue-500 text-white hover:bg-blue-600",
        ghost:
          "border-transparent bg-background/30 text-foreground backdrop-blur-sm",
        premium: 
          "border-transparent bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 text-white",
      },
      size: {
        default: "px-2.5 py-0.5 text-xs",
        sm: "px-2 py-0.25 text-xs",
        lg: "px-3 py-0.75 text-sm",
        xl: "px-4 py-1 text-base"
      },
      animation: {
        none: "",
        pulse: "animate-pulse",
        bounce: "animate-bounce",
        spin: "animate-spin",
        ping: "animate-ping"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default",
      animation: "none"
    },
  }
);

const Badge = React.forwardRef(({ 
  className, 
  variant, 
  size,
  animation,
  icon: Icon,
  children,
  ...props 
}, ref) => {
  return (
    <div
      ref={ref}
      className={cn(badgeVariants({ variant, size, animation }), className)}
      {...props}
    >
      {Icon && (
        <Icon className="w-3 h-3 mr-1" />
      )}
      {children}
    </div>
  );
});

Badge.displayName = "Badge";

export { Badge, badgeVariants };

// Example usage
const ExampleBadges = () => {
  return (
    <div className="flex gap-2 flex-wrap">
      <Badge>Default</Badge>
      <Badge variant="secondary">Secondary</Badge>
      <Badge variant="destructive">Destructive</Badge>
      <Badge variant="outline">Outline</Badge>
      <Badge variant="success">Success</Badge>
      <Badge variant="warning">Warning</Badge>
      <Badge variant="info">Info</Badge>
      <Badge variant="ghost">Ghost</Badge>
      <Badge variant="premium">Premium</Badge>
      
      {/* Sizes */}
      <Badge size="sm">Small</Badge>
      <Badge size="default">Default</Badge>
      <Badge size="lg">Large</Badge>
      <Badge size="xl">Extra Large</Badge>
      
      {/* Animations */}
      <Badge animation="pulse">Pulse</Badge>
      <Badge animation="bounce">Bounce</Badge>
      <Badge animation="ping">Ping</Badge>
      
      {/* With Icons */}
      <Badge icon={Star}>With Icon</Badge>
      <Badge variant="premium" icon={Crown}>Premium</Badge>
    </div>
  );
};

export default ExampleBadges;
=== FILE: ./src/components/ui/multi-step-loader.tsx ===

"use client"

import React from "react"
import { motion } from "framer-motion"
import { cn } from "@/lib/utils"

export interface Step {
  title: string
  description: string
}

interface MultiStepLoaderProps {
  steps: Step[]
  currentStep: number
  className?: string
  variant?: "default" | "success" | "destructive"
  showStepDescription?: boolean
}

export function MultiStepLoader({ 
  steps, 
  currentStep, 
  className,
  variant = "default",
  showStepDescription = true
}: MultiStepLoaderProps) {
  const getStepColor = (isActive: boolean, isCompleted: boolean) => {
    if (variant === "destructive") {
      return isCompleted
        ? "rgb(191 97 106)"  // red-500
        : isActive
        ? "rgb(191 97 106)"  // red-500
        : "rgb(163 190 140)" // slate-400
    }
    
    if (variant === "success") {
      return isCompleted
        ? "rgb(163 190 140)"  // green-500
        : isActive
        ? "rgb(163 190 140)"  // green-500
        : "rgb(163 190 140)" // slate-400
    }

    return isCompleted
      ? "rgb(163 190 140)"    // green-500
      : isActive
      ? "rgb(129 161 193)"   // blue-500
      : "rgb(163 190 140)"  // slate-400
  }

  return (
    <div className={cn("relative", className)}>
      {steps.map((step, index) => {
        const isActive = currentStep === index
        const isCompleted = currentStep > index

        return (
          <div
            key={step.title}
            className={cn(
              "flex items-center gap-4 p-4",
              index !== steps.length - 1 && "border-b border-border"
            )}
          >
            <div className="relative">
              <motion.div
                initial={false}
                animate={{
                  scale: isActive ? 1.2 : 1,
                  backgroundColor: getStepColor(isActive, isCompleted)
                }}
                className="h-4 w-4 rounded-full"
              />
              {index !== steps.length - 1 && (
                <div 
                  className={cn(
                    "absolute left-2 top-4 h-full w-[2px]",
                    isCompleted ? "bg-primary" : "bg-border"
                  )} 
                />
              )}
            </div>
            <div>
              <p
                className={cn(
                  "font-medium",
                  isActive && "text-blue-500",
                  isCompleted && "text-green-500"
                )}
              >
                {step.title}
              </p>
              {showStepDescription && isActive && (
                <p className="text-sm text-muted-foreground">
                  {step.description}
                </p>
              )}
            </div>
          </div>
        )
      })}
    </div>
  )
}
=== FILE: ./src/components/ui/checkbox.tsx ===

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

=== FILE: ./src/components/ui/switch.tsx ===

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

=== FILE: ./src/components/ui/dropdown-menu.tsx ===

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

=== FILE: ./src/components/ui/dialog.tsx ===

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        "bg-red dark:bg-base-100", // Explicit background color
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-base-content font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

=== FILE: ./src/components/ui/table.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

=== FILE: ./src/components/ui/sonner.tsx ===

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }

=== FILE: ./src/components/ui/alert-dialog.tsx ===

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

=== FILE: ./src/components/ui/select.tsx ===

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        "select-content",
        className
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn("select-item", className)}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
}

=== FILE: ./src/components/ui/csv-form.tsx ===

"use client";
import React, { useEffect, useState } from 'react';
import { Label } from "./label";
import { Input } from "./input";
import { cn } from "@/lib/utils";
import { IconX } from "@tabler/icons-react";

interface CsvFormProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: Record<string, string>) => void;
  initialData?: Record<string, string>;
  mode: 'add' | 'edit';
}

const BottomGradient = () => {
  return (
    <>
      <span className="group-hover/btn:opacity-100 block transition duration-500 opacity-0 absolute h-px w-full -bottom-px inset-x-0 bg-gradient-to-r from-transparent via-cyan-500 to-transparent" />
      <span className="group-hover/btn:opacity-100 blur-sm block transition duration-500 opacity-0 absolute h-px w-1/2 mx-auto -bottom-px inset-x-10 bg-gradient-to-r from-transparent via-indigo-500 to-transparent" />
    </>
  );
};

const LabelInputContainer = ({
  children,
  className,
}: {
  children: React.ReactNode;
  className?: string;
}) => {
  return (
    <div className={cn("flex flex-col space-y-2 w-full", className)}>
      {children}
    </div>
  );
};

export function CsvForm({ isOpen, onClose, onSubmit, initialData = {}, mode }: CsvFormProps) {
  const [formData, setFormData] = useState<Record<string, string>>(initialData);

  useEffect(() => {
    setFormData(initialData);
  }, [initialData]);

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    onSubmit(formData);
  };

  return (
    <div className="fixed inset-0 z-50">
      <div className="absolute inset-0 bg-black/40 backdrop-blur-sm" onClick={onClose} />
      <div className="container relative z-10 mx-auto flex min-h-screen items-center justify-center">
        <div className="max-w-md w-full mx-auto rounded-none md:rounded-2xl p-4 md:p-8 shadow-input bg-white dark:bg-black">
          <div className="flex items-center justify-between">
            <div>
              <h2 className="font-bold text-xl text-neutral-800 dark:text-neutral-200">
                {mode === 'add' ? 'Add New Entry' : 'Edit Entry'}
              </h2>
              <p className="text-neutral-600 text-sm max-w-sm mt-2 dark:text-neutral-300">
              </p>
            <div className="mt-8">
            </div>
            </div>
            <button
              onClick={onClose}
              className="rounded-full p-1.5 hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
            >
              <IconX className="h-5 w-5 text-neutral-700 dark:text-neutral-300" />
            </button>
          </div>
          <form className="my-8" onSubmit={handleSubmit}>
            <div className="space-y-3">
              {Object.keys(formData).map(field => (
                field !== 'Time' && (
                  <LabelInputContainer key={field}>
                    <Label htmlFor={field}>{field}</Label>
                    <Input
                      id={field}
                      placeholder={field}
                      value={formData[field]}
                      onChange={(e) => setFormData(prev => ({
                        ...prev,
                        [field]: e.target.value
                      }))}
                      type="text"
                    />
                  </LabelInputContainer>
                )
              ))}
            </div>

            <div className="mt-8">
              <button
                className="bg-gradient-to-br relative group/btn from-black dark:from-zinc-900 dark:to-zinc-900 to-neutral-600 block dark:bg-zinc-800 w-full text-white rounded-md h-10 font-medium shadow-[0px_1px_0px_0px_#ffffff40_inset,0px_-1px_0px_0px_#ffffff40_inset] dark:shadow-[0px_1px_0px_0px_var(--zinc-800)_inset,0px_-1px_0px_0px_var(--zinc-800)_inset]"
                type="submit"
              >
                {mode === 'add' ? 'Add Entry' : 'Save Changes'} →
                <BottomGradient />
              </button>

              <div className="bg-gradient-to-r from-transparent via-neutral-300 dark:via-neutral-700 to-transparent my-8 h-[1px] w-full" />

              <button
                type="button"
                onClick={onClose}
                className="relative group/btn flex items-center justify-center px-4 w-full text-black rounded-md h-10 font-medium shadow-input bg-gray-50 dark:bg-zinc-900 dark:shadow-[0px_0px_1px_1px_var(--neutral-800)]"
              >
                <span className="text-neutral-700 dark:text-neutral-300 text-sm">
                  Cancel
                </span>
                <BottomGradient />
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}

=== FILE: ./src/components/ui/input.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

=== FILE: ./src/components/ui/label.tsx ===

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

=== FILE: ./src/components/ui/textarea.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }

=== FILE: ./src/components/ui/theme-provider.tsx ===

// src/components/ui/theme-provider.tsx
import { ThemeProvider as NextThemesProvider } from "next-themes";
import { type ThemeProviderProps } from "next-themes/dist/types";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return (
    <NextThemesProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      {...props}
    >
      {children}
    </NextThemesProvider>
  );
}

=== FILE: ./src/components/SearchBar.tsx ===

import React, { useState, useEffect, useRef } from 'react'
import { Search } from 'lucide-react'
import Fuse from 'fuse.js'

interface Document {
  id: number
  title: string
  content: string
  restricted: boolean
  category: string
}

interface SearchBarProps {
  documents: Document[]
  onSelectDocument: (id: number) => void
  isUnlocked: boolean
}

export default function SearchBar({ documents, onSelectDocument, isUnlocked }: SearchBarProps) {
  const [searchTerm, setSearchTerm] = useState('')
  const [searchResults, setSearchResults] = useState<Fuse.FuseResult<Document>[]>([])
  const [previewDocument, setPreviewDocument] = useState<Document | null>(null)
  const searchRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const fuse = new Fuse(documents, {
      keys: ['title', 'content'],
      includeMatches: true,
      threshold: 0.4,
    })

    const results = fuse.search(searchTerm)
    setSearchResults(results)
  }, [searchTerm, documents])

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (searchRef.current && !searchRef.current.contains(event.target as Node)) {
        setSearchTerm('')
        setPreviewDocument(null)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [])

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value)
  }

  const handleResultHover = (document: Document) => {
    setPreviewDocument(document)
  }

  const handleResultClick = (id: number) => {
    onSelectDocument(id)
    setSearchTerm('')
    setPreviewDocument(null)
  }

  return (
    <div ref={searchRef} className="relative w-full">
      <div className="relative">
        <input
          type="text"
          value={searchTerm}
          onChange={handleSearchChange}
          placeholder="Search documents..."
          className="w-full px-4 py-2 border rounded-md pr-10"
        />
        <Search className="absolute right-3 top-1/2 transform -translate-y-1/2 text-yellow-400" size={20} />
      </div>
      {searchTerm && (
        <div className="absolute z-10 w-full mt-2 bg-white border rounded-md shadow-lg max-h-96 overflow-auto">
          {searchResults.map((result) => (
            <div
              key={result.item.id}
              className="p-2 hover:bg-gray-100 cursor-pointer"
              onMouseEnter={() => handleResultHover(result.item)}
              onClick={() => handleResultClick(result.item.id)}
            >
              <h3 className="font-semibold">{result.item.title}</h3>
              <p className="text-sm text-gray-600 truncate">{result.item.content}</p>
            </div>
          ))}
        </div>
      )}
      {previewDocument && (
        <div className="absolute z-20 w-64 p-4 mt-2 bg-white border rounded-md shadow-lg right-0">
          <h3 className="font-semibold mb-2">{previewDocument.title}</h3>
          <p className="text-sm text-gray-600 line-clamp-3">{previewDocument.content}</p>
        </div>
      )}
    </div>
  )
}

=== FILE: ./src/components/statistics/CsvStatisticsPage.tsx ===

"use client";
import React from "react";
import { BackgroundGradient } from "@/components/ui/background-gradient";
import { IconDatabase } from "@tabler/icons-react";
import { useRouter } from 'next/router';

export function CsvStatisticsPage() {
  const router = useRouter();

  return (
    <div className="min-h-screen w-full p-4 md:p-8 gap-4">
      <h1 className="text-2xl font-bold text-neutral-800 dark:text-neutral-200 mb-4">
        Statistics Dashboard
      </h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div 
          onClick={() => router.push('/statistics/csv')} 
          className="cursor-pointer"
        >
          <BackgroundGradient className="rounded-[22px] p-4 sm:p-10 bg-white dark:bg-zinc-900">
            <div className="flex flex-col items-center justify-center">
              <div className="p-4 bg-blue-500/10 dark:bg-blue-500/20 rounded-full">
                <IconDatabase className="w-8 h-8 text-blue-500" />
              </div>
              <h2 className="text-base sm:text-xl text-black mt-4 mb-2 dark:text-neutral-200 font-medium">
                Training Data Management
              </h2>
              <p className="text-sm text-neutral-600 dark:text-neutral-400 text-center">
                View and manage your AI training data records. Add, edit, or remove entries from your dataset.
              </p>
              <div className="mt-4 w-full">
                <button 
                  className="rounded-full w-full pl-4 pr-1 py-1 text-white flex items-center justify-center space-x-1 bg-black mt-4 text-xs font-bold dark:bg-zinc-800"
                  onClick={(e) => {
                    e.stopPropagation();
                    router.push('/statistics/csv');
                  }}
                >
                  <span>Open Manager</span>
                  <span className="bg-zinc-700 rounded-full px-2 py-0 text-white">→</span>
                </button>
              </div>
            </div>
          </BackgroundGradient>
        </div>

        {/* Add more statistics cards here in the future */}
      </div>
    </div>
  );
}

=== FILE: ./src/components/statistics/csv-manager.tsx ===

import React, { useState, useCallback } from 'react';
import useSWR from 'swr';
import { Button } from '@/components/ui/button';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { toast } from 'sonner';
import { IconTrash, IconPencil, IconPlus, IconX } from '@tabler/icons-react';
import { CsvForm } from '@/components/ui/csv-form';

export { CsvManager };

interface CsvRow {
  [key: string]: string;
}

interface CsvTableProps {
  data: CsvRow[];
  onDeleteRow: (index: number) => Promise<void>;
  onEditClick: (row: CsvRow) => void;
  onAddClick: () => void;
  isDeleting: number | null;
}

const fetcher = async (url: string) => {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.text();
    const rows = data.split('\n').filter(row => row.trim() !== '').map(row => row.split(','));
    const headers = rows[0];
    return rows.slice(1).map(row => {
      const obj: CsvRow = {};
      headers.forEach((header, index) => {
        obj[header] = row[index] || '';
      });
      return obj;
    });
  } catch (error) {
    console.error('Fetcher error:', error);
    throw error;
  }
};

const CsvTable: React.FC<CsvTableProps> = React.memo(({
  data,
  onDeleteRow,
  onEditClick,
  onAddClick,
  isDeleting
}) => {
  const headers = data[0] ? Object.keys(data[0]) : [];

  return (
    <div className="w-full rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            {headers.map(header => (
              <TableHead key={header} className="px-4 py-2 whitespace-nowrap">{header}</TableHead>
            ))}
            <TableHead className="px-4 py-2 whitespace-nowrap">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((row, index) => (
            <TableRow key={index} className="hover:bg-gray-100 dark:hover:bg-neutral-800">
              {headers.map(header => (
                <TableCell key={header} className="px-4 py-2 whitespace-nowrap">
                  {row[header]}
                </TableCell>
              ))}
              <TableCell className="px-4 py-2 whitespace-nowrap">
                <div className="flex gap-2">
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8 text-blue-500 hover:text-blue-700 hover:bg-blue-100 dark:hover:bg-blue-900"
                    onClick={() => onEditClick(row)}
                  >
                    <IconPencil className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8 text-red-500 hover:text-red-700 hover:bg-red-100 dark:hover:bg-red-900"
                    onClick={() => onDeleteRow(index)}
                    disabled={isDeleting === index}
                  >
                    <IconTrash className="h-4 w-4" />
                  </Button>
                </div>
              </TableCell>
            </TableRow>
          ))}
          <TableRow className="hover:bg-gray-50 dark:hover:bg-neutral-800">
            <TableCell colSpan={headers.length + 1} className="px-4 py-2 text-center">
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8 text-green-500 hover:text-green-700 hover:bg-green-100 dark:hover:bg-green-900"
                onClick={onAddClick}
              >
                <IconPlus className="h-4 w-4" />
              </Button>
            </TableCell>
          </TableRow>
        </TableBody>
      </Table>
    </div>
  );
});

const formatCurrentTime = () => {
  const now = new Date();
  const time = now.toLocaleTimeString('en-GB');
  const date = now.toLocaleDateString('en-GB');
  return `${time} ${date}`;
};

interface CsvManagerProps {
  mode?: 'view' | 'add' | 'remove';
  onComplete?: () => void;
  onCancel?: () => void;
}

const CsvManager: React.FC<CsvManagerProps> = () => {
  const { data: csvData, error, mutate } = useSWR('/api/statistics/keab-training-data', fetcher);
  const [deletingRow, setDeletingRow] = useState<number | null>(null);
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [formMode, setFormMode] = useState<'add' | 'edit'>('add');
  const [editingData, setEditingData] = useState<CsvRow | undefined>();

  const handleClose = () => {
    window.history.back();
  };

  const handleAddClick = useCallback(() => {
    if (csvData && csvData.length > 0) {
      const headers = Object.keys(csvData[0]);
      const initialData = Object.fromEntries(headers.map(header => [header, '']));
      setEditingData(initialData);
      setFormMode('add');
      setIsFormOpen(true);
    }
  }, [csvData]);

  const handleEditClick = useCallback((row: CsvRow) => {
    setEditingData(row);
    setFormMode('edit');
    setIsFormOpen(true);
  }, []);

  const handleFormSubmit = async (formData: Record<string, string>) => {
    try {
      if (formMode === 'add') {
        const rowWithTime = {
          ...formData,
          Time: formatCurrentTime()
        };

        const response = await fetch('/api/statistics/add-csv-row', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(rowWithTime),
        });

        if (!response.ok) throw new Error(await response.text());
      } else {
        const response = await fetch('/api/statistics/edit-csv-row', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            index: csvData?.findIndex(row =>
              Object.entries(row).every(([key, value]) => editingData?.[key] === value)
            ),
            data: formData,
          }),
        });

        if (!response.ok) throw new Error(await response.text());
      }

      await mutate();
      setIsFormOpen(false);
      setEditingData(undefined);
      toast.success(formMode === 'add' ? 'Entry added successfully' : 'Entry updated successfully');
    } catch (error) {
      console.error('Error saving data:', error);
      toast.error(`Failed to ${formMode} entry`);
    }
  };

  const removeRow = async (index: number) => {
    setDeletingRow(index);
    try {
      const response = await fetch('/api/statistics/remove-csv-row', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ index: index + 1 }),
      });

      if (!response.ok) throw new Error(await response.text());

      await mutate();
      toast.success('Entry removed successfully');
    } catch (error) {
      console.error('Error removing row:', error);
      toast.error('Failed to remove entry');
    } finally {
      setDeletingRow(null);
    }
  };

  if (error) return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="text-red-500">Failed to load data</div>
    </div>
  );
  
  if (!csvData) return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="text-neutral-500">Loading...</div>
    </div>
  );

  return (
    <div className="fixed inset-0 z-50">
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black/40 backdrop-blur-sm" 
        onClick={handleClose}
      />
      
      {/* Modal Window */}
      <div className="relative z-10 min-h-screen flex items-center justify-center p-4">
        <div className="relative w-full max-w-5xl">
          {/* Background effects */}
          <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10 rounded-[22px] blur-xl" />
          <div className="absolute inset-0 bg-gradient-to-b from-white/80 to-white/50 dark:from-black/80 dark:to-black/50 rounded-[22px]" />
          
          {/* Content */}
          <div className="relative bg-white/80 dark:bg-black/80 backdrop-blur-sm rounded-[22px] shadow-2xl border border-white/20 dark:border-black/20">
            <div className="p-6">
              <div className="flex items-center justify-between mb-6">
                <h1 className="text-2xl font-bold text-neutral-800 dark:text-neutral-200">
                  Training Data Management
                </h1>
                <button
                  onClick={handleClose}
                  className="p-2 hover:bg-neutral-100 dark:hover:bg-neutral-800 rounded-full transition-colors"
                >
                  <IconX className="w-5 h-5 text-neutral-500" />
                </button>
              </div>
              
              <div className="bg-white dark:bg-black rounded-lg shadow-sm overflow-hidden">
                <CsvTable
                  data={csvData}
                  onDeleteRow={removeRow}
                  onEditClick={handleEditClick}
                  onAddClick={handleAddClick}
                  isDeleting={deletingRow}
                />
              </div>
            </div>
          </div>
        </div>
      </div>

      <CsvForm
        isOpen={isFormOpen}
        onClose={() => {
          setIsFormOpen(false);
          setEditingData(undefined);
        }}
        onSubmit={handleFormSubmit}
        initialData={editingData}
        mode={formMode}
      />
    </div>
  );
};

=== FILE: ./src/components/statistics/csv-statistics-page.tsx ===

"use client";
import React from "react";
import { BackgroundGradient } from "@/components/ui/background-gradient";
import { IconDatabase } from "@tabler/icons-react";
import { useRouter } from 'next/router';

export function CsvStatisticsPage() {
  const router = useRouter();

  return (
    <div className="min-h-screen w-full p-4 md:p-8 gap-4">
      <h1 className="text-2xl font-bold text-neutral-800 dark:text-neutral-200 mb-4">
        Statistics Dashboard
      </h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div 
          onClick={() => router.push('/statistics/csv')} 
          className="cursor-pointer"
        >
          <BackgroundGradient className="rounded-[22px] p-4 sm:p-10 bg-white dark:bg-zinc-900">
            <div className="flex flex-col items-center justify-center">
              <div className="p-4 bg-blue-500/10 dark:bg-blue-500/20 rounded-full">
                <IconDatabase className="w-8 h-8 text-blue-500" />
              </div>
              <h2 className="text-base sm:text-xl text-black mt-4 mb-2 dark:text-neutral-200 font-medium">
                Training Data Management
              </h2>
              <p className="text-sm text-neutral-600 dark:text-neutral-400 text-center">
                View and manage your AI training data records. Add, edit, or remove entries from your dataset.
              </p>
              <div className="mt-4 w-full">
                <button 
                  className="rounded-full w-full pl-4 pr-1 py-1 text-white flex items-center justify-center space-x-1 bg-black mt-4 text-xs font-bold dark:bg-zinc-800"
                  onClick={(e) => {
                    e.stopPropagation();
                    router.push('/statistics/csv');
                  }}
                >
                  <span>Open Manager</span>
                  <span className="bg-zinc-700 rounded-full px-2 py-0 text-white">→</span>
                </button>
              </div>
            </div>
          </BackgroundGradient>
        </div>
      </div>
    </div>
  );
}

=== FILE: ./src/pages/statistics.tsx ===

// src/pages/statistics
import { CsvStatisticsPage } from "@/components/statistics/CsvStatisticsPage";

export default function Statistics() {
  return <CsvStatisticsPage />;
}

=== FILE: ./src/pages/index.tsx ===

// src/pages/index.tsx
import Head from 'next/head';
import NordicBackground from '@/components/dashboard/NordicBackground';
import BentoGrid from '@/components/dashboard/BentoGrid';

export default function Dashboard() {
  return (
    <>
      <Head>
        <title>DigitAPP</title>
        <meta name="description" content="Modern dashboard interface" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
  
      <div className="relative min-h-screen w-full overflow-hidden bg-background">
        <NordicBackground />
        
        {/* Main content container with consistent padding and width */}
        <div className="relative w-full min-h-screen px-4 sm:px-6 lg:px-8">
          <div className="mx-auto max-w-7xl w-full"> {/* Constrain width for ultra-wide screens */}
            <header className="py-8">
              <div className="w-full">
                <h1 className="text-3xl font-bold text-foreground">Dashboard</h1>
                <p className="text-muted-foreground mt-2">
                  Press <kbd className="px-1.5 py-0.5 rounded bg-muted text-sm">Alt + 1-3</kbd> to open apps or{' '}
                  <kbd className="px-1.5 py-0.5 rounded bg-muted text-sm">?</kbd> for shortcuts
                </p>
              </div>
            </header>

            {/* Grid container with consistent spacing */}
            <div className="w-full pb-8">
              <BentoGrid />
            </div>
          </div>
        </div>
      </div>

      <style jsx global>{`
        .custom-scrollbar::-webkit-scrollbar {
          width: 8px;
          height: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: hsl(var(--muted));
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background: hsl(var(--muted-foreground));
          border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
          background: hsl(var(--primary));
        }
      `}</style>
    </>
  );
}
=== FILE: ./src/pages/hostapps/videoProcessor.tsx ===

// @/pages/hostapps/videoProcessor.tsx
import React, { useState, useEffect } from 'react'
import { create } from "zustand"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { HandbrakeProcessorForm } from '@/components/hostapps/HandbrakeProcessorForm'
import { toast } from "sonner"

// Types
export type ProcessingStep = {
  title: string
  description: string
}

export type ProcessingState = {
  isProcessing: boolean
  currentStep: number
  progress: number
  steps: ProcessingStep[]
}

// Password Store
interface PasswordPromptStore {
  isOpen: boolean
  password: string
  setIsOpen: (isOpen: boolean) => void
  setPassword: (password: string) => void
  reset: () => void
}

export const usePasswordPromptStore = create<PasswordPromptStore>((set) => ({
  isOpen: false,
  password: "",
  setIsOpen: (isOpen) => set({ isOpen }),
  setPassword: (password) => set({ password }),
  reset: () => set({ isOpen: false, password: "" })
}))

// Video Processing Dialog Store
interface VideoProcessorStore {
  isOpen: boolean
  processingState: ProcessingState | null
  setIsOpen: (isOpen: boolean) => void
  setProcessingState: (state: ProcessingState | null) => void
}

export const useVideoProcessorStore = create<VideoProcessorStore>((set) => ({
  isOpen: false,
  processingState: null,
  setIsOpen: (isOpen) => set({ isOpen }),
  setProcessingState: (state) => set({ processingState: state })
}))

export const PROCESSING_STEPS: ProcessingStep[] = [
  {
    title: "Uploading File",
    description: "Transferring file to SFTP server..."
  },
  {
    title: "Preparing",
    description: "Setting up HandBrake processor..."
  },
  {
    title: "Converting",
    description: "Processing video with selected preset..."
  },
  {
    title: "Finalizing",
    description: "Cleaning up and verifying output..."
  }
]

// Core processing function
type ProcessVideoParams = {
  file: File
  presetIndex: number
  sftpPassword: string
  onProgressUpdate: (state: ProcessingState) => void
  onComplete: () => void
  onError: (error: string) => void
}

async function processVideo({
  file,
  presetIndex,
  sftpPassword,
  onProgressUpdate,
  onComplete,
  onError
}: ProcessVideoParams) {
  let uploadInterval: NodeJS.Timeout
  let processInterval: NodeJS.Timeout
  let finalizationInterval: NodeJS.Timeout

  try {
    onProgressUpdate({
      isProcessing: true,
      currentStep: 0,
      progress: 0,
      steps: PROCESSING_STEPS
    })

    const formData = new FormData()
    formData.append('file', file)
    formData.append('password', sftpPassword)

    uploadInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 1, 25)
      }))
    }, 100)

    const uploadResponse = await fetch('/api/hostapps/handbrake?action=upload_file', {
      method: 'POST',
      body: formData
    })

    clearInterval(uploadInterval)

    if (!uploadResponse.ok) {
      const data = await uploadResponse.json()
      throw new Error(data.error || data.details || 'Upload failed')
    }

    onProgressUpdate({
      isProcessing: true,
      currentStep: 1,
      progress: 25,
      steps: PROCESSING_STEPS
    })

    await new Promise(resolve => setTimeout(resolve, 1500))

    onProgressUpdate({
      isProcessing: true,
      currentStep: 2,
      progress: 30,
      steps: PROCESSING_STEPS
    })

    processInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 0.5, 90)
      }))
    }, 200)

    const processResponse = await fetch('/api/hostapps/handbrake?action=process_file', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        filename: file.name,
        preset_index: presetIndex,
        password: sftpPassword
      })
    })

    clearInterval(processInterval)

    if (!processResponse.ok) {
      throw new Error('Processing failed')
    }

    onProgressUpdate({
      isProcessing: true,
      currentStep: 3,
      progress: 95,
      steps: PROCESSING_STEPS
    })

    finalizationInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 1, 100)
      }))
    }, 100)

    await new Promise(resolve => setTimeout(resolve, 1000))
    clearInterval(finalizationInterval)
    
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    onComplete()

  } catch (error) {
    if (uploadInterval) clearInterval(uploadInterval)
    if (processInterval) clearInterval(processInterval)
    if (finalizationInterval) clearInterval(finalizationInterval)

    onError(error instanceof Error ? error.message : "Processing failed")
  }
}

// Password Prompt Component
export function PasswordPromptDialog() {
  const [password, setPassword] = useState("")
  const { isOpen, setIsOpen, setPassword: storePassword, reset } = usePasswordPromptStore()

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    storePassword(password)
    setPassword("")
    setIsOpen(false)
  }

  const handleClose = () => {
    setPassword("")
    reset()
  }

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) handleClose()
    }}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
          <DialogDescription>
            Please provide your SFTP password to continue.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

// Video Processor Dialog Component
export function VideoProcessorDialog() {
  const [presets, setPresets] = useState<Array<{ name: string; path: string | null }>>([])
  const { isOpen, setIsOpen, setProcessingState } = useVideoProcessorStore()

  useEffect(() => {
    if (isOpen) {
      fetchPresets()
    }
  }, [isOpen])

  const fetchPresets = async () => {
    try {
      const response = await fetch('/api/hostapps/handbrake?action=list_presets')
      const data = await response.json()
      if (data.presets) {
        setPresets(data.presets)
      }
    } catch (error) {
      toast.error("Failed to fetch presets")
    }
  }

  const handleProcessingStart = async (file: File, presetIndex: number) => {
    setIsOpen(false)
    
    try {
      await startVideoProcessing({
        file,
        presetIndex,
        onProgressUpdate: (state) => setProcessingState(state),
        onComplete: () => {
          toast.success("Video processing completed")
          setProcessingState(null)
        },
        onError: (error) => {
          toast.error(error)
          setProcessingState(null)
        }
      })
    } catch (error) {
      console.log("Processing was cancelled or failed")
    }
  }

  return (
    <Dialog 
      open={isOpen} 
      onOpenChange={(open) => {
        if (!open) {
          setIsOpen(false)
        }
      }}
    >
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Video Processor</DialogTitle>
          <DialogDescription>
            Select a video file and processing options to convert.
          </DialogDescription>
        </DialogHeader>
        <HandbrakeProcessorForm 
          presets={presets}
          onProcessingStart={handleProcessingStart}
          onCancel={() => setIsOpen(false)}
        />
      </DialogContent>
    </Dialog>
  )
}

// Helper function to open the video processor dialog
export function openVideoProcessor() {
  useVideoProcessorStore.getState().setIsOpen(true)
}

// Public interface for video processing
type StartVideoProcessingParams = {
  file: File
  presetIndex: number
  onProgressUpdate: (state: ProcessingState) => void
  onComplete: () => void
  onError: (error: string) => void
}

export function startVideoProcessing({
  file,
  presetIndex,
  onProgressUpdate,
  onComplete,
  onError
}: StartVideoProcessingParams): Promise<void> {
  return new Promise((resolve, reject) => {
    const passwordStore = usePasswordPromptStore.getState()
    passwordStore.setIsOpen(true)

    const cleanup = usePasswordPromptStore.subscribe((state) => {
      if (!state.isOpen && state.password) {
        cleanup()
        processVideo({
          file,
          presetIndex,
          sftpPassword: state.password,
          onProgressUpdate,
          onComplete: () => {
            passwordStore.reset()
            onComplete()
            resolve()
          },
          onError: (error) => {
            passwordStore.reset()
            onError(error)
            reject(error)
          }
        })
      } else if (!state.isOpen && !state.password) {
        cleanup()
        const error = "Password not provided"
        onError(error)
        reject(error)
      }
    })
  })
}
=== FILE: ./src/pages/hostapps.tsx ===

// src/pages/hostapps.tsx
import React, { useState } from 'react'
import { Card, CardHeader, CardContent, CardTitle } from "@/components/ui/card"
import SftpUserCreationForm from '@/components/hostapps/SftpUserCreationForm'
import { VideoProcessorCard } from '@/components/hostapps/VideoProcessorCard'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { UserPlus } from "lucide-react"
import { 
  openVideoProcessor, 
  VideoProcessorDialog, 
  PasswordPromptDialog, 
  useVideoProcessorStore 
} from '@/pages/hostapps/videoProcessor'

export default function HostApplications() {
  const [isSftpFormOpen, setIsSftpFormOpen] = useState(false)
  const processingState = useVideoProcessorStore((state) => state.processingState)

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Host Applications</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <Card
          onClick={() => setIsSftpFormOpen(true)}
          className="cursor-pointer hover:border-primary transition-all duration-300"
        >
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <UserPlus className="h-5 w-5" />
              Create SFTP User
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Click to create a new SFTP user
            </p>
          </CardContent>
        </Card>

        <VideoProcessorCard
          onClick={openVideoProcessor}
          processingState={processingState}
        />
      </div>

      <Dialog open={isSftpFormOpen} onOpenChange={setIsSftpFormOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Create SFTP User</DialogTitle>
            <DialogDescription>
              Fill in the details to create a new SFTP user.
            </DialogDescription>
          </DialogHeader>
          <SftpUserCreationForm onUserCreated={() => setIsSftpFormOpen(false)} />
        </DialogContent>
      </Dialog>

      <VideoProcessorDialog />
      <PasswordPromptDialog />
    </div>
  )
}
=== FILE: ./src/pages/api/test_connection.ts ===

// pages/api/test_connection.ts
import type { NextApiRequest, NextApiResponse } from 'next'

const PYTHON_SERVER = 'http://172.20.96.22:5000'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ message: 'Method not allowed' })
  }

  try {
    const response = await fetch(PYTHON_SERVER)
    
    if (!response.ok) {
      throw new Error(`Python server returned ${response.status}`)
    }

    const data = await response.json()
    return res.status(200).json({ 
      message: 'Successfully connected to Python server', 
      serverResponse: data 
    })
  } catch (error) {
    console.error('Connection test failed:', error)
    return res.status(500).json({ 
      message: `Failed to connect to Python server: ${error}`,
      error: (error as Error).message
    })
  }
}

=== FILE: ./src/pages/api/hostapps/create_user.ts ===

// pages/api/create_user.ts
import type { NextApiRequest, NextApiResponse } from 'next'

const PYTHON_SERVER = process.env.NEXT_PUBLIC_SFTP_PYTHON_API_URL || 'http://172.20.96.22:5000'

interface UserInfo {
  'First name': string;
  'Last name': string;
  'User Type': string;
  Department: string;
  Email: string;
  'Responsible internally email'?: string;
}

interface UserData {
  username: string;
  user_info: UserInfo;
  deletion_time?: string;
}

async function getToken() {
  try {
    const response = await fetch(`${PYTHON_SERVER}/generate_token`)
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to get authentication token: ${error}`)
    }
    const data = await response.json()
    return data.access_token
  } catch (error) {
    console.error('Token generation error:', error)
    throw error
  }
}

function validateUserData(data: any): { isValid: boolean; error?: string } {
  if (!data) {
    return { isValid: false, error: 'No data provided' }
  }

  // Validate username
  if (!data.username || typeof data.username !== 'string') {
    return { isValid: false, error: 'Username is required and must be a string' }
  }

  if (!/^[a-z0-9-_]+$/.test(data.username)) {
    return { isValid: false, error: 'Username can only contain lowercase letters, numbers, hyphens, and underscores' }
  }

  // Validate user_info
  if (!data.user_info || typeof data.user_info !== 'object') {
    return { isValid: false, error: 'user_info is required and must be an object' }
  }

  const requiredFields = ['First name', 'Last name', 'User Type', 'Department', 'Email']
  for (const field of requiredFields) {
    if (!data.user_info[field] || typeof data.user_info[field] !== 'string') {
      return { isValid: false, error: `${field} is required in user_info and must be a string` }
    }
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(data.user_info.Email)) {
    return { isValid: false, error: 'Invalid email format' }
  }

  // Validate user type
  if (!['internal', 'external'].includes(data.user_info['User Type'].toLowerCase())) {
    return { isValid: false, error: 'User Type must be either "internal" or "external"' }
  }

  // Validate deletion_time if provided
  if (data.deletion_time !== undefined) {
    const deletion_time = parseInt(data.deletion_time)
    if (isNaN(deletion_time) || deletion_time < 0) {
      return { isValid: false, error: 'deletion_time must be a non-negative number or "0"' }
    }
  }

  return { isValid: true }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Security headers
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('X-Frame-Options', 'DENY')
  res.setHeader('X-XSS-Protection', '1; mode=block')

  // Method check
  if (req.method !== 'POST') {
    res.setHeader('Allow', ['POST'])
    return res.status(405).json({ error: 'Method not allowed' })
  }

  // Content-Type check
  if (!req.headers['content-type']?.includes('application/json')) {
    return res.status(400).json({ error: 'Content-Type must be application/json' })
  }

  try {
    const userData = req.body as UserData

    // Validate input data
    const validation = validateUserData(userData)
    if (!validation.isValid) {
      return res.status(400).json({ error: validation.error })
    }

    console.log('Attempting to get token...')
    const token = await getToken()
    console.log('Token received successfully')

    // Sanitize data before logging (remove password if present)
    const sanitizedData = { ...userData }
    if ('password' in sanitizedData) {
      delete (sanitizedData as any).password
    }
    console.log('Sending request to Python server with data:', sanitizedData)

    const response = await fetch(`${PYTHON_SERVER}/create_user`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(userData)
    })

    const data = await response.json()
    console.log('Python server response:', {
      ...data,
      // Remove sensitive data from logs
      details: data.details ? { ...data.details, password: undefined } : undefined
    })

    if (!response.ok) {
      return res.status(response.status).json({
        error: 'Python server error',
        details: data.error || data.message || 'Unknown error',
        pythonResponse: data
      })
    }

    // Success response
    res.status(200).json(data)

  } catch (error) {
    console.error('Error in create_user handler:', error)
    
    // Determine if error is network-related
    const isNetworkError = error instanceof Error && 
      (error.message.includes('fetch') || error.message.includes('network'))

    res.status(isNetworkError ? 503 : 500).json({ 
      error: isNetworkError ? 'Service temporarily unavailable' : 'Failed to create user',
      details: (error as Error).message,
      ...(process.env.NODE_ENV === 'development' && { stack: (error as Error).stack })
    })
  }
}

=== FILE: ./src/pages/api/hostapps/handbrake.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import formidable from 'formidable'
import fs from 'fs'
import path from 'path'

export const config = {
  api: {
    bodyParser: false,
  },
}

const PYTHON_SERVER = process.env.NEXT_PUBLIC_HANDBRAKE_PYTHON_API_URL || 'http://172.20.96.20:5000'

// Helper to parse JSON body
async function parseJsonBody(req: NextApiRequest) {
  const buffers = []
  for await (const chunk of req) {
    buffers.push(chunk)
  }
  const data = Buffer.concat(buffers).toString()
  try {
    return JSON.parse(data)
  } catch {
    return null
  }
}

async function getToken() {
  try {
    const response = await fetch(`${PYTHON_SERVER}/generate_token`, {
      signal: AbortSignal.timeout(5000)
    })
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to get authentication token: ${error}`)
    }
    const data = await response.json()
    return data.access_token
  } catch (error) {
    console.error('Token generation error:', error)
    if (error instanceof TypeError && error.message.includes('ECONNREFUSED')) {
      throw new Error('Unable to connect to Handbrake server. Please try again later.')
    }
    throw error
  }
}

const parseForm = async (req: NextApiRequest) => {
  const form = formidable({
    maxFileSize: 10 * 1024 * 1024 * 1024, // 10GB
    maxTotalFileSize: 10 * 1024 * 1024 * 1024, // 10GB
    allowEmptyFiles: false,
    multiples: false,
  });

  return new Promise<{ fields: formidable.Fields; files: formidable.Files }>((resolve, reject) => {
    form.parse(req, (err, fields, files) => {
      if (err) reject(err);
      resolve({ fields, files });
    });
  });
};

async function streamToBuffer(stream: fs.ReadStream): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
    stream.on('error', (err) => reject(err));
    stream.on('end', () => resolve(Buffer.concat(chunks)));
  });
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('X-Frame-Options', 'DENY')
  res.setHeader('X-XSS-Protection', '1; mode=block')

  try {
    const token = await getToken()
    console.log('Action:', req.query.action)

    switch (req.query.action) {
      case 'upload_file': {
        if (req.method !== 'POST') {
          return res.status(405).json({ error: 'Method not allowed for this action' })
        }

        try {
          const { fields, files } = await parseForm(req);
          console.log('Form data:', { fields, files });

          const fileArray = Array.isArray(files.file) ? files.file : [files.file];
          const file = fileArray[0];
          const password = fields.password as string;

          if (!password) {
            return res.status(400).json({ error: "Password is required" });
          }

          if (!file || !file.filepath) {
            console.error('No file or filepath:', file);
            return res.status(400).json({ error: "No file provided" });
          }

          console.log('Uploading file:', file.originalFilename, 'from path:', file.filepath);

          // Read file content
          const fileBuffer = await fs.promises.readFile(file.filepath);

          // Create form data for upload
          const formData = new FormData();
          formData.append('file', new Blob([fileBuffer]), file.originalFilename || 'unnamed_file');
          formData.append('password', password);

          const uploadResponse = await fetch(`${PYTHON_SERVER}/upload_file`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`
            },
            body: formData
          });

          let data;
          try {
            data = await uploadResponse.json();
          } catch (e) {
            console.error('Failed to parse upload response:', e);
            return res.status(500).json({
              error: 'Upload failed',
              details: 'Invalid server response'
            });
          }

          // Clean up temp file
          try {
            await fs.promises.unlink(file.filepath);
          } catch (e) {
            console.error('Failed to cleanup temp file:', e);
          }

          if (!uploadResponse.ok) {
            console.error('Upload failed:', data);
            return res.status(uploadResponse.status).json(data);
          }

          return res.status(200).json(data);
        } catch (error) {
          console.error('File handling error:', error);
          return res.status(500).json({ 
            error: 'Upload failed', 
            details: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      }

      case 'list_files': {
        const body = await parseJsonBody(req)
        if (!body?.password) {
          return res.status(400).json({ error: "Password is required" });
        }

        const response = await fetch(`${PYTHON_SERVER}/list_files`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            password: body.password
          })
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse list_files response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      case 'list_presets': {
        const response = await fetch(`${PYTHON_SERVER}/list_presets`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse list_presets response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      case 'process_file': {
        const body = await parseJsonBody(req)
        if (!body) {
          return res.status(400).json({ error: "Invalid request body" });
        }

        const response = await fetch(`${PYTHON_SERVER}/process_file`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse process_file response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      default:
        return res.status(400).json({ error: 'Invalid action' });
    }
  } catch (error) {
    console.error('Error in handbrake handler:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('ECONNREFUSED') || error.message.includes('Unable to connect')) {
        return res.status(503).json({
          error: 'Service temporarily unavailable',
          details: 'Unable to connect to Handbrake server. Please try again later.'
        });
      }
      
      if (error.message.includes('timeout')) {
        return res.status(504).json({
          error: 'Service timeout',
          details: 'Request timed out. Please try again.'
        });
      }
    }

    return res.status(500).json({
      error: 'Failed to process request',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/tags.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { getTags, createTag, deleteTag, updateDocumentTags } from '@/lib/db';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const tags = await getTags();
        res.status(200).json(tags);
        break;

      case 'POST':
        const { name, color } = req.body;
        const newTag = await createTag(name, color);
        res.status(201).json(newTag);
        break;

      case 'DELETE':
        await deleteTag(Number(req.query.id));
        res.status(200).json({ message: 'Tag deleted' });
        break;

      case 'PATCH':
        const { documentId, tagIds } = req.body;
        await updateDocumentTags(documentId, tagIds);
        res.status(200).json({ message: 'Document tags updated' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'DELETE', 'PATCH']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Tag API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import prisma from '@/lib/prisma';

export const config = {
  api: {
    bodyParser: {
      sizeLimit: '50mb'
    },
    responseLimit: false
  }
};

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;

  try {
    switch (req.method) {
      case 'GET':
        if (id) {
          const document = await prisma.document.findUnique({
            where: { id: parseInt(id as string) }
          });

          if (!document) {
            return res.status(404).json({ error: 'Document not found' });
          }

          return res.status(200).json(document);
        } else {
          const documents = await prisma.document.findMany({
            orderBy: { updatedAt: 'desc' }
          });
          return res.status(200).json(documents);
        }

      case 'POST':
        const { title, content, restricted, category } = req.body;

        if (!title) {
          return res.status(400).json({ error: 'Title is required' });
        }

        const newDocument = await prisma.document.create({
          data: {
            title,
            content: content || '',
            restricted: restricted || false,
            category: category || 'General'
          }
        });

        return res.status(201).json(newDocument);

      case 'PUT':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        const updates = req.body;
        const documentId = parseInt(id as string);

        const existingDoc = await prisma.document.findUnique({
          where: { id: documentId }
        });

        if (!existingDoc) {
          return res.status(404).json({ error: 'Document not found' });
        }

        const updatedDocument = await prisma.document.update({
          where: { id: documentId },
          data: {
            title: updates.title ?? existingDoc.title,
            content: updates.content ?? existingDoc.content,
            category: updates.category ?? existingDoc.category,
            restricted: updates.restricted ?? existingDoc.restricted,
            updatedAt: new Date()
          }
        });

        return res.status(200).json(updatedDocument);

      case 'DELETE':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        await prisma.document.delete({
          where: { id: parseInt(id as string) }
        });

        return res.status(200).json({ message: 'Document deleted successfully' });

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE']);
        return res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('API error:', error);
    
    if ((error as any).code === 'P2025') {
      return res.status(404).json({ error: 'Document not found' });
    }

    return res.status(500).json({ 
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error : undefined
    });
  }
}
=== FILE: ./src/pages/api/wiki/categories.ts ===

// src/pages/api/wiki/categories.ts
import { NextApiRequest, NextApiResponse } from 'next';
import prisma from '@/lib/prisma';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const categories = await prisma.category.findMany({
          orderBy: {
            order: 'asc'
          }
        });
        
        if (!categories.length) {
          // Ensure at least 'General' category exists
          await prisma.category.upsert({
            where: { name: 'General' },
            update: {},
            create: {
              name: 'General',
              order: 0
            }
          });
          return res.status(200).json([{ id: 1, name: 'General', order: 0, parentId: null }]);
        }
        
        return res.status(200).json(categories);

      case 'POST':
        const { name, parentId } = req.body;
        if (!name) {
          return res.status(400).json({ error: 'Name is required' });
        }

        const maxOrder = await prisma.category.aggregate({
          _max: {
            order: true
          }
        });

        const newCategory = await prisma.category.create({
          data: {
            name,
            parentId: parentId || null,
            order: (maxOrder._max.order || 0) + 1
          }
        });

        return res.status(201).json(newCategory);

      case 'PUT':
        const { id, name: updateName } = req.body;
        if (!id || !updateName) {
          return res.status(400).json({ error: 'ID and name are required' });
        }

        const updatedCategory = await prisma.category.update({
          where: { id: Number(id) },
          data: { name: updateName }
        });

        return res.status(200).json(updatedCategory);

      case 'DELETE':
        const categoryId = Number(req.query.id);
        if (!categoryId) {
          return res.status(400).json({ error: 'ID is required' });
        }

        // First, move any documents in this category to 'General'
        await prisma.document.updateMany({
          where: { 
            category: {
              equals: (await prisma.category.findUnique({
                where: { id: categoryId }
              }))?.name
            }
          },
          data: { category: 'General' }
        });

        // Then delete the category
        await prisma.category.delete({
          where: { id: categoryId }
        });

        return res.status(200).json({ message: 'Category deleted' });

      case 'PATCH':
        const { id: patchId, order: newOrder } = req.body;
        if (!patchId || typeof newOrder !== 'number') {
          return res.status(400).json({ error: 'ID and order are required' });
        }

        const patchedCategory = await prisma.category.update({
          where: { id: Number(patchId) },
          data: { order: newOrder }
        });

        return res.status(200).json(patchedCategory);

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']);
        return res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Categories API error:', error);

    // Handle specific Prisma errors
    if (error.code === 'P2002') {
      return res.status(409).json({ error: 'Category name must be unique' });
    }
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Category not found' });
    }

    return res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/api/statistics/remove-csv-row.ts ===

// src/pages/api/statistics/remove-csv-row.ts
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/remove-csv-row`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(req.body),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(errorText);
    }

    const data = await response.json();
    res.status(200).json(data);
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to remove CSV row' });
  }
}

=== FILE: ./src/pages/api/statistics/csv-data.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import { API_URL } from '@/config'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const response = await fetch(`${API_URL}/api/keab-training-data`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.text();
    res.status(200).json({ data });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch CSV data' });
  }
}

=== FILE: ./src/pages/api/statistics/keab-training-data.ts ===

import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/keab-training-data`);
    const data = await response.text();
    
    if (!response.ok) {
      throw new Error(`Node server responded with status: ${response.status}`);
    }
    
    res.status(200).send(data);
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to fetch CSV data' });
  }
}

=== FILE: ./src/pages/api/statistics/add-csv-row.ts ===

// src/pages/api/statistics/add-csv-row.ts
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/add-csv-row`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    });
    
    if (!response.ok) {
      throw new Error(`Node server responded with status: ${response.status}`);
    }
    
    res.status(200).json({ success: true });
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to add CSV row' });
  }
}

=== FILE: ./src/pages/api/statistics/convert-docx.ts ===

// src/pages/api/statistics/convert-docx.ts
import { NextApiRequest, NextApiResponse } from 'next';
import formidable from 'formidable';
import mammoth from 'mammoth';
import path from 'path';
import fs from 'fs';

export const config = {
  api: {
    bodyParser: false,
  },
};

async function convertDocxToMarkdown(filePath: string): Promise<{ value: string, messages: any[] }> {
  try {
    const result = await mammoth.convertToHtml({
      path: filePath,
      options: {
        styleMap: [
          "p[style-name='Heading 1'] => h1",
          "p[style-name='Heading 2'] => h2",
          "p[style-name='Heading 3'] => h3",
          "r[style-name='Strong'] => strong"
        ]
      }
    });

    let html = result.value;
    console.log('Initial HTML:', html);

    // Clean up HTML
    html = html
      .replace(/<p>\s*<strong>/g, '<p><strong>')
      .replace(/<\/strong>\s*<\/p>/g, '</strong></p>')
      .replace(/<strong>\s+/g, '<strong>')
      .replace(/\s+<\/strong>/g, '</strong>');

    const TurndownService = require('turndown');
    const turndownService = new TurndownService({
      headingStyle: 'atx',
      bulletListMarker: '*'
    });

    // Custom rule for strong tags
    turndownService.addRule('strong', {
      filter: 'strong',
      replacement: (content, node) => {
        // Don't wrap in ** if it's just whitespace/empty
        if (!content.trim()) return '';
        // Check if this is the beginning of a paragraph
        const isStartOfParagraph = !node.previousSibling || node.previousSibling.textContent.trim() === '';
        return isStartOfParagraph ? `**${content.trim()}**` : content;
      }
    });

    let markdown = turndownService.turndown(html);

    // Final cleanup
    markdown = markdown
      .replace(/\n{3,}/g, '\n\n')
      .replace(/\*\*\s+/g, '**')
      .replace(/\s+\*\*/g, '**')
      .replace(/\\\\/g, '\\')
      .trim();

    return { value: markdown, messages: result.messages };
  } catch (error) {
    console.error('Conversion error:', error);
    throw error;
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  console.log('Starting document conversion request...');

  const uploadDir = path.join(process.cwd(), 'tmp', 'uploads');
  try {
    await fs.promises.mkdir(uploadDir, { recursive: true });
  } catch (err) {
    console.error('Error creating upload directory:', err);
  }

  const form = formidable({
    uploadDir,
    keepExtensions: true,
    maxFileSize: 10 * 1024 * 1024, // 10MB limit
  });

  let filePath: string | null = null;

  try {
    console.log('Parsing form data...');
    const [fields, files] = await new Promise<[formidable.Fields, formidable.Files]>((resolve, reject) => {
      form.parse(req, (err, fields, files) => {
        if (err) {
          console.error('Form parsing error:', err);
          reject(err);
        } else {
          resolve([fields, files]);
        }
      });
    });

    console.log('File received:', files);

    const file = Array.isArray(files.file) ? files.file[0] : files.file;
    if (!file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    filePath = file.filepath;
    console.log('Converting file:', {
      originalName: file.originalFilename,
      filepath: file.filepath,
      size: file.size
    });

    try {
      const result = await convertDocxToMarkdown(file.filepath);

      if (!result.value || result.value.trim().length === 0) {
        console.error('Conversion produced empty content');
        return res.status(422).json({
          error: 'Document conversion failed',
          details: 'Conversion resulted in empty content'
        });
      }

      console.log('Conversion successful:', {
        contentLength: result.value.length,
        messageCount: result.messages.length
      });

      return res.status(200).json({
        content: result.value,
        messages: result.messages
      });

    } catch (conversionError) {
      console.error('Conversion error:', conversionError);
      return res.status(500).json({
        error: 'Error converting document',
        details: conversionError instanceof Error ? conversionError.message : 'Unknown error'
      });
    }
  } catch (error) {
    console.error('Upload handling error:', error);
    return res.status(500).json({
      error: 'Error handling upload',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  } finally {
    // Clean up temporary file
    if (filePath) {
      try {
        await fs.promises.unlink(filePath);
        console.log('Temporary file cleaned up:', filePath);
      } catch (cleanupError) {
        console.error('Error cleaning up temp file:', cleanupError);
      }
    }
  }
}
=== FILE: ./src/pages/api/statistics/edit-csv-row.ts ===

// src/pages/api/statistics/edit-csv-row.ts
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/edit-csv-row`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    });
    
    if (!response.ok) {
      throw new Error(`Node server responded with status: ${response.status}`);
    }
    
    res.status(200).json({ success: true });
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to edit CSV row' });
  }
}

=== FILE: ./src/pages/_app.tsx ===

// src/pages/_app.tsx
import type { AppProps } from 'next/app'
import Layout from '@/components/layout'
import { ThemeProvider } from 'next-themes'
import { WikiProvider } from '@/lib/context/WikiContext'
import { Toaster } from 'sonner';
import '@/styles/globals.css'

export default function App({ Component, pageProps }: AppProps) {
  return (
    <ThemeProvider>
      <WikiProvider>
        <Layout>
          <Component {...pageProps} />
        </Layout>
      </WikiProvider>
    </ThemeProvider>
  )
}

=== FILE: ./src/pages/wiki.tsx ===

import { useState } from 'react';
import { useWiki } from '@/lib/context/WikiContext';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';

export default function WikiPage() {
  // Local state for dialogs
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isSearchOpen, setIsSearchOpen] = useState(false);

  // Get everything else from context
  const {
    documents,
    selectedDocument,
    categories,
    tags,
    isEditing,
    isUnlocked,
    isLoading,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    setIsEditing,
    selectDocument,
    updateDocument,
    deleteDocument,
    createDocument,
    setIsUnlocked,
    handlePasswordSubmit
  } = useWiki();

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={[]} // You might want to handle search results properly
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={selectDocument}
        onSearch={() => {}} // Implement search handling
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={() => {}} // Implement search results handling
        setSelectedDocument={selectDocument}
        setExpandedCategories={() => {}} // Implement category expansion handling
      />
    </div>
  );

  // Helper functions
  function handleDocumentSelect(id: number) {
    selectDocument(id);
    setIsEditing(false);
  }

  function handleUnlockToggle(checked: boolean) {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }

  function canEditDocument(document: any) {
    return isUnlocked || !document.restricted;
  }
}
=== FILE: ./src/pages/statistics/csv.tsx ===

import { CsvManager } from "@/components/statistics/csv-manager";

export default function CsvPage() {
  return <CsvManager />;
}

=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
      - ./public/uploads:/app/public/uploads
      - ./tmp:/app/tmp
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./next.config.js ===

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  transpilePackages: ['@uiw/react-markdown-preview', 'react-markdown', 'react-syntax-highlighter'],
  experimental: {
    serverActions: {
      allowedOrigins: ['localhost:8080', 'localhost:5000'],
    },
  },
  api: {
    bodyParser: {
      sizeLimit: '10mb' // Increase from default 1mb
    },
    responseLimit: false
  },
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        path: false,
      };
    }
    config.externals.push({
      sqlite3: 'commonjs sqlite3',
    });
    config.externals.push('_http_common');
    return config;
  }
};

module.exports = nextConfig;
=== FILE: ./package.json ===

{
  "name": "digitapp",
  "private": true,
  "version": "0.0.0",
  "prisma": {
    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
  },
  "scripts": {
    "dev": "next dev -p 8080",
    "build": "next build",
    "start": "next start -p 8080",
    "lint": "next lint",
    "node-server": "node server.js",
    "manage-password": "npx ts-node src/lib/managePassword.ts",
    "prisma:generate": "node -r ./load-env.js ./node_modules/.bin/prisma generate",
    "prisma:migrate": "node -r ./load-env.js ./node_modules/.bin/prisma migrate dev",
    "prisma:studio": "prisma studio",
    "db:seed": "prisma db seed",
    "db:reset": "prisma migrate reset",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:migrate:create": "prisma migrate dev --create-only",
    "db:migrate:deploy": "prisma migrate deploy"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@prisma/client": "^5.21.1",
    "@radix-ui/react-alert-dialog": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@tabler/icons-react": "^3.21.0",
    "@types/turndown": "^5.0.5",
    "@uiw/react-codemirror": "^4.23.6",
    "@uiw/react-markdown-preview": "^5.0.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "cors": "^2.8.5",
    "csv-parse": "^5.5.6",
    "csv-stringify": "^6.5.1",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.5",
    "easymde": "^2.18.0",
    "express": "^4.21.1",
    "formidable": "^3.5.2",
    "framer-motion": "^11.11.11",
    "fuse.js": "^7.0.0",
    "highlight.js": "^11.10.0",
    "isomorphic-unfetch": "^4.0.2",
    "lucide-react": "^0.452.0",
    "mammoth": "^1.8.0",
    "next": "^15.0.1",
    "next-themes": "^0.3.0",
    "prisma": "^5.21.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-dropzone": "^14.2.10",
    "react-focus-lock": "^2.9.3",
    "react-hook-form": "^7.53.1",
    "react-hot-toast": "^2.4.1",
    "react-hotkeys-hook": "^4.4.4",
    "react-markdown": "^9.0.1",
    "react-simplemde-editor": "^5.2.0",
    "react-syntax-highlighter": "^15.6.1",
    "recharts": "^2.13.0",
    "rehype-highlight": "^7.0.1",
    "rehype-stringify": "^10.0.1",
    "remark-gfm": "^4.0.0",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.1",
    "sonner": "^1.7.0",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "swr": "^2.2.5",
    "tailwind-merge": "^2.5.3",
    "tailwind-scrollbar-hide": "^1.1.7",
    "tailwindcss-animate": "^1.0.7",
    "turndown": "^7.2.0",
    "unified": "^11.0.5",
    "zod": "^3.23.8",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^25.0.7",
    "@types/bcryptjs": "^2.4.6",
    "@types/formidable": "^3.4.5",
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "autoprefixer": "^10.4.14",
    "eslint": "^8.56.0",
    "eslint-config-next": "^14.0.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "postcss": "^8.4.21",
    "tailwindcss": "^3.3.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  },
  "overrides": {
    "semver": "^7.5.3",
    "word-wrap": "^1.2.5",
    "tough-cookie": "^4.1.3",
    "glob": "^10.3.10",
    "rimraf": "^5.0.5",
    "@humanwhocodes/config-array": "^0.11.11",
    "@humanwhocodes/object-schema": "^1.2.1",
    "gauge": "^5.0.1",
    "npmlog": "^7.0.1",
    "@npmcli/fs": "^3.1.0",
    "@npmcli/move-file": "^3.0.0",
    "are-we-there-yet": "^3.0.1"
  },
  "resolutions": {
    "string-width": "^4.2.3",
    "strip-ansi": "^6.0.1",
    "wrap-ansi": "^7.0.0",
    "@humanwhocodes/config-array": "^0.11.11",
    "@humanwhocodes/object-schema": "^1.2.1",
    "gauge": "^5.0.1",
    "npmlog": "^7.0.1",
    "@npmcli/fs": "^3.1.0",
    "@npmcli/move-file": "^3.0.0",
    "are-we-there-yet": "^3.0.1"
  },
  "engines": {
    "node": ">=16.0.0"
  }
}
=== FILE: ./wiki_files.txt ===


=== FILE: ./src/lib/utils/apiUtils.ts ===

import { WikiError } from '@/lib/errors/wikiError';

export const handleApiResponse = async (response: Response, errorMessage: string) => {
  if (!response.ok) {
    throw new Error(errorMessage);
  }
  return response.json();
};
=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useEffect, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import Fuse from 'fuse.js';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Fuse.FuseResult<Document>[]>([]);

  // Enhanced Fuse configuration
  const searchIndex = useMemo(() => {
    return new Fuse(documents, {
      keys: [
        { 
          name: 'title',
          weight: 3.0  // Increased weight for titles
        },
        {
          name: 'content',
          weight: 1.0
        },
        {
          name: 'category',
          weight: 2.0
        }
      ],
      includeMatches: true,
      shouldSort: true,
      threshold: 0.3,      // Lower threshold for stricter matching
      location: 0,         // Start searching at beginning of strings
      distance: 200,       // Allow more distance for matches
      minMatchCharLength: 2,  // Minimum length for matches
      useExtendedSearch: true,
      ignoreLocation: false,  // Consider location in string for relevance
      findAllMatches: true,   // Find all matching instances
      // Add Swedish diacritics to equivalent chars
      getFn: (obj, path) => {
        const value = Fuse.config.getFn(obj, path);
        if (typeof value === 'string') {
          return value.toLowerCase()
            .replace(/[åä]/g, 'a')
            .replace(/ö/g, 'o');
        }
        return value;
      }
    });
  }, [documents]);

  // Add keyboard shortcut handler
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.code === 'Space') {
        e.preventDefault();
        setIsSearchOpen(true);
      }

      if (e.key === 'Escape' && isSearchOpen) {
        e.preventDefault();
        setIsSearchOpen(false);
        setSearchResults([]);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isSearchOpen]);

  const handleSearch = useCallback((query: string) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    // Use extended search syntax for better matching
    const searchPattern = query.split(' ').map(term => {
      // Exact match for terms with quotes
      if (term.startsWith('"') && term.endsWith('"')) {
        return `'${term.slice(1, -1)}`;
      }
      // Fuzzy matching for other terms
      return `${term}`;
    }).join(' ');

    const results = searchIndex.search(searchPattern);
    setSearchResults(results);
  }, [searchIndex]);

  // Add a cleanup function for when the search modal is closed
  const handleClose = useCallback(() => {
    setIsSearchOpen(false);
    setSearchResults([]);
  }, []);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch,
    handleClose
  };
};

// Add type exports if needed
export type SearchResult = Fuse.FuseResult<Document>;
=== FILE: ./src/lib/context/WikiContext.tsx ===

import React, { 
    createContext, 
    useContext, 
    useState, 
    useCallback, 
    useEffect,
    useMemo 
  } from 'react';
  import { toast } from 'react-hot-toast';
  import { 
    Document, 
    Category, 
    CategoryWithHierarchy, 
    Tag, 
    DocumentUpdate, 
    WikiState,
    DocumentFilter,
    SortOption
  } from '@/lib/types/wiki';
  
  interface WikiContextType extends WikiState {
    // Document actions
    selectDocument: (id: number | null) => void;
    createDocument: (title: string, category: string, restricted: boolean) => Promise<void>;
    updateDocument: (id: number, updates: DocumentUpdate) => Promise<void>;
    deleteDocument: (id: number) => Promise<void>;
    
    // Category actions
    createCategory: (name: string, parentId?: number) => Promise<void>;
    updateCategory: (id: number, name: string) => Promise<void>;
    deleteCategory: (id: number) => Promise<void>;
    reorderCategory: (id: number, newOrder: number) => Promise<void>;
    
    // Tag actions
    createTag: (name: string, color: string) => Promise<void>;
    deleteTag: (id: number) => Promise<void>;
    updateDocumentTags: (documentId: number, tagIds: number[]) => Promise<void>;
    
    // UI State actions
    setIsEditing: (value: boolean) => void;
    setIsUnlocked: (value: boolean) => void;
    
    // Search and filter
    filterDocuments: (filter: DocumentFilter) => void;
    sortDocuments: (sort: SortOption) => void;
    
    // Auth
    isPasswordPromptOpen: boolean;
    setIsPasswordPromptOpen: (value: boolean) => void;
    handlePasswordSubmit: (password: string) => Promise<void>;
  }
  
  const buildCategoryHierarchy = (
    categories: Category[],
    documents: Document[],
    parentId: number | null = null,
    level: number = 0
  ): CategoryWithHierarchy[] => {
    return categories
      .filter(cat => cat.parentId === parentId)
      .map(cat => ({
        ...cat,
        level,
        children: buildCategoryHierarchy(categories, documents, cat.id, level + 1),
        documentCount: documents.filter(doc => doc.category === cat.name).length
      }))
      .sort((a, b) => a.order - b.order);
  };
  
  const WikiContext = createContext<WikiContextType | null>(null);
  
  export function useWiki() {
    const context = useContext(WikiContext);
    if (!context) {
      throw new Error('useWiki must be used within a WikiProvider');
    }
    return context;
  }
  
  export function WikiProvider({ children }: { children: React.ReactNode }) {
    // State
    const [documents, setDocuments] = useState<Document[]>([]);
    const [categories, setCategories] = useState<Category[]>([]);
    const [tags, setTags] = useState<Tag[]>([]);
    const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
    const [isEditing, setIsEditing] = useState(false);
    const [isUnlocked, setIsUnlocked] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);
    const [filter, setFilter] = useState<DocumentFilter>({});
    const [sort, setSort] = useState<SortOption>({ field: 'updatedAt', direction: 'desc' });
  
    // Compute category hierarchy
    const categoryHierarchy = useMemo(() => 
      buildCategoryHierarchy(categories, documents),
      [categories, documents]
    );
  
    // Fetch initial data
    const fetchData = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        
        try {
          // Fetch documents first since we know that table exists
          const docsRes = await fetch('/api/wiki/wiki');
          if (!docsRes.ok) {
            throw new Error('Failed to fetch documents');
          }
          const docsData = await docsRes.json();
          setDocuments(docsData);
      
          try {
            // Try to fetch categories
            const catsRes = await fetch('/api/wiki/categories');
            if (catsRes.ok) {
              const catsData = await catsRes.json();
              setCategories(catsData);
            }
          } catch (error) {
            console.error('Error fetching categories:', error);
            setCategories([]); // Set empty array if categories fail
          }
      
          try {
            // Try to fetch tags
            const tagsRes = await fetch('/api/wiki/tags');
            if (tagsRes.ok) {
              const tagsData = await tagsRes.json();
              setTags(tagsData);
            }
          } catch (error) {
            console.error('Error fetching tags:', error);
            setTags([]); // Set empty array if tags fail
          }
      
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : 'An unexpected error occurred';
          console.error('Error fetching data:', err);
          setError(errorMessage);
          toast.error(errorMessage);
        } finally {
          setIsLoading(false);
        }
      }, []);
  
    useEffect(() => {
      fetchData();
    }, [fetchData]);
  
    // Document actions
    const selectDocument = useCallback((id: number | null) => {
      const doc = id ? documents.find(d => d.id === id) || null : null;
      setSelectedDocument(doc);
      setIsEditing(false);
    }, [documents]);
  
    const createDocument = useCallback(async (
      title: string,
      category: string,
      restricted: boolean
    ) => {
      try {
        const response = await fetch('/api/wiki/wiki', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, category, restricted }),
        });
  
        if (!response.ok) throw new Error('Failed to create document');
  
        await fetchData();
        toast.success('Document created successfully');
      } catch (error) {
        console.error('Error creating document:', error);
        toast.error('Failed to create document');
        throw error;
      }
    }, [fetchData]);
  
    const updateDocument = useCallback(async (
        id: number,
        updates: DocumentUpdate
      ) => {
        try {
          // Find the current document to merge with updates
          const currentDoc = documents.find(d => d.id === id);
          if (!currentDoc) {
            throw new Error('Document not found');
          }
      
          const response = await fetch('/api/wiki/wiki', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id,
              title: updates.title || currentDoc.title,
              content: updates.content || currentDoc.content,
              category: updates.category || currentDoc.category,
              restricted: updates.restricted ?? currentDoc.restricted,
              isPinned: updates.isPinned ?? currentDoc.isPinned
            }),
          });
      
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to update document');
          }
      
          await fetchData();
          toast.success('Document updated successfully');
        } catch (error) {
          console.error('Error updating document:', error);
          toast.error(error instanceof Error ? error.message : 'Failed to update document');
          throw error;
        }
      }, [documents, fetchData]);
  
    const deleteDocument = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/wiki?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete document');
  
        await fetchData();
        if (selectedDocument?.id === id) {
          setSelectedDocument(null);
        }
        toast.success('Document deleted successfully');
      } catch (error) {
        console.error('Error deleting document:', error);
        toast.error('Failed to delete document');
        throw error;
      }
    }, [fetchData, selectedDocument?.id]);
  
    // Category actions
    const createCategory = useCallback(async (name: string, parentId?: number) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, parentId }),
        });
  
        if (!response.ok) throw new Error('Failed to create category');
  
        await fetchData();
        toast.success('Category created successfully');
      } catch (error) {
        console.error('Error creating category:', error);
        toast.error('Failed to create category');
        throw error;
      }
    }, [fetchData]);
  
    const updateCategory = useCallback(async (id: number, name: string) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, name }),
        });
  
        if (!response.ok) throw new Error('Failed to update category');
  
        await fetchData();
        toast.success('Category updated successfully');
      } catch (error) {
        console.error('Error updating category:', error);
        toast.error('Failed to update category');
        throw error;
      }
    }, [fetchData]);
  
    const deleteCategory = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/categories?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete category');
  
        await fetchData();
        toast.success('Category deleted successfully');
      } catch (error) {
        console.error('Error deleting category:', error);
        toast.error('Failed to delete category');
        throw error;
      }
    }, [fetchData]);
  
    const reorderCategory = useCallback(async (id: number, newOrder: number) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, order: newOrder }),
        });
  
        if (!response.ok) throw new Error('Failed to reorder category');
  
        await fetchData();
      } catch (error) {
        console.error('Error reordering category:', error);
        toast.error('Failed to reorder category');
        throw error;
      }
    }, [fetchData]);
  
    // Tag actions
    const createTag = useCallback(async (name: string, color: string) => {
      try {
        const response = await fetch('/api/wiki/tags', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, color }),
        });
  
        if (!response.ok) throw new Error('Failed to create tag');
  
        await fetchData();
        toast.success('Tag created successfully');
      } catch (error) {
        console.error('Error creating tag:', error);
        toast.error('Failed to create tag');
        throw error;
      }
    }, [fetchData]);
  
    const deleteTag = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/tags?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete tag');
  
        await fetchData();
        toast.success('Tag deleted successfully');
      } catch (error) {
        console.error('Error deleting tag:', error);
        toast.error('Failed to delete tag');
        throw error;
      }
    }, [fetchData]);
  
    const updateDocumentTags = useCallback(async (documentId: number, tagIds: number[]) => {
      try {
        const response = await fetch('/api/wiki/tags', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ documentId, tagIds }),
        });
  
        if (!response.ok) throw new Error('Failed to update document tags');
  
        await fetchData();
        toast.success('Tags updated successfully');
      } catch (error) {
        console.error('Error updating document tags:', error);
        toast.error('Failed to update document tags');
        throw error;
      }
    }, [fetchData]);
  
    // Search and filter
    const filterDocuments = useCallback((newFilter: DocumentFilter) => {
      setFilter(newFilter);
    }, []);
  
    const sortDocuments = useCallback((newSort: SortOption) => {
      setSort(newSort);
    }, []);
  
    // Auth
    const handlePasswordSubmit = useCallback(async (password: string) => {
      try {
        const response = await fetch('/api/wiki/verify-password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password }),
        });
  
        if (response.ok) {
          setIsUnlocked(true);
          setIsPasswordPromptOpen(false);
          toast.success('Successfully unlocked');
        } else {
          toast.error('Incorrect password');
        }
      } catch (error) {
        console.error('Error during authentication:', error);
        toast.error('Authentication failed');
      }
    }, []);
  
    // Create value object after all functions are defined
    const value = {
      documents,
      selectedDocument,
      categories: categoryHierarchy,
      tags,
      isEditing,
      isUnlocked,
      isLoading,
      error,
      isPasswordPromptOpen,
      selectDocument,
      createDocument,
      updateDocument,
      deleteDocument,
      createCategory,
      updateCategory,
      deleteCategory,
      reorderCategory,
      createTag,
      deleteTag,
      updateDocumentTags,
      setIsEditing,
      setIsUnlocked,
      setIsPasswordPromptOpen,
      filterDocuments,
      sortDocuments,
      handlePasswordSubmit,
    };
  
    return (
      <WikiContext.Provider value={value}>
        {children}
      </WikiContext.Provider>
    );
  }
=== FILE: ./src/lib/types/wiki.ts ===

// src/lib/types/wiki.ts
export interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
  isPinned?: boolean;
  createdAt: Date;
  updatedAt: Date;
  tags?: Array<{
    id: number;
    name: string;
    color: string;
  }>;
}

export interface Tag {
  id: number;
  name: string;
  color: string;
}

export interface Category {
  id: number;
  name: string;
  parentId: number | null;
  order: number;
}

export interface CategoryWithHierarchy extends Category {
  level: number;
  children: CategoryWithHierarchy[];
  documentCount: number;
}

export interface DocumentUpdate {
  title?: string;
  content?: string;
  category?: string;
  restricted?: boolean;
  isPinned?: boolean;
}

export interface SearchResult {
  document: Document;
  matches: {
    indices: [number, number][];
    key: string;
    value: string;
  }[];
  score: number;
}

export interface TOCItem {
  id: string;
  text: string;
  level: number;
}

// API Response Types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface DocumentResponse extends ApiResponse<Document> {}
export interface DocumentsResponse extends ApiResponse<Document[]> {}
export interface CategoryResponse extends ApiResponse<Category> {}
export interface CategoriesResponse extends ApiResponse<Category[]> {}
export interface TagResponse extends ApiResponse<Tag> {}
export interface TagsResponse extends ApiResponse<Tag[]> {}

// Action Types for any reducers you might add later
export type DocumentAction = 
  | { type: 'SET_DOCUMENTS'; payload: Document[] }
  | { type: 'ADD_DOCUMENT'; payload: Document }
  | { type: 'UPDATE_DOCUMENT'; payload: Document }
  | { type: 'DELETE_DOCUMENT'; payload: number }
  | { type: 'SET_SELECTED_DOCUMENT'; payload: Document | null }
  | { type: 'SET_IS_EDITING'; payload: boolean };

export type CategoryAction =
  | { type: 'SET_CATEGORIES'; payload: Category[] }
  | { type: 'ADD_CATEGORY'; payload: Category }
  | { type: 'UPDATE_CATEGORY'; payload: Category }
  | { type: 'DELETE_CATEGORY'; payload: number }
  | { type: 'REORDER_CATEGORY'; payload: { id: number; order: number } };

export type TagAction =
  | { type: 'SET_TAGS'; payload: Tag[] }
  | { type: 'ADD_TAG'; payload: Tag }
  | { type: 'UPDATE_TAG'; payload: Tag }
  | { type: 'DELETE_TAG'; payload: number };

// State Types for context
export interface WikiState {
  documents: Document[];
  selectedDocument: Document | null;
  categories: CategoryWithHierarchy[];
  tags: Tag[];
  isEditing: boolean;
  isUnlocked: boolean;
  isLoading: boolean;
  error: string | null;
}

// Additional Types for specific features
export interface DocumentFilter {
  category?: string;
  tag?: string;
  searchQuery?: string;
  restricted?: boolean;
  isPinned?: boolean;
}

export interface SortOption {
  field: keyof Document;
  direction: 'asc' | 'desc';
}

export interface DocumentStats {
  totalCount: number;
  restrictedCount: number;
  pinnedCount: number;
  categoryCounts: Record<string, number>;
  tagCounts: Record<string, number>;
  lastUpdated: Date;
}
=== FILE: ./src/lib/types/types.ts ===

// @/lib/types/wiki.ts
export interface Document {
  id: number;
  title: string;
  content: string;
  category: string;
  restricted: boolean;
}
=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    // Create documents table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN,
        isPinned BOOLEAN DEFAULT 0,
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);

    // Check and add category column to documents
    const documentsInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = documentsInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }

    // Create categories table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        parentId INTEGER,
        orderIndex INTEGER DEFAULT 0,
        FOREIGN KEY (parentId) REFERENCES categories(id)
      );
    `);

    // Create tags table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        color TEXT NOT NULL
      );
    `);

    // Create document_tags table for many-to-many relationship
    await db.exec(`
      CREATE TABLE IF NOT EXISTS document_tags (
        documentId INTEGER,
        tagId INTEGER,
        PRIMARY KEY (documentId, tagId),
        FOREIGN KEY (documentId) REFERENCES documents(id) ON DELETE CASCADE,
        FOREIGN KEY (tagId) REFERENCES tags(id) ON DELETE CASCADE
      );
    `);
  }
  return db;
}

// Rest of your existing functions remain the same...

export async function getCategories(): Promise<Category[]> {
  const db = await openDb();
  return db.all(`
    SELECT 
      c.id, 
      c.name, 
      c.parentId,
      c.orderIndex,
      COUNT(d.id) as documentCount
    FROM categories c
    LEFT JOIN documents d ON d.category = c.name
    GROUP BY c.id
    ORDER BY c.orderIndex
  `);
}

export async function createCategory(name: string, parentId?: number): Promise<Category> {
  const db = await openDb();
  const maxOrder = await db.get('SELECT MAX(orderIndex) as maxOrder FROM categories');
  const result = await db.run(
    'INSERT INTO categories (name, parentId, orderIndex) VALUES (?, ?, ?)',
    name,
    parentId || null,
    (maxOrder?.maxOrder || 0) + 1
  );
  return {
    id: result.lastID!,
    name,
    parentId: parentId || null,
    order: (maxOrder?.maxOrder || 0) + 1
  };
}

export async function updateCategory(id: number, name: string): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET name = ? WHERE id = ?', name, id);
}

export async function deleteCategory(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM categories WHERE id = ?', id);
}

export async function reorderCategory(id: number, newOrder: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET orderIndex = ? WHERE id = ?', newOrder, id);
}

export async function getTags(): Promise<Tag[]> {
  const db = await openDb();
  return db.all('SELECT * FROM tags');
}

export async function createTag(name: string, color: string): Promise<Tag> {
  const db = await openDb();
  const result = await db.run(
    'INSERT INTO tags (name, color) VALUES (?, ?)',
    name,
    color
  );
  return { id: result.lastID!, name, color };
}

export async function deleteTag(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM tags WHERE id = ?', id);
}

export async function updateDocumentTags(documentId: number, tagIds: number[]): Promise<void> {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    await db.run('DELETE FROM document_tags WHERE documentId = ?', documentId);
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        documentId,
        tagId
      );
    }
    await db.run('COMMIT');
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

// Update existing document functions to include new fields
export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  const documents = await db.all(`
    SELECT 
      d.*,
      GROUP_CONCAT(t.id) as tagIds,
      GROUP_CONCAT(t.name) as tagNames,
      GROUP_CONCAT(t.color) as tagColors
    FROM documents d
    LEFT JOIN document_tags dt ON d.id = dt.documentId
    LEFT JOIN tags t ON dt.tagId = t.id
    ${includeRestricted ? '' : 'WHERE d.restricted = 0'}
    GROUP BY d.id
    ORDER BY d.isPinned DESC, d.updatedAt DESC
  `);

  return documents.map(doc => ({
    ...doc,
    tags: doc.tagIds ? doc.tagIds.split(',').map((id: string, index: number) => ({
      id: parseInt(id),
      name: doc.tagNames.split(',')[index],
      color: doc.tagColors.split(',')[index]
    })) : []
  }));
}

export async function createDocument(
  title: string,
  content: string,
  restricted: boolean,
  categoryId: number,
  tagIds: number[] = []
) {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    const result = await db.run(
      `INSERT INTO documents (
        title, content, restricted, categoryId, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
      title,
      content,
      restricted ? 1 : 0,
      categoryId
    );
    
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        result.lastID,
        tagId
      );
    }
    
    await db.run('COMMIT');
    return result.lastID;
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

export async function toggleDocumentPin(id: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE documents SET isPinned = NOT isPinned WHERE id = ?', id);
}
=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 w-full">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              "hover:scale-[1.02]",
              item.className,
              item.hoverColor
            )}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/WikiWelcome.tsx ===

import React from 'react';
import { Card } from "@/components/ui/card";
import { Pin, Clock, Tag, FolderOpen } from "lucide-react";
import { useWiki } from '@/lib/context/WikiContext';
import { formatDistanceToNow } from 'date-fns';

export default function WelcomeScreen() {
  const { documents, selectDocument } = useWiki();

  const pinnedDocs = documents.filter(doc => doc.isPinned);
  const recentDocs = documents
    .filter(doc => !doc.isPinned)
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
    .slice(0, 5);

  // Calculate statistics
  const totalDocs = documents.length;
  const publicDocs = documents.filter(doc => !doc.restricted).length;
  const categories = [...new Set(documents.map(doc => doc.category))];

  return (
    <div className="p-8 max-w-6xl mx-auto">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold mb-4">Welcome to the Wiki</h1>
        <p className="text-xl text-muted-foreground">
          Your central hub for documentation and knowledge sharing
        </p>
      </div>

      {/* Quick Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12">
        <div className="bg-primary/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-primary mb-2">{totalDocs}</h3>
          <p className="text-sm text-muted-foreground">Total Documents</p>
        </div>
        <div className="bg-secondary/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-secondary mb-2">{categories.length}</h3>
          <p className="text-sm text-muted-foreground">Categories</p>
        </div>
        <div className="bg-accent/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-accent mb-2">{publicDocs}</h3>
          <p className="text-sm text-muted-foreground">Public Documents</p>
        </div>
      </div>

      {pinnedDocs.length > 0 && (
        <div className="mb-8">
          <div className="flex items-center gap-2 mb-4">
            <Pin className="w-5 h-5" />
            <h2 className="text-xl font-semibold">Pinned Documents</h2>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {pinnedDocs.map(doc => (
              <Card
                key={doc.id}
                className="p-4 cursor-pointer hover:bg-muted/50 transition-colors"
                onClick={() => selectDocument(doc.id)}
              >
                <h3 className="font-medium mb-2">{doc.title}</h3>
                <div className="text-sm text-muted-foreground mb-2 flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {doc.category}
                </div>
                {doc.tags && doc.tags.length > 0 && (
                  <div className="flex items-center gap-2 text-sm text-muted-foreground">
                    <Tag className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </Card>
            ))}
          </div>
        </div>
      )}

      <div>
        <div className="flex items-center gap-2 mb-4">
          <Clock className="w-5 h-5" />
          <h2 className="text-xl font-semibold">Recently Updated</h2>
        </div>
        <div className="space-y-2">
          {recentDocs.map(doc => (
            <div
              key={doc.id}
              className="p-4 border rounded-lg cursor-pointer hover:bg-muted/50 transition-colors"
              onClick={() => selectDocument(doc.id)}
            >
              <div className="flex items-center justify-between mb-1">
                <h3 className="font-medium">{doc.title}</h3>
                <span className="text-sm text-muted-foreground">
                  {formatDistanceToNow(new Date(doc.updatedAt), { addSuffix: true })}
                </span>
              </div>
              <div className="flex items-center gap-4 text-sm text-muted-foreground">
                <div className="flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {doc.category}
                </div>
                {doc.tags && doc.tags.length > 0 && (
                  <div className="flex items-center gap-2">
                    <Tag className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

// src/components/wiki/WikiHeader.tsx
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { useWiki } from '@/lib/context/WikiContext';

export const WikiHeader = () => {
  const { 
    isUnlocked,
    setIsUnlocked,
    setIsPasswordPromptOpen,
    isLoading 
  } = useWiki();

  const handleUnlockToggle = (checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  };

  return (
    <div className="flex-shrink-0 p-4 bg-base-300 border-b">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <h1 className="text-2xl font-bold">Wiki Documents</h1>
          <p className="text-[#D8DEE9]/80">
            Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to open apps
          </p>
        </div>
        
        <div className="flex items-center space-x-4">
          <Button onClick={() => setIsPasswordPromptOpen(true)}>Add New Page</Button>
          <Button variant="outline" onClick={() => setIsPasswordPromptOpen(true)}>
            Upload Word Document
          </Button>
          <div className="flex items-center space-x-2">
            <Switch
              id="lock-mode"
              checked={isUnlocked}
              onCheckedChange={handleUnlockToggle}
              disabled={isLoading}
            />
            <Label htmlFor="lock-mode">
              {isUnlocked ? 'Unlocked' : 'Locked'}
            </Label>
          </div>
        </div>
      </div>
    </div>
  );
};
=== FILE: ./src/components/wiki/CategoryManager.tsx ===

// @/components/wiki/CategoryManager.tsx
import React, { useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus, Edit2, Trash2, GripVertical, ChevronRight, ChevronDown } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { CategoryWithHierarchy, Tag } from '@/lib/types/wiki';
import { cn } from "@/lib/utils";

interface CategoryManagerProps {
  categories: CategoryWithHierarchy[];
  onCategoryCreate: (name: string, parentId?: number) => Promise<void>;
  onCategoryUpdate: (id: number, name: string) => Promise<void>;
  onCategoryDelete: (id: number) => Promise<void>;
  onCategoryMove: (id: number, parentId: number | null) => Promise<void>;
  onCategoryReorder: (id: number, newOrder: number) => Promise<void>;
}

const CategoryManager: React.FC<CategoryManagerProps> = ({
  categories,
  onCategoryCreate,
  onCategoryUpdate,
  onCategoryDelete,
  onCategoryMove,
  onCategoryReorder,
}) => {
  const [expandedCategories, setExpandedCategories] = useState<Set<number>>(new Set());
  const [draggedCategory, setDraggedCategory] = useState<number | null>(null);
  const [editCategory, setEditCategory] = useState<{ id: number; name: string } | null>(null);
  const [newCategoryName, setNewCategoryName] = useState("");
  const [selectedParentId, setSelectedParentId] = useState<number | null>(null);

  const toggleExpanded = (categoryId: number) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      if (newSet.has(categoryId)) {
        newSet.delete(categoryId);
      } else {
        newSet.add(categoryId);
      }
      return newSet;
    });
  };

  const handleDragStart = (e: React.DragEvent, categoryId: number) => {
    setDraggedCategory(categoryId);
    e.dataTransfer.setData('text/plain', categoryId.toString());
  };

  const handleDragOver = (e: React.DragEvent, categoryId: number) => {
    e.preventDefault();
    if (draggedCategory === categoryId) return;
    
    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;
    
    target.classList.remove('border-t-2', 'border-b-2');
    if (y < rect.height / 3) {
      target.classList.add('border-t-2');
    } else if (y > (rect.height * 2) / 3) {
      target.classList.add('border-b-2');
    }
  };

  const handleDrop = async (e: React.DragEvent, targetId: number) => {
    e.preventDefault();
    if (!draggedCategory) return;

    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;

    if (y < rect.height / 3) {
      // Drop above
      await onCategoryReorder(draggedCategory, targetId - 0.5);
    } else if (y > (rect.height * 2) / 3) {
      // Drop below
      await onCategoryReorder(draggedCategory, targetId + 0.5);
    } else {
      // Drop as child
      await onCategoryMove(draggedCategory, targetId);
    }

    setDraggedCategory(null);
    target.classList.remove('border-t-2', 'border-b-2');
  };

  const renderCategory = (category: CategoryWithHierarchy) => {
    const isExpanded = expandedCategories.has(category.id);
    
    return (
      <div key={category.id}>
        <div
          className={cn(
            "flex items-center p-2 rounded-lg hover:bg-muted/50 cursor-pointer",
            draggedCategory === category.id && "opacity-50"
          )}
          draggable
          onDragStart={(e) => handleDragStart(e, category.id)}
          onDragOver={(e) => handleDragOver(e, category.id)}
          onDrop={(e) => handleDrop(e, category.id)}
          style={{ marginLeft: `${category.level * 1.5}rem` }}
        >
          <button
            className="mr-2"
            onClick={() => toggleExpanded(category.id)}
          >
            {category.children.length > 0 && (
              isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />
            )}
          </button>
          
          <GripVertical className="w-4 h-4 mr-2 cursor-grab" />
          
          <span className="flex-1">{category.name}</span>
          
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                setEditCategory({ id: category.id, name: category.name });
              }}
            >
              <Edit2 size={16} />
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                onCategoryDelete(category.id);
              }}
            >
              <Trash2 size={16} />
            </Button>
          </div>
        </div>
        
        {isExpanded && (
          <motion.div
            initial={{ height: 0 }}
            animate={{ height: "auto" }}
            exit={{ height: 0 }}
          >
            {category.children.map(renderCategory)}
          </motion.div>
        )}
      </div>
    );
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Categories</h2>
        <Button onClick={() => setEditCategory({ id: -1, name: '' })}>
          <Plus size={16} className="mr-2" />
          Add Category
        </Button>
      </div>

      <div className="space-y-1">
        {categories.map(renderCategory)}
      </div>

      <Dialog open={!!editCategory} onOpenChange={() => setEditCategory(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {editCategory?.id === -1 ? 'Add Category' : 'Edit Category'}
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={editCategory?.name ?? ''}
                onChange={(e) => setEditCategory(prev => prev ? { ...prev, name: e.target.value } : null)}
                placeholder="Category name"
              />
            </div>

            {editCategory?.id === -1 && (
              <div>
                <select
                  value={selectedParentId?.toString() ?? ''}
                  onChange={(e) => setSelectedParentId(e.target.value ? Number(e.target.value) : null)}
                  className="w-full p-2 rounded-md border"
                >
                  <option value="">No parent (root category)</option>
                  {categories.map(cat => (
                    <option key={cat.id} value={cat.id}>
                      {'  '.repeat(cat.level)}{cat.name}
                    </option>
                  ))}
                </select>
              </div>
            )}

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setEditCategory(null)}>
                Cancel
              </Button>
              <Button
                onClick={async () => {
                  if (editCategory) {
                    if (editCategory.id === -1) {
                      await onCategoryCreate(editCategory.name, selectedParentId ?? undefined);
                    } else {
                      await onCategoryUpdate(editCategory.id, editCategory.name);
                    }
                    setEditCategory(null);
                  }
                }}
              >
                {editCategory?.id === -1 ? 'Create' : 'Update'}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default CategoryManager;
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useWiki } from '@/lib/context/WikiContext';
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content?: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/wiki/TagManager.tsx ===

// @/components/wiki/TagManager.tsx
import React, { useState } from 'react';
import { Plus, X } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Tag } from '@/lib/types/wiki';

interface TagManagerProps {
  tags: Tag[];
  onTagCreate: (name: string, color: string) => Promise<void>;
  onTagDelete: (id: number) => Promise<void>;
  onTagsChange: (documentId: number, tagIds: number[]) => Promise<void>;
}

const TagManager: React.FC<TagManagerProps> = ({
  tags,
  onTagCreate,
  onTagDelete,
  onTagsChange,
}) => {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [newTag, setNewTag] = useState({ name: '', color: '#3B82F6' });

  const handleCreateTag = async () => {
    await onTagCreate(newTag.name, newTag.color);
    setNewTag({ name: '', color: '#3B82F6' });
    setIsDialogOpen(false);
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Tags</h2>
        <Button onClick={() => setIsDialogOpen(true)}>
          <Plus size={16} className="mr-2" />
          Add Tag
        </Button>
      </div>

      <div className="flex flex-wrap gap-2">
        {tags.map(tag => (
          <div
            key={tag.id}
            className="flex items-center gap-2 px-3 py-1 rounded-full"
            style={{ backgroundColor: tag.color + '20', color: tag.color }}
          >
            <span>{tag.name}</span>
            <button
              onClick={() => onTagDelete(tag.id)}
              className="hover:opacity-75"
            >
              <X size={14} />
            </button>
          </div>
        ))}
      </div>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add Tag</DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={newTag.name}
                onChange={(e) => setNewTag(prev => ({ ...prev, name: e.target.value }))}
                placeholder="Tag name"
              />
            </div>

            <div>
              <input
                type="color"
                value={newTag.color}
                onChange={(e) => setNewTag(prev => ({ ...prev, color: e.target.value }))}
                className="w-full h-10 p-1 rounded border"
              />
            </div>

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleCreateTag}>
                Create
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default TagManager;
=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import { useWiki } from '@/lib/context/WikiContext';
import { cn } from "@/lib/utils";

export default function WikiSearch() {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<Array<any>>([]);
  const searchRef = useRef<HTMLInputElement>(null);
  const { documents, selectDocument } = useWiki();

  // Handle keyboard shortcut
  export function WikiSearch({ onOpen }: { onOpen: () => void }) {
    useEffect(() => {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.ctrlKey && e.code === 'Space') {
          e.preventDefault();
          onOpen();
        }
      };

      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onOpen]);

  // Search functionality
  const handleSearch = (value: string) => {
    setSearchQuery(value);
    if (!value.trim()) {
      setSearchResults([]);
      return;
    }

    const query = value.toLowerCase();
    const results = documents.filter(doc => 
      doc.title.toLowerCase().includes(query) ||
      doc.content.toLowerCase().includes(query) ||
      doc.category.toLowerCase().includes(query)
    );

    setSearchResults(results);
  };

  return (
    <div className="relative w-full">
      <Input
        ref={searchRef}
        type="text"
        value={searchQuery}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search documents... (Ctrl + Space)"
        onFocus={() => setIsOpen(true)}
        className="pl-10 py-6 text-lg"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.map((doc) => (
                <div
                  key={doc.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    selectDocument(doc.id);
                    setIsOpen(false);
                    setSearchQuery('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">{doc.title}</span>
                      <span className="text-xs text-muted-foreground">
                        {doc.category}
                      </span>
                    </div>
                    <p className="text-sm text-muted-foreground line-clamp-2">
                      {doc.content}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// src/components/wiki/WikiContent.tsx
import dynamic from 'next/dynamic';
import { useWiki } from '@/lib/context/WikiContext';
import WikiDocument from '@/components/wiki/WikiDocument';
import WelcomeScreen from './WikiWelcome';

const MarkdownEditor = dynamic(() => import('@/components/wiki/MarkdownEditor'), {
  ssr: false
});

export function WikiContent() {
  const {
    selectedDocument,
    isEditing,
    isUnlocked,
    updateDocument,
    setIsEditing,
  } = useWiki();

  if (!selectedDocument) {
    return <WelcomeScreen />;
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <MarkdownEditor
          documentId={selectedDocument.id}
          initialTitle={selectedDocument.title}
          initialContent={selectedDocument.content}
          onSave={async (title, content) => {
            await updateDocument(selectedDocument.id, title, content);
            setIsEditing(false);
          }}
          onCancel={() => setIsEditing(false)}
        />
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={updateDocument}
        onEdit={() => setIsEditing(true)}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React from 'react';
import { toast } from 'sonner';  // Add this import
import MarkdownPreview from '@uiw/react-markdown-preview';
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Breadcrumb, BreadcrumbItem, BreadcrumbLink } from "@/components/ui/breadcrumb";
import { Pin, PinOff, Lock, Pencil } from 'lucide-react';
import { Document } from '@/lib/types/wiki';
import '@uiw/react-markdown-preview/markdown.css';

interface WikiDocumentProps {
  document: Document;
  isUnlocked: boolean;
  onDocumentUpdate: (id: number, updates: Partial<Document>) => Promise<void>;
  onEdit: () => void;
}

export default function WikiDocument({ 
  document, 
  isUnlocked, 
  onDocumentUpdate,
  onEdit
}: WikiDocumentProps) {
  if (!document) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        No document selected
      </div>
    );
  }

  const togglePin = async () => {
    try {
      await onDocumentUpdate(document.id, {
        isPinned: !document.isPinned
      });
      toast.success(document.isPinned ? 'Document unpinned' : 'Document pinned');
    } catch (error) {
      console.error('Error toggling pin:', error);
      toast.error('Failed to update pin status');
    }
  };

  // Function to preprocess the Markdown content
  const preprocessMarkdown = (content: string) => {
    // Replace single line breaks with <br>, but preserve double line breaks
    return content.replace(/(?<!\n)\n(?!\n)/g, '  \n');
  };

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleString(undefined, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const processedContent = preprocessMarkdown(document.content);
  const canEdit = isUnlocked || !document.restricted;

  return (
    <div className="w-full h-full bg-background text-foreground">
      <div className="p-6 border-b">
        <Breadcrumb>
          <BreadcrumbItem>
            <BreadcrumbLink>Wiki</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem>
            <BreadcrumbLink>{document.category}</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem isCurrentPage>
            <span className="font-medium">{document.title}</span>
          </BreadcrumbItem>
        </Breadcrumb>

        <div className="mt-4 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <h1 className="text-2xl font-bold">{document.title}</h1>
            {document.restricted && (
              <Lock className="w-5 h-5 text-warning" />
            )}
          </div>

          <div className="flex items-center gap-2">
            {canEdit && (
              <>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={togglePin}
                  title={document.isPinned ? "Unpin document" : "Pin document"}
                >
                  {document.isPinned ? (
                    <PinOff className="w-4 h-4" />
                  ) : (
                    <Pin className="w-4 h-4" />
                  )}
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={onEdit}
                  title="Edit document"
                >
                  <Pencil className="w-4 h-4" />
                </Button>
              </>
            )}
          </div>
        </div>

        {document.tags && document.tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mt-4">
            {document.tags.map(tag => (
              <Badge
                key={tag.id}
                variant="outline"
                style={{
                  borderColor: tag.color,
                  color: tag.color,
                  backgroundColor: `${tag.color}10`
                }}
              >
                {tag.name}
              </Badge>
            ))}
          </div>
        )}

        <div className="text-sm text-muted-foreground mt-4">
          Last updated: {formatDate(document.updatedAt)}
        </div>
      </div>

      <div className="p-6 prose dark:prose-invert max-w-none">
        <MarkdownPreview 
          source={processedContent} 
          style={{
            backgroundColor: 'var(--background)',
            color: 'var(--foreground)',
          }}
        />
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
import { useWiki } from '@/lib/context/WikiContext';
import { Button } from "@/components/ui/button";
import { IconFileText, IconLock, IconEdit, IconTrash } from '@tabler/icons-react';

export default function WikiDocumentList() {
  const { 
    documents,
    selectedDocument,
    isUnlocked,
    selectDocument,
    deleteDocument,
    setIsEditing,
    isLoading
  } = useWiki();

  if (isLoading) {
    return (
      <div className="p-4 text-center">Loading documents...</div>
    );
  }

  const groupedDocuments = documents.reduce((acc, doc) => {
    if (!acc[doc.category]) {
      acc[doc.category] = [];
    }
    acc[doc.category].push(doc);
    return acc;
  }, {} as Record<string, typeof documents>);

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        {Object.entries(groupedDocuments).map(([category, docs]) => (
          <div key={category} className="mb-6">
            <h2 className="text-lg font-semibold mb-2">{category}</h2>
            <div className="space-y-2">
              {docs.map((doc) => (
                <div
                  key={doc.id}
                  className={`
                    border rounded-md overflow-hidden shadow-sm
                    ${doc.restricted && !isUnlocked ? 'opacity-50' : ''}
                    ${selectedDocument?.id === doc.id ? 'ring-2 ring-primary' : ''}
                  `}
                >
                  <div
                    className={`
                      flex items-center justify-between p-2
                      ${doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'}
                    `}
                    onClick={() => {
                      if (!(doc.restricted && !isUnlocked)) {
                        selectDocument(doc.id);
                      }
                    }}
                  >
                    <span className={doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'}>
                      {doc.title}
                    </span>
                    <div className="flex items-center space-x-2">
                      {doc.restricted && (
                        <IconLock size={16} className="text-warning" />
                      )}
                      {(!doc.restricted || isUnlocked) && (
                        <>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              selectDocument(doc.id);
                              setIsEditing(true);
                            }}
                          >
                            <IconEdit size={16} />
                            <span className="sr-only">Edit</span>
                          </Button>
                          {isUnlocked && (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={(e) => {
                                e.stopPropagation();
                                deleteDocument(doc.id);
                              }}
                            >
                              <IconTrash size={16} />
                              <span className="sr-only">Delete</span>
                            </Button>
                          )}
                        </>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;
    e.stopPropagation();

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        onClose();
        break;
    }
  };

  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true);
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm flex items-center justify-center"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <motion.div
              initial={{ scale: 0.95, opacity: 0, y: -20 }}
              animate={{ scale: 1, opacity: 1, y: 0 }}
              exit={{ scale: 0.95, opacity: 0, y: -20 }}
              className="w-full max-w-5xl mx-4 bg-background rounded-xl shadow-2xl overflow-hidden"
              onClick={stopPropagation}
            >
              <div className="p-6 border-b">
                <div className="relative">
                  <Input
                    ref={searchRef}
                    type="text"
                    value={inputValue}
                    onChange={handleInputChange}
                    placeholder="Search documents..."
                    className="pl-20 py-6 text-lg"
                    autoFocus
                  />
                  <Search className="w-6 h-6 absolute left-4 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                </div>
              </div>

              <div 
                ref={resultsRef}
                className="max-h-[400px] overflow-y-auto"
              >
                {searchResults.length === 0 && inputValue.trim() !== '' && (
                  <div className="p-8 text-center text-lg text-muted-foreground">
                    No results found
                  </div>
                )}
                <div className="h-auto">
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-6 min-h-[100px]",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-3 mb-2">
                        <FileText className="w-5 h-5 flex-shrink-0 text-muted-foreground" />
                        <span className="text-lg font-medium truncate">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-sm flex-shrink-0 text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-base text-muted-foreground ml-8 line-clamp-2">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="line-clamp-1">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
                {searchResults.length > 10 && (
                  <div className="p-4 text-center text-base text-muted-foreground">
                    {searchResults.length - 10} more results...
                  </div>
                )}
              </div>
            </motion.div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useCallback, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import 'easymde/dist/easymde.min.css';

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { ssr: false });

interface MarkdownEditorProps {
  documentId: number;
  initialTitle: string;
  initialContent: string;
  onSave: (title: string, content: string) => Promise<void>;
  onCancel: () => void;
}

export default function MarkdownEditor({
  documentId,
  initialTitle,
  initialContent,
  onSave,
  onCancel
}: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle);
  const [content, setContent] = useState(initialContent);
  const [isSaving, setIsSaving] = useState(false);

  // Handle Ctrl+S shortcut
  useEffect(() => {
    const handleKeyDown = async (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        await handleSave();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [title, content]);

  const handleSave = async () => {
    if (isSaving) return;
    setIsSaving(true);
    try {
      await onSave(title, content);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="Document Title"
          className="text-xl font-bold"
        />
      </div>

      <div className="flex-1">
        <SimpleMDE
          value={content}
          onChange={setContent}
          options={{
            spellChecker: false,
            status: false,
            minHeight: '400px',
            autofocus: true,
            autosave: {
              enabled: true,
              uniqueId: `document-${documentId}`,
              delay: 1000,
            },
          }}
        />
      </div>

      <div className="p-4 border-t flex justify-between items-center">
        <div className="text-sm text-muted-foreground">
          Press Ctrl + S to save
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button 
            onClick={handleSave}
            disabled={isSaving}
          >
            {isSaving ? 'Saving...' : 'Save'}
          </Button>
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/AddDocument.tsx ===

// @/components/wiki/AddDocument.tsx
import React, { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Category, Tag } from '@/lib/types/wiki';
import { X } from 'lucide-react';

interface AddDocumentProps {
  categories: Category[];
  tags: Tag[];
  onCreateDocument: (
    title: string,
    category: string,
    restricted: boolean,
    tagIds: number[],
    content?: string
  ) => Promise<void>;
  initialCategory?: string;
  onClose?: () => void;
}

export default function AddDocument({
  categories,
  tags,
  onCreateDocument,
  initialCategory = "",
  onClose
}: AddDocumentProps) {
  const [title, setTitle] = useState("");
  const [category, setCategory] = useState(initialCategory);
  const [restricted, setRestricted] = useState(false);
  const [selectedTags, setSelectedTags] = useState<number[]>([]);

  useEffect(() => {
    setCategory(initialCategory);
  }, [initialCategory]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await onCreateDocument(title, category, restricted, selectedTags);
    setTitle("");
    setCategory("");
    setRestricted(false);
    setSelectedTags([]);
    if (onClose) onClose();
  };

  const toggleTag = (tagId: number) => {
    setSelectedTags(prev => 
      prev.includes(tagId)
        ? prev.filter(id => id !== tagId)
        : [...prev, tagId]
    );
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>

      <div>
        <Label htmlFor="category">Category</Label>
        <Select value={category} onValueChange={setCategory} required>
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            {categories.map((cat) => (
              <SelectItem key={cat.id} value={cat.id.toString()}>
                {'  '.repeat(cat.level)}{cat.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div>
        <Label>Tags</Label>
        <div className="flex flex-wrap gap-2 mt-2">
          {tags.map(tag => (
            <Badge
              key={tag.id}
              variant={selectedTags.includes(tag.id) ? "default" : "outline"}
              className="cursor-pointer"
              style={{
                backgroundColor: selectedTags.includes(tag.id) ? tag.color + '20' : 'transparent',
                borderColor: tag.color,
                color: selectedTags.includes(tag.id) ? tag.color : 'inherit'
              }}
              onClick={() => toggleTag(tag.id)}
            >
              {tag.name}
              {selectedTags.includes(tag.id) && (
                <X className="w-3 h-3 ml-1" onClick={(e) => {
                  e.stopPropagation();
                  toggleTag(tag.id);
                }} />
              )}
            </Badge>
          ))}
        </div>
      </div>

      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>

      <Button type="submit">Create Document</Button>
    </form>
  );
}
=== FILE: ./src/components/wiki/KeyboardShortcutsHelp.tsx ===

export const KeyboardShortcutsHelp = ({ shortcuts }: { shortcuts: KeyboardShortcuts }) => {
    const groupedShortcuts = Object.values(shortcuts).reduce((acc, shortcut) => {
      if (!acc[shortcut.group]) {
        acc[shortcut.group] = [];
      }
      acc[shortcut.group].push(shortcut);
      return acc;
    }, {} as Record<string, KeyBinding[]>);
  
    return (
      <div className="space-y-6">
        {Object.entries(groupedShortcuts).map(([group, bindings]) => (
          <div key={group}>
            <h3 className="text-lg font-medium mb-2">{group}</h3>
            <div className="space-y-2">
              {bindings.map((binding) => (
                <div key={binding.key} className="flex justify-between">
                  <span>{binding.description}</span>
                  <kbd className="px-2 py-1 bg-muted rounded text-sm">
                    {binding.key.split('+').map(k => k.charAt(0).toUpperCase() + k.slice(1)).join(' + ')}
                  </kbd>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    );
  };
=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface PasswordPromptModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (password: string) => void
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(password)
    setPassword('')
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <Input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter password"
            className="mb-4"
          />
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/tags.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { getTags, createTag, deleteTag, updateDocumentTags } from '@/lib/db';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const tags = await getTags();
        res.status(200).json(tags);
        break;

      case 'POST':
        const { name, color } = req.body;
        const newTag = await createTag(name, color);
        res.status(201).json(newTag);
        break;

      case 'DELETE':
        await deleteTag(Number(req.query.id));
        res.status(200).json({ message: 'Tag deleted' });
        break;

      case 'PATCH':
        const { documentId, tagIds } = req.body;
        await updateDocumentTags(documentId, tagIds);
        res.status(200).json({ message: 'Document tags updated' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'DELETE', 'PATCH']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Tag API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;

  try {
    switch (req.method) {
      case 'GET':
        if (id) {
          const document = await prisma.document.findUnique({
            where: { id: parseInt(id as string) },
          });

          if (document) {
            res.status(200).json(document);
          } else {
            res.status(404).json({ error: 'Document not found' });
          }
        } else {
          const documents = await prisma.document.findMany({
            orderBy: [
              { isPinned: 'desc' },
              { updatedAt: 'desc' }
            ],
          });
          res.status(200).json(documents);
        }
        break;

      case 'POST':
        const { title, content, restricted, category } = req.body;

        if (!title) {
          return res.status(400).json({ error: 'Title is required' });
        }

        const newDocument = await prisma.document.create({
          data: {
            title,
            content: content || '',
            restricted: restricted || false,
            category: category || 'General',
            isPinned: false,
          },
        });
        res.status(201).json(newDocument);
        break;

        case 'PUT': {
          if (!id) {
            return res.status(400).json({ error: 'Document ID is required' });
          }
        
          const updates = req.body;
          const documentId = parseInt(id as string);
        
          try {
            // First get the existing document
            const existingDoc = await prisma.document.findUnique({
              where: { id: documentId },
            });
        
            if (!existingDoc) {
              return res.status(404).json({ error: 'Document not found' });
            }
        
            // Update with merged data
            const updatedDocument = await prisma.document.update({
              where: { id: documentId },
              data: {
                title: updates.title ?? existingDoc.title,
                content: updates.content ?? existingDoc.content,
                category: updates.category ?? existingDoc.category,
                restricted: updates.restricted ?? existingDoc.restricted,
                isPinned: updates.isPinned ?? existingDoc.isPinned,
              },
            });
        
            res.status(200).json(updatedDocument);
          } catch (error) {
            console.error('Error updating document:', error);
            res.status(500).json({ error: 'Error updating document' });
          }
          break;
        }

      case 'PATCH':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        const { restricted: patchRestricted, isPinned: patchIsPinned } = req.body;

        const patchedDocument = await prisma.document.update({
          where: { id: parseInt(id as string) },
          data: {
            ...(patchRestricted !== undefined && { restricted: patchRestricted }),
            ...(patchIsPinned !== undefined && { isPinned: patchIsPinned }),
          },
        });
        res.status(200).json(patchedDocument);
        break;

      case 'DELETE':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        await prisma.document.delete({
          where: { id: parseInt(id as string) },
        });
        res.status(200).json({ message: 'Document deleted successfully' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('API error:', error);
    
    // Check if it's a Prisma error
    if ((error as any).code === 'P2025') {
      return res.status(404).json({ error: 'Document not found' });
    }

    res.status(500).json({ 
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error : undefined
    });
  }
}
=== FILE: ./src/pages/api/wiki/categories.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { getCategories, createCategory, updateCategory, deleteCategory } from '@/lib/db';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const categories = await getCategories();
        res.status(200).json(categories);
        break;

      case 'POST':
        const { name, parentId } = req.body;
        const newCategory = await createCategory(name, parentId);
        res.status(201).json(newCategory);
        break;

      case 'PUT':
        const { id, name: updateName } = req.body;
        await updateCategory(id, updateName);
        res.status(200).json({ message: 'Category updated' });
        break;

      case 'DELETE':
        await deleteCategory(Number(req.query.id));
        res.status(200).json({ message: 'Category deleted' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Category API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/wiki.tsx ===

import { useState } from 'react';
import { useWiki } from '@/lib/context/WikiContext';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';

export default function WikiPage() {
  // Local state for dialogs
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isSearchOpen, setIsSearchOpen] = useState(false);

  // Get everything else from context
  const {
    documents,
    selectedDocument,
    categories,
    tags,
    isEditing,
    isUnlocked,
    isLoading,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    setIsEditing,
    selectDocument,
    updateDocument,
    deleteDocument,
    createDocument,
    setIsUnlocked,
    handlePasswordSubmit
  } = useWiki();

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={[]} // You might want to handle search results properly
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={selectDocument}
        onSearch={() => {}} // Implement search handling
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={() => {}} // Implement search results handling
        setSelectedDocument={selectDocument}
        setExpandedCategories={() => {}} // Implement category expansion handling
      />
    </div>
  );

  // Helper functions
  function handleDocumentSelect(id: number) {
    selectDocument(id);
    setIsEditing(false);
  }

  function handleUnlockToggle(checked: boolean) {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }

  function canEditDocument(document: any) {
    return isUnlocked || !document.restricted;
  }
}
=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./wiki_files.txt ===


=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285
=== FILE: ./prisma/schema.prisma ===

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Document {
  id         Int      @id @default(autoincrement())
  title      String
  content    String   @default("")
  restricted Boolean  @default(false)
  category   String   @default("General")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Category {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  parentId Int?      
  order    Int       @default(0)
}

model Tag {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  color     String
}
=== FILE: ./prisma/seed.ts ===

// prisma/seed.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // Create default categories
  await Promise.all([
    prisma.category.upsert({
      where: { name: 'General' },
      update: {},
      create: {
        name: 'General',
        order: 1
      }
    }),
    prisma.category.upsert({
      where: { name: 'Documentation' },
      update: {},
      create: {
        name: 'Documentation',
        order: 2
      }
    }),
    prisma.category.upsert({
      where: { name: 'Guides' },
      update: {},
      create: {
        name: 'Guides',
        order: 3
      }
    })
  ]);

  console.log('Database has been seeded');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
=== FILE: ./tailwind.config.js ===

const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  darkMode: "class",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      animation: {
        aurora: "aurora 60s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
      boxShadow: {
        input: "0px 2px 3px -1px rgba(0,0,0,0.1), 0px 1px 0px 0px rgba(25,28,33,0.02), 0px 0px 0px 1px rgba(25,28,33,0.08)",
      },
      keyframes: {
        aurora: {
          from: {
            backgroundPosition: "50% 50%, 50% 50%",
          },
          to: {
            backgroundPosition: "350% 50%, 350% 50%",
          },
        },
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
          content: "hsl(var(--primary-content))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
          content: "hsl(var(--secondary-content))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
          content: "hsl(var(--accent-content))",
        },
        neutral: {
          DEFAULT: "hsl(var(--neutral))",
          content: "hsl(var(--neutral-content))",
        },
        base: {
          100: "hsl(var(--base-100))",
          200: "hsl(var(--base-200))",
          300: "hsl(var(--base-300))",
          content: "hsl(var(--base-content))",
        },
        info: {
          DEFAULT: "hsl(var(--info))",
          content: "hsl(var(--info-content))",
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          content: "hsl(var(--success-content))",
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          content: "hsl(var(--warning-content))",
        },
        error: {
          DEFAULT: "hsl(var(--error))",
          content: "hsl(var(--error-content))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        // Custom colors
        red: "hsl(var(--red))",
        green: "hsl(var(--green))",
        blue: "hsl(var(--blue))",
        orange: "hsl(var(--orange))",
        yellow: "hsl(var(--yellow))",
        purple: "hsl(var(--purple))",
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [
    addVariablesForColors,
    require('tailwind-scrollbar-hide'),
    require("tailwindcss-animate"),
  ],
};

// This plugin adds each Tailwind color as a global CSS variable
function addVariablesForColors({ addBase, theme }) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );
  addBase({
    ":root": newVars,
  });
}

=== FILE: ./server.js ===

const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const app = express();
app.use(cors());
app.use(express.json());
const CSV_PATH = process.env.CSV_PATH || '/app/completions.csv';

app.get('/api/statistics/keab-training-data', (req, res) => {
  console.log('Received request for CSV data');
  try {
    const csvData = fs.readFileSync(CSV_PATH, 'utf8');
    console.log('CSV data read successfully. First 100 chars:', csvData.substring(0, 100));
    res.send(csvData);
  } catch (error) {
    console.error('Error reading CSV file:', error);
    res.status(500).send('Error reading CSV file');
  }
});

app.post('/api/statistics/add-csv-row', (req, res) => {
  console.log('Received request to add CSV row:', req.body);
  const newRow = Object.values(req.body).join(',') + '\n';
  fs.appendFile(CSV_PATH, newRow, (err) => {
    if (err) {
      console.error('Error appending to file:', err);
      return res.status(500).json({ error: 'Error adding row to CSV' });
    }
    console.log('Row added successfully');
    res.status(200).json({ message: 'Row added successfully' });
  });
});

app.post('/api/statistics/remove-csv-row', (req, res) => {
  console.log('Received request to remove CSV row:', req.body);
  const { index } = req.body;
  fs.readFile(CSV_PATH, 'utf8', (err, data) => {
    if (err) {
      console.error('Error reading CSV file:', err);
      return res.status(500).json({ error: 'Error reading CSV file' });
    }
    const rows = data.split('\n');
    if (index < 1 || index >= rows.length) {
      console.error('Invalid row index:', index);
      return res.status(400).json({ error: 'Invalid row index' });
    }
    rows.splice(index, 1);
    const updatedCsv = rows.join('\n');
    fs.writeFile(CSV_PATH, updatedCsv, (err) => {
      if (err) {
        console.error('Error writing file:', err);
        return res.status(500).json({ error: 'Error updating CSV file' });
      }
      console.log('Row removed successfully');
      res.status(200).json({ message: 'Row removed successfully' });
    });
  });
});

app.post('/api/statistics/edit-csv-row', (req, res) => {
  console.log('Received request to edit CSV row:', req.body);
  const { index, data } = req.body;
  
  fs.readFile(CSV_PATH, 'utf8', (err, fileData) => {
    if (err) {
      console.error('Error reading CSV file:', err);
      return res.status(500).json({ error: 'Error reading CSV file' });
    }

    try {
      const rows = fileData.split('\n');
      const headers = rows[0].split(',');
      
      if (index < 0 || index >= rows.length - 1) {
        console.error('Invalid row index:', index);
        return res.status(400).json({ error: 'Invalid row index' });
      }

      const newRowArray = headers.map(header => {
        const value = data[header];
        return value !== undefined ? value : '';
      });
      const newRowString = newRowArray.join(',');
      
      rows[index + 1] = newRowString;
      const updatedCsv = rows.join('\n');
      
      fs.writeFile(CSV_PATH, updatedCsv, (writeErr) => {
        if (writeErr) {
          console.error('Error writing file:', writeErr);
          return res.status(500).json({ error: 'Error updating CSV file' });
        }
        console.log('Row edited successfully');
        res.status(200).json({ message: 'Row edited successfully' });
      });
    } catch (error) {
      console.error('Error processing CSV data:', error);
      res.status(500).json({ error: 'Error processing CSV data' });
    }
  });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Node server running at http://0.0.0.0:${PORT}`);
  console.log('CSV file path:', CSV_PATH);
});
=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285
=== FILE: ./secret/encryption_iv.txt ===

	}ڒ_&^
=== FILE: ./secret/encrypted_password.txt ===

be6fca6ae6a048b3fae068dd81c5352c
=== FILE: ./secret/encryption_key.txt ===

UTTSŹ`fq¬)A~a9Nԗ
=== FILE: ./secret/password.txt ===

Kanin123!

=== FILE: ./tsconfig.json ===

{
  "compilerOptions": {
    "target": "es2018",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"],
  "ts-node": {
    "compilerOptions": {
      "module": "commonjs"
    }
  }
}

=== FILE: ./load-env.js ===

const fs = require('fs');
const dotenv = require('dotenv');

const envConfig = dotenv.parse(fs.readFileSync('.env.local'));
for (const k in envConfig) {
  process.env[k] = envConfig[k];
}

=== FILE: ./components.json ===

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui"
  }
}

=== FILE: ./eslint.config.js ===

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

=== FILE: ./postcss.config.js ===

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
