
=== FILE: ./src/lib/utils/apiUtils.ts ===

import { WikiError } from '@/lib/errors/wikiError';

export const handleApiResponse = async (response: Response, errorMessage: string) => {
  if (!response.ok) {
    throw new Error(errorMessage);
  }
  return response.json();
};
=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useEffect, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import Fuse from 'fuse.js';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Fuse.FuseResult<Document>[]>([]);

  // Enhanced Fuse configuration
  const searchIndex = useMemo(() => {
    return new Fuse(documents, {
      keys: [
        { 
          name: 'title',
          weight: 3.0  // Increased weight for titles
        },
        {
          name: 'content',
          weight: 1.0
        },
        {
          name: 'category',
          weight: 2.0
        }
      ],
      includeMatches: true,
      shouldSort: true,
      threshold: 0.3,      // Lower threshold for stricter matching
      location: 0,         // Start searching at beginning of strings
      distance: 200,       // Allow more distance for matches
      minMatchCharLength: 2,  // Minimum length for matches
      useExtendedSearch: true,
      ignoreLocation: false,  // Consider location in string for relevance
      findAllMatches: true,   // Find all matching instances
      // Add Swedish diacritics to equivalent chars
      getFn: (obj, path) => {
        const value = Fuse.config.getFn(obj, path);
        if (typeof value === 'string') {
          return value.toLowerCase()
            .replace(/[åä]/g, 'a')
            .replace(/ö/g, 'o');
        }
        return value;
      }
    });
  }, [documents]);

  // Add keyboard shortcut handler
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.code === 'Space') {
        e.preventDefault();
        setIsSearchOpen(true);
      }

      if (e.key === 'Escape' && isSearchOpen) {
        e.preventDefault();
        setIsSearchOpen(false);
        setSearchResults([]);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isSearchOpen]);

  const handleSearch = useCallback((query: string) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    // Use extended search syntax for better matching
    const searchPattern = query.split(' ').map(term => {
      // Exact match for terms with quotes
      if (term.startsWith('"') && term.endsWith('"')) {
        return `'${term.slice(1, -1)}`;
      }
      // Fuzzy matching for other terms
      return `${term}`;
    }).join(' ');

    const results = searchIndex.search(searchPattern);
    setSearchResults(results);
  }, [searchIndex]);

  // Add a cleanup function for when the search modal is closed
  const handleClose = useCallback(() => {
    setIsSearchOpen(false);
    setSearchResults([]);
  }, []);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch,
    handleClose
  };
};

// Add type exports if needed
export type SearchResult = Fuse.FuseResult<Document>;
=== FILE: ./src/lib/context/WikiContext.tsx ===

import React, { 
    createContext, 
    useContext, 
    useState, 
    useCallback, 
    useEffect,
    useMemo 
  } from 'react';
  import { toast } from 'react-hot-toast';
  import { 
    Document, 
    Category, 
    CategoryWithHierarchy, 
    Tag, 
    DocumentUpdate, 
    WikiState,
    DocumentFilter,
    SortOption
  } from '@/lib/types/wiki';
  
  interface WikiContextType extends WikiState {
    // Document actions
    selectDocument: (id: number | null) => void;
    createDocument: (title: string, category: string, restricted: boolean) => Promise<void>;
    updateDocument: (id: number, updates: DocumentUpdate) => Promise<void>;
    deleteDocument: (id: number) => Promise<void>;
    
    // Category actions
    createCategory: (name: string, parentId?: number) => Promise<void>;
    updateCategory: (id: number, name: string) => Promise<void>;
    deleteCategory: (id: number) => Promise<void>;
    reorderCategory: (id: number, newOrder: number) => Promise<void>;
    
    // Tag actions
    createTag: (name: string, color: string) => Promise<void>;
    deleteTag: (id: number) => Promise<void>;
    updateDocumentTags: (documentId: number, tagIds: number[]) => Promise<void>;
    
    // UI State actions
    setIsEditing: (value: boolean) => void;
    setIsUnlocked: (value: boolean) => void;
    
    // Search and filter
    filterDocuments: (filter: DocumentFilter) => void;
    sortDocuments: (sort: SortOption) => void;
    
    // Auth
    isPasswordPromptOpen: boolean;
    setIsPasswordPromptOpen: (value: boolean) => void;
    handlePasswordSubmit: (password: string) => Promise<void>;
  }
  
  const buildCategoryHierarchy = (
    categories: Category[],
    documents: Document[],
    parentId: number | null = null,
    level: number = 0
  ): CategoryWithHierarchy[] => {
    return categories
      .filter(cat => cat.parentId === parentId)
      .map(cat => ({
        ...cat,
        level,
        children: buildCategoryHierarchy(categories, documents, cat.id, level + 1),
        documentCount: documents.filter(doc => doc.category === cat.name).length
      }))
      .sort((a, b) => a.order - b.order);
  };
  
  const WikiContext = createContext<WikiContextType | null>(null);
  
  export function useWiki() {
    const context = useContext(WikiContext);
    if (!context) {
      throw new Error('useWiki must be used within a WikiProvider');
    }
    return context;
  }
  
  export function WikiProvider({ children }: { children: React.ReactNode }) {
    // State
    const [documents, setDocuments] = useState<Document[]>([]);
    const [categories, setCategories] = useState<Category[]>([]);
    const [tags, setTags] = useState<Tag[]>([]);
    const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
    const [isEditing, setIsEditing] = useState(false);
    const [isUnlocked, setIsUnlocked] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);
    const [filter, setFilter] = useState<DocumentFilter>({});
    const [sort, setSort] = useState<SortOption>({ field: 'updatedAt', direction: 'desc' });
  
    // Compute category hierarchy
    const categoryHierarchy = useMemo(() => 
      buildCategoryHierarchy(categories, documents),
      [categories, documents]
    );
  
    // Fetch initial data
    const fetchData = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        
        try {
          // Fetch documents first since we know that table exists
          const docsRes = await fetch('/api/wiki/wiki');
          if (!docsRes.ok) {
            throw new Error('Failed to fetch documents');
          }
          const docsData = await docsRes.json();
          setDocuments(docsData);
      
          try {
            // Try to fetch categories
            const catsRes = await fetch('/api/wiki/categories');
            if (catsRes.ok) {
              const catsData = await catsRes.json();
              setCategories(catsData);
            }
          } catch (error) {
            console.error('Error fetching categories:', error);
            setCategories([]); // Set empty array if categories fail
          }
      
          try {
            // Try to fetch tags
            const tagsRes = await fetch('/api/wiki/tags');
            if (tagsRes.ok) {
              const tagsData = await tagsRes.json();
              setTags(tagsData);
            }
          } catch (error) {
            console.error('Error fetching tags:', error);
            setTags([]); // Set empty array if tags fail
          }
      
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : 'An unexpected error occurred';
          console.error('Error fetching data:', err);
          setError(errorMessage);
          toast.error(errorMessage);
        } finally {
          setIsLoading(false);
        }
      }, []);
  
    useEffect(() => {
      fetchData();
    }, [fetchData]);
  
    // Document actions
    const selectDocument = useCallback((id: number | null) => {
      const doc = id ? documents.find(d => d.id === id) || null : null;
      setSelectedDocument(doc);
      setIsEditing(false);
    }, [documents]);
  
    const createDocument = useCallback(async (
      title: string,
      category: string,
      restricted: boolean
    ) => {
      try {
        const response = await fetch('/api/wiki/wiki', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, category, restricted }),
        });
  
        if (!response.ok) throw new Error('Failed to create document');
  
        await fetchData();
        toast.success('Document created successfully');
      } catch (error) {
        console.error('Error creating document:', error);
        toast.error('Failed to create document');
        throw error;
      }
    }, [fetchData]);
  
    const updateDocument = useCallback(async (
        id: number,
        updates: DocumentUpdate
      ) => {
        try {
          // Find the current document to merge with updates
          const currentDoc = documents.find(d => d.id === id);
          if (!currentDoc) {
            throw new Error('Document not found');
          }
      
          const response = await fetch('/api/wiki/wiki', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id,
              title: updates.title || currentDoc.title,
              content: updates.content || currentDoc.content,
              category: updates.category || currentDoc.category,
              restricted: updates.restricted ?? currentDoc.restricted,
              isPinned: updates.isPinned ?? currentDoc.isPinned
            }),
          });
      
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to update document');
          }
      
          await fetchData();
          toast.success('Document updated successfully');
        } catch (error) {
          console.error('Error updating document:', error);
          toast.error(error instanceof Error ? error.message : 'Failed to update document');
          throw error;
        }
      }, [documents, fetchData]);
  
    const deleteDocument = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/wiki?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete document');
  
        await fetchData();
        if (selectedDocument?.id === id) {
          setSelectedDocument(null);
        }
        toast.success('Document deleted successfully');
      } catch (error) {
        console.error('Error deleting document:', error);
        toast.error('Failed to delete document');
        throw error;
      }
    }, [fetchData, selectedDocument?.id]);
  
    // Category actions
    const createCategory = useCallback(async (name: string, parentId?: number) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, parentId }),
        });
  
        if (!response.ok) throw new Error('Failed to create category');
  
        await fetchData();
        toast.success('Category created successfully');
      } catch (error) {
        console.error('Error creating category:', error);
        toast.error('Failed to create category');
        throw error;
      }
    }, [fetchData]);
  
    const updateCategory = useCallback(async (id: number, name: string) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, name }),
        });
  
        if (!response.ok) throw new Error('Failed to update category');
  
        await fetchData();
        toast.success('Category updated successfully');
      } catch (error) {
        console.error('Error updating category:', error);
        toast.error('Failed to update category');
        throw error;
      }
    }, [fetchData]);
  
    const deleteCategory = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/categories?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete category');
  
        await fetchData();
        toast.success('Category deleted successfully');
      } catch (error) {
        console.error('Error deleting category:', error);
        toast.error('Failed to delete category');
        throw error;
      }
    }, [fetchData]);
  
    const reorderCategory = useCallback(async (id: number, newOrder: number) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, order: newOrder }),
        });
  
        if (!response.ok) throw new Error('Failed to reorder category');
  
        await fetchData();
      } catch (error) {
        console.error('Error reordering category:', error);
        toast.error('Failed to reorder category');
        throw error;
      }
    }, [fetchData]);
  
    // Tag actions
    const createTag = useCallback(async (name: string, color: string) => {
      try {
        const response = await fetch('/api/wiki/tags', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, color }),
        });
  
        if (!response.ok) throw new Error('Failed to create tag');
  
        await fetchData();
        toast.success('Tag created successfully');
      } catch (error) {
        console.error('Error creating tag:', error);
        toast.error('Failed to create tag');
        throw error;
      }
    }, [fetchData]);
  
    const deleteTag = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/tags?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete tag');
  
        await fetchData();
        toast.success('Tag deleted successfully');
      } catch (error) {
        console.error('Error deleting tag:', error);
        toast.error('Failed to delete tag');
        throw error;
      }
    }, [fetchData]);
  
    const updateDocumentTags = useCallback(async (documentId: number, tagIds: number[]) => {
      try {
        const response = await fetch('/api/wiki/tags', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ documentId, tagIds }),
        });
  
        if (!response.ok) throw new Error('Failed to update document tags');
  
        await fetchData();
        toast.success('Tags updated successfully');
      } catch (error) {
        console.error('Error updating document tags:', error);
        toast.error('Failed to update document tags');
        throw error;
      }
    }, [fetchData]);
  
    // Search and filter
    const filterDocuments = useCallback((newFilter: DocumentFilter) => {
      setFilter(newFilter);
    }, []);
  
    const sortDocuments = useCallback((newSort: SortOption) => {
      setSort(newSort);
    }, []);
  
    // Auth
    const handlePasswordSubmit = useCallback(async (password: string) => {
      try {
        const response = await fetch('/api/wiki/verify-password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password }),
        });
  
        if (response.ok) {
          setIsUnlocked(true);
          setIsPasswordPromptOpen(false);
          toast.success('Successfully unlocked');
        } else {
          toast.error('Incorrect password');
        }
      } catch (error) {
        console.error('Error during authentication:', error);
        toast.error('Authentication failed');
      }
    }, []);
  
    // Create value object after all functions are defined
    const value = {
      documents,
      selectedDocument,
      categories: categoryHierarchy,
      tags,
      isEditing,
      isUnlocked,
      isLoading,
      error,
      isPasswordPromptOpen,
      selectDocument,
      createDocument,
      updateDocument,
      deleteDocument,
      createCategory,
      updateCategory,
      deleteCategory,
      reorderCategory,
      createTag,
      deleteTag,
      updateDocumentTags,
      setIsEditing,
      setIsUnlocked,
      setIsPasswordPromptOpen,
      filterDocuments,
      sortDocuments,
      handlePasswordSubmit,
    };
  
    return (
      <WikiContext.Provider value={value}>
        {children}
      </WikiContext.Provider>
    );
  }
=== FILE: ./src/lib/types/wiki.ts ===

// src/lib/types/wiki.ts
export interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
  isPinned?: boolean;
  createdAt: Date;
  updatedAt: Date;
  tags?: Array<{
    id: number;
    name: string;
    color: string;
  }>;
}

export interface Tag {
  id: number;
  name: string;
  color: string;
}

export interface Category {
  id: number;
  name: string;
  parentId: number | null;
  order: number;
}

export interface CategoryWithHierarchy extends Category {
  level: number;
  children: CategoryWithHierarchy[];
  documentCount: number;
}

export interface DocumentUpdate {
  title?: string;
  content?: string;
  category?: string;
  restricted?: boolean;
  isPinned?: boolean;
}

export interface SearchResult {
  document: Document;
  matches: {
    indices: [number, number][];
    key: string;
    value: string;
  }[];
  score: number;
}

export interface TOCItem {
  id: string;
  text: string;
  level: number;
}

// API Response Types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface DocumentResponse extends ApiResponse<Document> {}
export interface DocumentsResponse extends ApiResponse<Document[]> {}
export interface CategoryResponse extends ApiResponse<Category> {}
export interface CategoriesResponse extends ApiResponse<Category[]> {}
export interface TagResponse extends ApiResponse<Tag> {}
export interface TagsResponse extends ApiResponse<Tag[]> {}

// Action Types for any reducers you might add later
export type DocumentAction = 
  | { type: 'SET_DOCUMENTS'; payload: Document[] }
  | { type: 'ADD_DOCUMENT'; payload: Document }
  | { type: 'UPDATE_DOCUMENT'; payload: Document }
  | { type: 'DELETE_DOCUMENT'; payload: number }
  | { type: 'SET_SELECTED_DOCUMENT'; payload: Document | null }
  | { type: 'SET_IS_EDITING'; payload: boolean };

export type CategoryAction =
  | { type: 'SET_CATEGORIES'; payload: Category[] }
  | { type: 'ADD_CATEGORY'; payload: Category }
  | { type: 'UPDATE_CATEGORY'; payload: Category }
  | { type: 'DELETE_CATEGORY'; payload: number }
  | { type: 'REORDER_CATEGORY'; payload: { id: number; order: number } };

export type TagAction =
  | { type: 'SET_TAGS'; payload: Tag[] }
  | { type: 'ADD_TAG'; payload: Tag }
  | { type: 'UPDATE_TAG'; payload: Tag }
  | { type: 'DELETE_TAG'; payload: number };

// State Types for context
export interface WikiState {
  documents: Document[];
  selectedDocument: Document | null;
  categories: CategoryWithHierarchy[];
  tags: Tag[];
  isEditing: boolean;
  isUnlocked: boolean;
  isLoading: boolean;
  error: string | null;
}

// Additional Types for specific features
export interface DocumentFilter {
  category?: string;
  tag?: string;
  searchQuery?: string;
  restricted?: boolean;
  isPinned?: boolean;
}

export interface SortOption {
  field: keyof Document;
  direction: 'asc' | 'desc';
}

export interface DocumentStats {
  totalCount: number;
  restrictedCount: number;
  pinnedCount: number;
  categoryCounts: Record<string, number>;
  tagCounts: Record<string, number>;
  lastUpdated: Date;
}
=== FILE: ./src/lib/types/types.ts ===

// @/lib/types/wiki.ts
export interface Document {
  id: number;
  title: string;
  content: string;
  category: string;
  restricted: boolean;
}
=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    // Create documents table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN,
        isPinned BOOLEAN DEFAULT 0,
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);

    // Check and add category column to documents
    const documentsInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = documentsInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }

    // Create categories table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        parentId INTEGER,
        orderIndex INTEGER DEFAULT 0,
        FOREIGN KEY (parentId) REFERENCES categories(id)
      );
    `);

    // Create tags table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        color TEXT NOT NULL
      );
    `);

    // Create document_tags table for many-to-many relationship
    await db.exec(`
      CREATE TABLE IF NOT EXISTS document_tags (
        documentId INTEGER,
        tagId INTEGER,
        PRIMARY KEY (documentId, tagId),
        FOREIGN KEY (documentId) REFERENCES documents(id) ON DELETE CASCADE,
        FOREIGN KEY (tagId) REFERENCES tags(id) ON DELETE CASCADE
      );
    `);
  }
  return db;
}

// Rest of your existing functions remain the same...

export async function getCategories(): Promise<Category[]> {
  const db = await openDb();
  return db.all(`
    SELECT 
      c.id, 
      c.name, 
      c.parentId,
      c.orderIndex,
      COUNT(d.id) as documentCount
    FROM categories c
    LEFT JOIN documents d ON d.category = c.name
    GROUP BY c.id
    ORDER BY c.orderIndex
  `);
}

export async function createCategory(name: string, parentId?: number): Promise<Category> {
  const db = await openDb();
  const maxOrder = await db.get('SELECT MAX(orderIndex) as maxOrder FROM categories');
  const result = await db.run(
    'INSERT INTO categories (name, parentId, orderIndex) VALUES (?, ?, ?)',
    name,
    parentId || null,
    (maxOrder?.maxOrder || 0) + 1
  );
  return {
    id: result.lastID!,
    name,
    parentId: parentId || null,
    order: (maxOrder?.maxOrder || 0) + 1
  };
}

export async function updateCategory(id: number, name: string): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET name = ? WHERE id = ?', name, id);
}

export async function deleteCategory(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM categories WHERE id = ?', id);
}

export async function reorderCategory(id: number, newOrder: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET orderIndex = ? WHERE id = ?', newOrder, id);
}

export async function getTags(): Promise<Tag[]> {
  const db = await openDb();
  return db.all('SELECT * FROM tags');
}

export async function createTag(name: string, color: string): Promise<Tag> {
  const db = await openDb();
  const result = await db.run(
    'INSERT INTO tags (name, color) VALUES (?, ?)',
    name,
    color
  );
  return { id: result.lastID!, name, color };
}

export async function deleteTag(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM tags WHERE id = ?', id);
}

export async function updateDocumentTags(documentId: number, tagIds: number[]): Promise<void> {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    await db.run('DELETE FROM document_tags WHERE documentId = ?', documentId);
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        documentId,
        tagId
      );
    }
    await db.run('COMMIT');
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

// Update existing document functions to include new fields
export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  const documents = await db.all(`
    SELECT 
      d.*,
      GROUP_CONCAT(t.id) as tagIds,
      GROUP_CONCAT(t.name) as tagNames,
      GROUP_CONCAT(t.color) as tagColors
    FROM documents d
    LEFT JOIN document_tags dt ON d.id = dt.documentId
    LEFT JOIN tags t ON dt.tagId = t.id
    ${includeRestricted ? '' : 'WHERE d.restricted = 0'}
    GROUP BY d.id
    ORDER BY d.isPinned DESC, d.updatedAt DESC
  `);

  return documents.map(doc => ({
    ...doc,
    tags: doc.tagIds ? doc.tagIds.split(',').map((id: string, index: number) => ({
      id: parseInt(id),
      name: doc.tagNames.split(',')[index],
      color: doc.tagColors.split(',')[index]
    })) : []
  }));
}

export async function createDocument(
  title: string,
  content: string,
  restricted: boolean,
  categoryId: number,
  tagIds: number[] = []
) {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    const result = await db.run(
      `INSERT INTO documents (
        title, content, restricted, categoryId, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
      title,
      content,
      restricted ? 1 : 0,
      categoryId
    );
    
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        result.lastID,
        tagId
      );
    }
    
    await db.run('COMMIT');
    return result.lastID;
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

export async function toggleDocumentPin(id: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE documents SET isPinned = NOT isPinned WHERE id = ?', id);
}
=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 w-full">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              "hover:scale-[1.02]",
              item.className,
              item.hoverColor
            )}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/WikiWelcome.tsx ===

import React from 'react';
import { Card } from "@/components/ui/card";
import { Pin, Clock, Tag, FolderOpen } from "lucide-react";
import { useWiki } from '@/lib/context/WikiContext';
import { formatDistanceToNow } from 'date-fns';

export default function WelcomeScreen() {
  const { documents, selectDocument } = useWiki();

  const pinnedDocs = documents.filter(doc => doc.isPinned);
  const recentDocs = documents
    .filter(doc => !doc.isPinned)
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
    .slice(0, 5);

  // Calculate statistics
  const totalDocs = documents.length;
  const publicDocs = documents.filter(doc => !doc.restricted).length;
  const categories = [...new Set(documents.map(doc => doc.category))];

  return (
    <div className="p-8 max-w-6xl mx-auto">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold mb-4">Welcome to the Wiki</h1>
        <p className="text-xl text-muted-foreground">
          Your central hub for documentation and knowledge sharing
        </p>
      </div>

      {/* Quick Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12">
        <div className="bg-primary/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-primary mb-2">{totalDocs}</h3>
          <p className="text-sm text-muted-foreground">Total Documents</p>
        </div>
        <div className="bg-secondary/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-secondary mb-2">{categories.length}</h3>
          <p className="text-sm text-muted-foreground">Categories</p>
        </div>
        <div className="bg-accent/10 rounded-lg p-6 text-center">
          <h3 className="text-2xl font-bold text-accent mb-2">{publicDocs}</h3>
          <p className="text-sm text-muted-foreground">Public Documents</p>
        </div>
      </div>

      {pinnedDocs.length > 0 && (
        <div className="mb-8">
          <div className="flex items-center gap-2 mb-4">
            <Pin className="w-5 h-5" />
            <h2 className="text-xl font-semibold">Pinned Documents</h2>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {pinnedDocs.map(doc => (
              <Card
                key={doc.id}
                className="p-4 cursor-pointer hover:bg-muted/50 transition-colors"
                onClick={() => selectDocument(doc.id)}
              >
                <h3 className="font-medium mb-2">{doc.title}</h3>
                <div className="text-sm text-muted-foreground mb-2 flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {doc.category}
                </div>
                {doc.tags && doc.tags.length > 0 && (
                  <div className="flex items-center gap-2 text-sm text-muted-foreground">
                    <Tag className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </Card>
            ))}
          </div>
        </div>
      )}

      <div>
        <div className="flex items-center gap-2 mb-4">
          <Clock className="w-5 h-5" />
          <h2 className="text-xl font-semibold">Recently Updated</h2>
        </div>
        <div className="space-y-2">
          {recentDocs.map(doc => (
            <div
              key={doc.id}
              className="p-4 border rounded-lg cursor-pointer hover:bg-muted/50 transition-colors"
              onClick={() => selectDocument(doc.id)}
            >
              <div className="flex items-center justify-between mb-1">
                <h3 className="font-medium">{doc.title}</h3>
                <span className="text-sm text-muted-foreground">
                  {formatDistanceToNow(new Date(doc.updatedAt), { addSuffix: true })}
                </span>
              </div>
              <div className="flex items-center gap-4 text-sm text-muted-foreground">
                <div className="flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {doc.category}
                </div>
                {doc.tags && doc.tags.length > 0 && (
                  <div className="flex items-center gap-2">
                    <Tag className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

// src/components/wiki/WikiHeader.tsx
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { useWiki } from '@/lib/context/WikiContext';

export const WikiHeader = () => {
  const { 
    isUnlocked,
    setIsUnlocked,
    setIsPasswordPromptOpen,
    isLoading 
  } = useWiki();

  const handleUnlockToggle = (checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  };

  return (
    <div className="flex-shrink-0 p-4 bg-base-300 border-b">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <h1 className="text-2xl font-bold">Wiki Documents</h1>
          <p className="text-[#D8DEE9]/80">
            Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to open apps
          </p>
        </div>
        
        <div className="flex items-center space-x-4">
          <Button onClick={() => setIsPasswordPromptOpen(true)}>Add New Page</Button>
          <Button variant="outline" onClick={() => setIsPasswordPromptOpen(true)}>
            Upload Word Document
          </Button>
          <div className="flex items-center space-x-2">
            <Switch
              id="lock-mode"
              checked={isUnlocked}
              onCheckedChange={handleUnlockToggle}
              disabled={isLoading}
            />
            <Label htmlFor="lock-mode">
              {isUnlocked ? 'Unlocked' : 'Locked'}
            </Label>
          </div>
        </div>
      </div>
    </div>
  );
};
=== FILE: ./src/components/wiki/CategoryManager.tsx ===

// @/components/wiki/CategoryManager.tsx
import React, { useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus, Edit2, Trash2, GripVertical, ChevronRight, ChevronDown } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { CategoryWithHierarchy, Tag } from '@/lib/types/wiki';
import { cn } from "@/lib/utils";

interface CategoryManagerProps {
  categories: CategoryWithHierarchy[];
  onCategoryCreate: (name: string, parentId?: number) => Promise<void>;
  onCategoryUpdate: (id: number, name: string) => Promise<void>;
  onCategoryDelete: (id: number) => Promise<void>;
  onCategoryMove: (id: number, parentId: number | null) => Promise<void>;
  onCategoryReorder: (id: number, newOrder: number) => Promise<void>;
}

const CategoryManager: React.FC<CategoryManagerProps> = ({
  categories,
  onCategoryCreate,
  onCategoryUpdate,
  onCategoryDelete,
  onCategoryMove,
  onCategoryReorder,
}) => {
  const [expandedCategories, setExpandedCategories] = useState<Set<number>>(new Set());
  const [draggedCategory, setDraggedCategory] = useState<number | null>(null);
  const [editCategory, setEditCategory] = useState<{ id: number; name: string } | null>(null);
  const [newCategoryName, setNewCategoryName] = useState("");
  const [selectedParentId, setSelectedParentId] = useState<number | null>(null);

  const toggleExpanded = (categoryId: number) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      if (newSet.has(categoryId)) {
        newSet.delete(categoryId);
      } else {
        newSet.add(categoryId);
      }
      return newSet;
    });
  };

  const handleDragStart = (e: React.DragEvent, categoryId: number) => {
    setDraggedCategory(categoryId);
    e.dataTransfer.setData('text/plain', categoryId.toString());
  };

  const handleDragOver = (e: React.DragEvent, categoryId: number) => {
    e.preventDefault();
    if (draggedCategory === categoryId) return;
    
    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;
    
    target.classList.remove('border-t-2', 'border-b-2');
    if (y < rect.height / 3) {
      target.classList.add('border-t-2');
    } else if (y > (rect.height * 2) / 3) {
      target.classList.add('border-b-2');
    }
  };

  const handleDrop = async (e: React.DragEvent, targetId: number) => {
    e.preventDefault();
    if (!draggedCategory) return;

    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;

    if (y < rect.height / 3) {
      // Drop above
      await onCategoryReorder(draggedCategory, targetId - 0.5);
    } else if (y > (rect.height * 2) / 3) {
      // Drop below
      await onCategoryReorder(draggedCategory, targetId + 0.5);
    } else {
      // Drop as child
      await onCategoryMove(draggedCategory, targetId);
    }

    setDraggedCategory(null);
    target.classList.remove('border-t-2', 'border-b-2');
  };

  const renderCategory = (category: CategoryWithHierarchy) => {
    const isExpanded = expandedCategories.has(category.id);
    
    return (
      <div key={category.id}>
        <div
          className={cn(
            "flex items-center p-2 rounded-lg hover:bg-muted/50 cursor-pointer",
            draggedCategory === category.id && "opacity-50"
          )}
          draggable
          onDragStart={(e) => handleDragStart(e, category.id)}
          onDragOver={(e) => handleDragOver(e, category.id)}
          onDrop={(e) => handleDrop(e, category.id)}
          style={{ marginLeft: `${category.level * 1.5}rem` }}
        >
          <button
            className="mr-2"
            onClick={() => toggleExpanded(category.id)}
          >
            {category.children.length > 0 && (
              isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />
            )}
          </button>
          
          <GripVertical className="w-4 h-4 mr-2 cursor-grab" />
          
          <span className="flex-1">{category.name}</span>
          
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                setEditCategory({ id: category.id, name: category.name });
              }}
            >
              <Edit2 size={16} />
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                onCategoryDelete(category.id);
              }}
            >
              <Trash2 size={16} />
            </Button>
          </div>
        </div>
        
        {isExpanded && (
          <motion.div
            initial={{ height: 0 }}
            animate={{ height: "auto" }}
            exit={{ height: 0 }}
          >
            {category.children.map(renderCategory)}
          </motion.div>
        )}
      </div>
    );
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Categories</h2>
        <Button onClick={() => setEditCategory({ id: -1, name: '' })}>
          <Plus size={16} className="mr-2" />
          Add Category
        </Button>
      </div>

      <div className="space-y-1">
        {categories.map(renderCategory)}
      </div>

      <Dialog open={!!editCategory} onOpenChange={() => setEditCategory(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {editCategory?.id === -1 ? 'Add Category' : 'Edit Category'}
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={editCategory?.name ?? ''}
                onChange={(e) => setEditCategory(prev => prev ? { ...prev, name: e.target.value } : null)}
                placeholder="Category name"
              />
            </div>

            {editCategory?.id === -1 && (
              <div>
                <select
                  value={selectedParentId?.toString() ?? ''}
                  onChange={(e) => setSelectedParentId(e.target.value ? Number(e.target.value) : null)}
                  className="w-full p-2 rounded-md border"
                >
                  <option value="">No parent (root category)</option>
                  {categories.map(cat => (
                    <option key={cat.id} value={cat.id}>
                      {'  '.repeat(cat.level)}{cat.name}
                    </option>
                  ))}
                </select>
              </div>
            )}

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setEditCategory(null)}>
                Cancel
              </Button>
              <Button
                onClick={async () => {
                  if (editCategory) {
                    if (editCategory.id === -1) {
                      await onCategoryCreate(editCategory.name, selectedParentId ?? undefined);
                    } else {
                      await onCategoryUpdate(editCategory.id, editCategory.name);
                    }
                    setEditCategory(null);
                  }
                }}
              >
                {editCategory?.id === -1 ? 'Create' : 'Update'}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default CategoryManager;
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useWiki } from '@/lib/context/WikiContext';
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content?: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/wiki/TagManager.tsx ===

// @/components/wiki/TagManager.tsx
import React, { useState } from 'react';
import { Plus, X } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Tag } from '@/lib/types/wiki';

interface TagManagerProps {
  tags: Tag[];
  onTagCreate: (name: string, color: string) => Promise<void>;
  onTagDelete: (id: number) => Promise<void>;
  onTagsChange: (documentId: number, tagIds: number[]) => Promise<void>;
}

const TagManager: React.FC<TagManagerProps> = ({
  tags,
  onTagCreate,
  onTagDelete,
  onTagsChange,
}) => {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [newTag, setNewTag] = useState({ name: '', color: '#3B82F6' });

  const handleCreateTag = async () => {
    await onTagCreate(newTag.name, newTag.color);
    setNewTag({ name: '', color: '#3B82F6' });
    setIsDialogOpen(false);
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Tags</h2>
        <Button onClick={() => setIsDialogOpen(true)}>
          <Plus size={16} className="mr-2" />
          Add Tag
        </Button>
      </div>

      <div className="flex flex-wrap gap-2">
        {tags.map(tag => (
          <div
            key={tag.id}
            className="flex items-center gap-2 px-3 py-1 rounded-full"
            style={{ backgroundColor: tag.color + '20', color: tag.color }}
          >
            <span>{tag.name}</span>
            <button
              onClick={() => onTagDelete(tag.id)}
              className="hover:opacity-75"
            >
              <X size={14} />
            </button>
          </div>
        ))}
      </div>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add Tag</DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={newTag.name}
                onChange={(e) => setNewTag(prev => ({ ...prev, name: e.target.value }))}
                placeholder="Tag name"
              />
            </div>

            <div>
              <input
                type="color"
                value={newTag.color}
                onChange={(e) => setNewTag(prev => ({ ...prev, color: e.target.value }))}
                className="w-full h-10 p-1 rounded border"
              />
            </div>

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleCreateTag}>
                Create
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default TagManager;
=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import { useWiki } from '@/lib/context/WikiContext';
import { cn } from "@/lib/utils";

export default function WikiSearch() {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<Array<any>>([]);
  const searchRef = useRef<HTMLInputElement>(null);
  const { documents, selectDocument } = useWiki();

  // Handle keyboard shortcut
  export function WikiSearch({ onOpen }: { onOpen: () => void }) {
    useEffect(() => {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.ctrlKey && e.code === 'Space') {
          e.preventDefault();
          onOpen();
        }
      };

      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onOpen]);

  // Search functionality
  const handleSearch = (value: string) => {
    setSearchQuery(value);
    if (!value.trim()) {
      setSearchResults([]);
      return;
    }

    const query = value.toLowerCase();
    const results = documents.filter(doc => 
      doc.title.toLowerCase().includes(query) ||
      doc.content.toLowerCase().includes(query) ||
      doc.category.toLowerCase().includes(query)
    );

    setSearchResults(results);
  };

  return (
    <div className="relative w-full">
      <Input
        ref={searchRef}
        type="text"
        value={searchQuery}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search documents... (Ctrl + Space)"
        onFocus={() => setIsOpen(true)}
        className="pl-10 py-6 text-lg"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.map((doc) => (
                <div
                  key={doc.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    selectDocument(doc.id);
                    setIsOpen(false);
                    setSearchQuery('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">{doc.title}</span>
                      <span className="text-xs text-muted-foreground">
                        {doc.category}
                      </span>
                    </div>
                    <p className="text-sm text-muted-foreground line-clamp-2">
                      {doc.content}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// src/components/wiki/WikiContent.tsx
import dynamic from 'next/dynamic';
import { useWiki } from '@/lib/context/WikiContext';
import WikiDocument from '@/components/wiki/WikiDocument';
import WelcomeScreen from './WikiWelcome';

const MarkdownEditor = dynamic(() => import('@/components/wiki/MarkdownEditor'), {
  ssr: false
});

export function WikiContent() {
  const {
    selectedDocument,
    isEditing,
    isUnlocked,
    updateDocument,
    setIsEditing,
  } = useWiki();

  if (!selectedDocument) {
    return <WelcomeScreen />;
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <MarkdownEditor
          documentId={selectedDocument.id}
          initialTitle={selectedDocument.title}
          initialContent={selectedDocument.content}
          onSave={async (title, content) => {
            await updateDocument(selectedDocument.id, title, content);
            setIsEditing(false);
          }}
          onCancel={() => setIsEditing(false)}
        />
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={updateDocument}
        onEdit={() => setIsEditing(true)}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React from 'react';
import { toast } from 'sonner';  // Add this import
import MarkdownPreview from '@uiw/react-markdown-preview';
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Breadcrumb, BreadcrumbItem, BreadcrumbLink } from "@/components/ui/breadcrumb";
import { Pin, PinOff, Lock, Pencil } from 'lucide-react';
import { Document } from '@/lib/types/wiki';
import '@uiw/react-markdown-preview/markdown.css';

interface WikiDocumentProps {
  document: Document;
  isUnlocked: boolean;
  onDocumentUpdate: (id: number, updates: Partial<Document>) => Promise<void>;
  onEdit: () => void;
}

export default function WikiDocument({ 
  document, 
  isUnlocked, 
  onDocumentUpdate,
  onEdit
}: WikiDocumentProps) {
  if (!document) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        No document selected
      </div>
    );
  }

  const togglePin = async () => {
    try {
      await onDocumentUpdate(document.id, {
        isPinned: !document.isPinned
      });
      toast.success(document.isPinned ? 'Document unpinned' : 'Document pinned');
    } catch (error) {
      console.error('Error toggling pin:', error);
      toast.error('Failed to update pin status');
    }
  };

  // Function to preprocess the Markdown content
  const preprocessMarkdown = (content: string) => {
    // Replace single line breaks with <br>, but preserve double line breaks
    return content.replace(/(?<!\n)\n(?!\n)/g, '  \n');
  };

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleString(undefined, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const processedContent = preprocessMarkdown(document.content);
  const canEdit = isUnlocked || !document.restricted;

  return (
    <div className="w-full h-full bg-background text-foreground">
      <div className="p-6 border-b">
        <Breadcrumb>
          <BreadcrumbItem>
            <BreadcrumbLink>Wiki</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem>
            <BreadcrumbLink>{document.category}</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem isCurrentPage>
            <span className="font-medium">{document.title}</span>
          </BreadcrumbItem>
        </Breadcrumb>

        <div className="mt-4 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <h1 className="text-2xl font-bold">{document.title}</h1>
            {document.restricted && (
              <Lock className="w-5 h-5 text-warning" />
            )}
          </div>

          <div className="flex items-center gap-2">
            {canEdit && (
              <>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={togglePin}
                  title={document.isPinned ? "Unpin document" : "Pin document"}
                >
                  {document.isPinned ? (
                    <PinOff className="w-4 h-4" />
                  ) : (
                    <Pin className="w-4 h-4" />
                  )}
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={onEdit}
                  title="Edit document"
                >
                  <Pencil className="w-4 h-4" />
                </Button>
              </>
            )}
          </div>
        </div>

        {document.tags && document.tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mt-4">
            {document.tags.map(tag => (
              <Badge
                key={tag.id}
                variant="outline"
                style={{
                  borderColor: tag.color,
                  color: tag.color,
                  backgroundColor: `${tag.color}10`
                }}
              >
                {tag.name}
              </Badge>
            ))}
          </div>
        )}

        <div className="text-sm text-muted-foreground mt-4">
          Last updated: {formatDate(document.updatedAt)}
        </div>
      </div>

      <div className="p-6 prose dark:prose-invert max-w-none">
        <MarkdownPreview 
          source={processedContent} 
          style={{
            backgroundColor: 'var(--background)',
            color: 'var(--foreground)',
          }}
        />
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
import { useWiki } from '@/lib/context/WikiContext';
import { Button } from "@/components/ui/button";
import { IconFileText, IconLock, IconEdit, IconTrash } from '@tabler/icons-react';

export default function WikiDocumentList() {
  const { 
    documents,
    selectedDocument,
    isUnlocked,
    selectDocument,
    deleteDocument,
    setIsEditing,
    isLoading
  } = useWiki();

  if (isLoading) {
    return (
      <div className="p-4 text-center">Loading documents...</div>
    );
  }

  const groupedDocuments = documents.reduce((acc, doc) => {
    if (!acc[doc.category]) {
      acc[doc.category] = [];
    }
    acc[doc.category].push(doc);
    return acc;
  }, {} as Record<string, typeof documents>);

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        {Object.entries(groupedDocuments).map(([category, docs]) => (
          <div key={category} className="mb-6">
            <h2 className="text-lg font-semibold mb-2">{category}</h2>
            <div className="space-y-2">
              {docs.map((doc) => (
                <div
                  key={doc.id}
                  className={`
                    border rounded-md overflow-hidden shadow-sm
                    ${doc.restricted && !isUnlocked ? 'opacity-50' : ''}
                    ${selectedDocument?.id === doc.id ? 'ring-2 ring-primary' : ''}
                  `}
                >
                  <div
                    className={`
                      flex items-center justify-between p-2
                      ${doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'}
                    `}
                    onClick={() => {
                      if (!(doc.restricted && !isUnlocked)) {
                        selectDocument(doc.id);
                      }
                    }}
                  >
                    <span className={doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'}>
                      {doc.title}
                    </span>
                    <div className="flex items-center space-x-2">
                      {doc.restricted && (
                        <IconLock size={16} className="text-warning" />
                      )}
                      {(!doc.restricted || isUnlocked) && (
                        <>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              selectDocument(doc.id);
                              setIsEditing(true);
                            }}
                          >
                            <IconEdit size={16} />
                            <span className="sr-only">Edit</span>
                          </Button>
                          {isUnlocked && (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={(e) => {
                                e.stopPropagation();
                                deleteDocument(doc.id);
                              }}
                            >
                              <IconTrash size={16} />
                              <span className="sr-only">Delete</span>
                            </Button>
                          )}
                        </>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;
    e.stopPropagation();

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        onClose();
        break;
    }
  };

  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true);
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm flex items-center justify-center"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <motion.div
              initial={{ scale: 0.95, opacity: 0, y: -20 }}
              animate={{ scale: 1, opacity: 1, y: 0 }}
              exit={{ scale: 0.95, opacity: 0, y: -20 }}
              className="w-full max-w-5xl mx-4 bg-background rounded-xl shadow-2xl overflow-hidden"
              onClick={stopPropagation}
            >
              <div className="p-6 border-b">
                <div className="relative">
                  <Input
                    ref={searchRef}
                    type="text"
                    value={inputValue}
                    onChange={handleInputChange}
                    placeholder="Search documents..."
                    className="pl-20 py-6 text-lg"
                    autoFocus
                  />
                  <Search className="w-6 h-6 absolute left-4 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                </div>
              </div>

              <div 
                ref={resultsRef}
                className="max-h-[400px] overflow-y-auto"
              >
                {searchResults.length === 0 && inputValue.trim() !== '' && (
                  <div className="p-8 text-center text-lg text-muted-foreground">
                    No results found
                  </div>
                )}
                <div className="h-auto">
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-6 min-h-[100px]",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-3 mb-2">
                        <FileText className="w-5 h-5 flex-shrink-0 text-muted-foreground" />
                        <span className="text-lg font-medium truncate">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-sm flex-shrink-0 text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-base text-muted-foreground ml-8 line-clamp-2">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="line-clamp-1">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
                {searchResults.length > 10 && (
                  <div className="p-4 text-center text-base text-muted-foreground">
                    {searchResults.length - 10} more results...
                  </div>
                )}
              </div>
            </motion.div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useCallback, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import 'easymde/dist/easymde.min.css';

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { ssr: false });

interface MarkdownEditorProps {
  documentId: number;
  initialTitle: string;
  initialContent: string;
  onSave: (title: string, content: string) => Promise<void>;
  onCancel: () => void;
}

export default function MarkdownEditor({
  documentId,
  initialTitle,
  initialContent,
  onSave,
  onCancel
}: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle);
  const [content, setContent] = useState(initialContent);
  const [isSaving, setIsSaving] = useState(false);

  // Handle Ctrl+S shortcut
  useEffect(() => {
    const handleKeyDown = async (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        await handleSave();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [title, content]);

  const handleSave = async () => {
    if (isSaving) return;
    setIsSaving(true);
    try {
      await onSave(title, content);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="Document Title"
          className="text-xl font-bold"
        />
      </div>

      <div className="flex-1">
        <SimpleMDE
          value={content}
          onChange={setContent}
          options={{
            spellChecker: false,
            status: false,
            minHeight: '400px',
            autofocus: true,
            autosave: {
              enabled: true,
              uniqueId: `document-${documentId}`,
              delay: 1000,
            },
          }}
        />
      </div>

      <div className="p-4 border-t flex justify-between items-center">
        <div className="text-sm text-muted-foreground">
          Press Ctrl + S to save
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button 
            onClick={handleSave}
            disabled={isSaving}
          >
            {isSaving ? 'Saving...' : 'Save'}
          </Button>
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/AddDocument.tsx ===

// @/components/wiki/AddDocument.tsx
import React, { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Category, Tag } from '@/lib/types/wiki';
import { X } from 'lucide-react';

interface AddDocumentProps {
  categories: Category[];
  tags: Tag[];
  onCreateDocument: (
    title: string,
    category: string,
    restricted: boolean,
    tagIds: number[],
    content?: string
  ) => Promise<void>;
  initialCategory?: string;
  onClose?: () => void;
}

export default function AddDocument({
  categories,
  tags,
  onCreateDocument,
  initialCategory = "",
  onClose
}: AddDocumentProps) {
  const [title, setTitle] = useState("");
  const [category, setCategory] = useState(initialCategory);
  const [restricted, setRestricted] = useState(false);
  const [selectedTags, setSelectedTags] = useState<number[]>([]);

  useEffect(() => {
    setCategory(initialCategory);
  }, [initialCategory]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await onCreateDocument(title, category, restricted, selectedTags);
    setTitle("");
    setCategory("");
    setRestricted(false);
    setSelectedTags([]);
    if (onClose) onClose();
  };

  const toggleTag = (tagId: number) => {
    setSelectedTags(prev => 
      prev.includes(tagId)
        ? prev.filter(id => id !== tagId)
        : [...prev, tagId]
    );
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>

      <div>
        <Label htmlFor="category">Category</Label>
        <Select value={category} onValueChange={setCategory} required>
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            {categories.map((cat) => (
              <SelectItem key={cat.id} value={cat.id.toString()}>
                {'  '.repeat(cat.level)}{cat.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div>
        <Label>Tags</Label>
        <div className="flex flex-wrap gap-2 mt-2">
          {tags.map(tag => (
            <Badge
              key={tag.id}
              variant={selectedTags.includes(tag.id) ? "default" : "outline"}
              className="cursor-pointer"
              style={{
                backgroundColor: selectedTags.includes(tag.id) ? tag.color + '20' : 'transparent',
                borderColor: tag.color,
                color: selectedTags.includes(tag.id) ? tag.color : 'inherit'
              }}
              onClick={() => toggleTag(tag.id)}
            >
              {tag.name}
              {selectedTags.includes(tag.id) && (
                <X className="w-3 h-3 ml-1" onClick={(e) => {
                  e.stopPropagation();
                  toggleTag(tag.id);
                }} />
              )}
            </Badge>
          ))}
        </div>
      </div>

      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>

      <Button type="submit">Create Document</Button>
    </form>
  );
}
=== FILE: ./src/components/wiki/KeyboardShortcutsHelp.tsx ===

export const KeyboardShortcutsHelp = ({ shortcuts }: { shortcuts: KeyboardShortcuts }) => {
    const groupedShortcuts = Object.values(shortcuts).reduce((acc, shortcut) => {
      if (!acc[shortcut.group]) {
        acc[shortcut.group] = [];
      }
      acc[shortcut.group].push(shortcut);
      return acc;
    }, {} as Record<string, KeyBinding[]>);
  
    return (
      <div className="space-y-6">
        {Object.entries(groupedShortcuts).map(([group, bindings]) => (
          <div key={group}>
            <h3 className="text-lg font-medium mb-2">{group}</h3>
            <div className="space-y-2">
              {bindings.map((binding) => (
                <div key={binding.key} className="flex justify-between">
                  <span>{binding.description}</span>
                  <kbd className="px-2 py-1 bg-muted rounded text-sm">
                    {binding.key.split('+').map(k => k.charAt(0).toUpperCase() + k.slice(1)).join(' + ')}
                  </kbd>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    );
  };
=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface PasswordPromptModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (password: string) => void
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(password)
    setPassword('')
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <Input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter password"
            className="mb-4"
          />
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/tags.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { getTags, createTag, deleteTag, updateDocumentTags } from '@/lib/db';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const tags = await getTags();
        res.status(200).json(tags);
        break;

      case 'POST':
        const { name, color } = req.body;
        const newTag = await createTag(name, color);
        res.status(201).json(newTag);
        break;

      case 'DELETE':
        await deleteTag(Number(req.query.id));
        res.status(200).json({ message: 'Tag deleted' });
        break;

      case 'PATCH':
        const { documentId, tagIds } = req.body;
        await updateDocumentTags(documentId, tagIds);
        res.status(200).json({ message: 'Document tags updated' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'DELETE', 'PATCH']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Tag API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;

  try {
    switch (req.method) {
      case 'GET':
        if (id) {
          const document = await prisma.document.findUnique({
            where: { id: parseInt(id as string) },
          });

          if (document) {
            res.status(200).json(document);
          } else {
            res.status(404).json({ error: 'Document not found' });
          }
        } else {
          const documents = await prisma.document.findMany({
            orderBy: [
              { isPinned: 'desc' },
              { updatedAt: 'desc' }
            ],
          });
          res.status(200).json(documents);
        }
        break;

      case 'POST':
        const { title, content, restricted, category } = req.body;

        if (!title) {
          return res.status(400).json({ error: 'Title is required' });
        }

        const newDocument = await prisma.document.create({
          data: {
            title,
            content: content || '',
            restricted: restricted || false,
            category: category || 'General',
            isPinned: false,
          },
        });
        res.status(201).json(newDocument);
        break;

        case 'PUT': {
          if (!id) {
            return res.status(400).json({ error: 'Document ID is required' });
          }
        
          const updates = req.body;
          const documentId = parseInt(id as string);
        
          try {
            // First get the existing document
            const existingDoc = await prisma.document.findUnique({
              where: { id: documentId },
            });
        
            if (!existingDoc) {
              return res.status(404).json({ error: 'Document not found' });
            }
        
            // Update with merged data
            const updatedDocument = await prisma.document.update({
              where: { id: documentId },
              data: {
                title: updates.title ?? existingDoc.title,
                content: updates.content ?? existingDoc.content,
                category: updates.category ?? existingDoc.category,
                restricted: updates.restricted ?? existingDoc.restricted,
                isPinned: updates.isPinned ?? existingDoc.isPinned,
              },
            });
        
            res.status(200).json(updatedDocument);
          } catch (error) {
            console.error('Error updating document:', error);
            res.status(500).json({ error: 'Error updating document' });
          }
          break;
        }

      case 'PATCH':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        const { restricted: patchRestricted, isPinned: patchIsPinned } = req.body;

        const patchedDocument = await prisma.document.update({
          where: { id: parseInt(id as string) },
          data: {
            ...(patchRestricted !== undefined && { restricted: patchRestricted }),
            ...(patchIsPinned !== undefined && { isPinned: patchIsPinned }),
          },
        });
        res.status(200).json(patchedDocument);
        break;

      case 'DELETE':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        await prisma.document.delete({
          where: { id: parseInt(id as string) },
        });
        res.status(200).json({ message: 'Document deleted successfully' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('API error:', error);
    
    // Check if it's a Prisma error
    if ((error as any).code === 'P2025') {
      return res.status(404).json({ error: 'Document not found' });
    }

    res.status(500).json({ 
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error : undefined
    });
  }
}
=== FILE: ./src/pages/api/wiki/categories.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { getCategories, createCategory, updateCategory, deleteCategory } from '@/lib/db';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const categories = await getCategories();
        res.status(200).json(categories);
        break;

      case 'POST':
        const { name, parentId } = req.body;
        const newCategory = await createCategory(name, parentId);
        res.status(201).json(newCategory);
        break;

      case 'PUT':
        const { id, name: updateName } = req.body;
        await updateCategory(id, updateName);
        res.status(200).json({ message: 'Category updated' });
        break;

      case 'DELETE':
        await deleteCategory(Number(req.query.id));
        res.status(200).json({ message: 'Category deleted' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Category API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/wiki.tsx ===

import { useState } from 'react';
import { useWiki } from '@/lib/context/WikiContext';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';

export default function WikiPage() {
  // Local state for dialogs
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isSearchOpen, setIsSearchOpen] = useState(false);

  // Get everything else from context
  const {
    documents,
    selectedDocument,
    categories,
    tags,
    isEditing,
    isUnlocked,
    isLoading,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    setIsEditing,
    selectDocument,
    updateDocument,
    deleteDocument,
    createDocument,
    setIsUnlocked,
    handlePasswordSubmit
  } = useWiki();

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={[]} // You might want to handle search results properly
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={selectDocument}
        onSearch={() => {}} // Implement search handling
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={() => {}} // Implement search results handling
        setSelectedDocument={selectDocument}
        setExpandedCategories={() => {}} // Implement category expansion handling
      />
    </div>
  );

  // Helper functions
  function handleDocumentSelect(id: number) {
    selectDocument(id);
    setIsEditing(false);
  }

  function handleUnlockToggle(checked: boolean) {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }

  function canEditDocument(document: any) {
    return isUnlocked || !document.restricted;
  }
}
=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./wiki_files.txt ===


=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285