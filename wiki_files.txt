
=== FILE: ./statistics_files.txt ===


=== FILE: ./statistics_files.txt ===


=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/statistics/CsvStatisticsPage.tsx ===

"use client";
import React from "react";
import { BackgroundGradient } from "@/components/ui/background-gradient";
import { IconDatabase } from "@tabler/icons-react";
import { useRouter } from 'next/router';

export function CsvStatisticsPage() {
  const router = useRouter();

  return (
    <div className="min-h-screen w-full p-4 md:p-8 gap-4">
      <h1 className="text-2xl font-bold text-neutral-800 dark:text-neutral-200 mb-4">
        Statistics Dashboard
      </h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div 
          onClick={() => router.push('/statistics/csv')} 
          className="cursor-pointer"
        >
          <BackgroundGradient className="rounded-[22px] p-4 sm:p-10 bg-white dark:bg-zinc-900">
            <div className="flex flex-col items-center justify-center">
              <div className="p-4 bg-blue-500/10 dark:bg-blue-500/20 rounded-full">
                <IconDatabase className="w-8 h-8 text-blue-500" />
              </div>
              <h2 className="text-base sm:text-xl text-black mt-4 mb-2 dark:text-neutral-200 font-medium">
                Training Data Management
              </h2>
              <p className="text-sm text-neutral-600 dark:text-neutral-400 text-center">
                View and manage your AI training data records. Add, edit, or remove entries from your dataset.
              </p>
              <div className="mt-4 w-full">
                <button 
                  className="rounded-full w-full pl-4 pr-1 py-1 text-white flex items-center justify-center space-x-1 bg-black mt-4 text-xs font-bold dark:bg-zinc-800"
                  onClick={(e) => {
                    e.stopPropagation();
                    router.push('/statistics/csv');
                  }}
                >
                  <span>Open Manager</span>
                  <span className="bg-zinc-700 rounded-full px-2 py-0 text-white">→</span>
                </button>
              </div>
            </div>
          </BackgroundGradient>
        </div>

        {/* Add more statistics cards here in the future */}
      </div>
    </div>
  );
}

=== FILE: ./src/components/statistics/csv-manager.tsx ===

import React, { useState, useCallback } from 'react';
import useSWR from 'swr';
import { Button } from '@/components/ui/button';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { toast } from 'sonner';
import { IconTrash, IconPencil, IconPlus, IconX } from '@tabler/icons-react';
import { CsvForm } from '@/components/ui/csv-form';

export { CsvManager };

interface CsvRow {
  [key: string]: string;
}

interface CsvTableProps {
  data: CsvRow[];
  onDeleteRow: (index: number) => Promise<void>;
  onEditClick: (row: CsvRow) => void;
  onAddClick: () => void;
  isDeleting: number | null;
}

const fetcher = async (url: string) => {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.text();
    const rows = data.split('\n').filter(row => row.trim() !== '').map(row => row.split(','));
    const headers = rows[0];
    return rows.slice(1).map(row => {
      const obj: CsvRow = {};
      headers.forEach((header, index) => {
        obj[header] = row[index] || '';
      });
      return obj;
    });
  } catch (error) {
    console.error('Fetcher error:', error);
    throw error;
  }
};

const CsvTable: React.FC<CsvTableProps> = React.memo(({
  data,
  onDeleteRow,
  onEditClick,
  onAddClick,
  isDeleting
}) => {
  const headers = data[0] ? Object.keys(data[0]) : [];

  return (
    <div className="w-full rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            {headers.map(header => (
              <TableHead key={header} className="px-4 py-2 whitespace-nowrap">{header}</TableHead>
            ))}
            <TableHead className="px-4 py-2 whitespace-nowrap">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((row, index) => (
            <TableRow key={index} className="hover:bg-gray-100 dark:hover:bg-neutral-800">
              {headers.map(header => (
                <TableCell key={header} className="px-4 py-2 whitespace-nowrap">
                  {row[header]}
                </TableCell>
              ))}
              <TableCell className="px-4 py-2 whitespace-nowrap">
                <div className="flex gap-2">
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8 text-blue-500 hover:text-blue-700 hover:bg-blue-100 dark:hover:bg-blue-900"
                    onClick={() => onEditClick(row)}
                  >
                    <IconPencil className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8 text-red-500 hover:text-red-700 hover:bg-red-100 dark:hover:bg-red-900"
                    onClick={() => onDeleteRow(index)}
                    disabled={isDeleting === index}
                  >
                    <IconTrash className="h-4 w-4" />
                  </Button>
                </div>
              </TableCell>
            </TableRow>
          ))}
          <TableRow className="hover:bg-gray-50 dark:hover:bg-neutral-800">
            <TableCell colSpan={headers.length + 1} className="px-4 py-2 text-center">
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8 text-green-500 hover:text-green-700 hover:bg-green-100 dark:hover:bg-green-900"
                onClick={onAddClick}
              >
                <IconPlus className="h-4 w-4" />
              </Button>
            </TableCell>
          </TableRow>
        </TableBody>
      </Table>
    </div>
  );
});

const formatCurrentTime = () => {
  const now = new Date();
  const time = now.toLocaleTimeString('en-GB');
  const date = now.toLocaleDateString('en-GB');
  return `${time} ${date}`;
};

interface CsvManagerProps {
  mode?: 'view' | 'add' | 'remove';
  onComplete?: () => void;
  onCancel?: () => void;
}

const CsvManager: React.FC<CsvManagerProps> = () => {
  const { data: csvData, error, mutate } = useSWR('/api/statistics/keab-training-data', fetcher);
  const [deletingRow, setDeletingRow] = useState<number | null>(null);
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [formMode, setFormMode] = useState<'add' | 'edit'>('add');
  const [editingData, setEditingData] = useState<CsvRow | undefined>();

  const handleClose = () => {
    window.history.back();
  };

  const handleAddClick = useCallback(() => {
    if (csvData && csvData.length > 0) {
      const headers = Object.keys(csvData[0]);
      const initialData = Object.fromEntries(headers.map(header => [header, '']));
      setEditingData(initialData);
      setFormMode('add');
      setIsFormOpen(true);
    }
  }, [csvData]);

  const handleEditClick = useCallback((row: CsvRow) => {
    setEditingData(row);
    setFormMode('edit');
    setIsFormOpen(true);
  }, []);

  const handleFormSubmit = async (formData: Record<string, string>) => {
    try {
      if (formMode === 'add') {
        const rowWithTime = {
          ...formData,
          Time: formatCurrentTime()
        };

        const response = await fetch('/api/statistics/add-csv-row', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(rowWithTime),
        });

        if (!response.ok) throw new Error(await response.text());
      } else {
        const response = await fetch('/api/statistics/edit-csv-row', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            index: csvData?.findIndex(row =>
              Object.entries(row).every(([key, value]) => editingData?.[key] === value)
            ),
            data: formData,
          }),
        });

        if (!response.ok) throw new Error(await response.text());
      }

      await mutate();
      setIsFormOpen(false);
      setEditingData(undefined);
      toast.success(formMode === 'add' ? 'Entry added successfully' : 'Entry updated successfully');
    } catch (error) {
      console.error('Error saving data:', error);
      toast.error(`Failed to ${formMode} entry`);
    }
  };

  const removeRow = async (index: number) => {
    setDeletingRow(index);
    try {
      const response = await fetch('/api/statistics/remove-csv-row', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ index: index + 1 }),
      });

      if (!response.ok) throw new Error(await response.text());

      await mutate();
      toast.success('Entry removed successfully');
    } catch (error) {
      console.error('Error removing row:', error);
      toast.error('Failed to remove entry');
    } finally {
      setDeletingRow(null);
    }
  };

  if (error) return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="text-red-500">Failed to load data</div>
    </div>
  );
  
  if (!csvData) return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="text-neutral-500">Loading...</div>
    </div>
  );

  return (
    <div className="fixed inset-0 z-50">
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black/40 backdrop-blur-sm" 
        onClick={handleClose}
      />
      
      {/* Modal Window */}
      <div className="relative z-10 min-h-screen flex items-center justify-center p-4">
        <div className="relative w-full max-w-5xl">
          {/* Background effects */}
          <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10 rounded-[22px] blur-xl" />
          <div className="absolute inset-0 bg-gradient-to-b from-white/80 to-white/50 dark:from-black/80 dark:to-black/50 rounded-[22px]" />
          
          {/* Content */}
          <div className="relative bg-white/80 dark:bg-black/80 backdrop-blur-sm rounded-[22px] shadow-2xl border border-white/20 dark:border-black/20">
            <div className="p-6">
              <div className="flex items-center justify-between mb-6">
                <h1 className="text-2xl font-bold text-neutral-800 dark:text-neutral-200">
                  Training Data Management
                </h1>
                <button
                  onClick={handleClose}
                  className="p-2 hover:bg-neutral-100 dark:hover:bg-neutral-800 rounded-full transition-colors"
                >
                  <IconX className="w-5 h-5 text-neutral-500" />
                </button>
              </div>
              
              <div className="bg-white dark:bg-black rounded-lg shadow-sm overflow-hidden">
                <CsvTable
                  data={csvData}
                  onDeleteRow={removeRow}
                  onEditClick={handleEditClick}
                  onAddClick={handleAddClick}
                  isDeleting={deletingRow}
                />
              </div>
            </div>
          </div>
        </div>
      </div>

      <CsvForm
        isOpen={isFormOpen}
        onClose={() => {
          setIsFormOpen(false);
          setEditingData(undefined);
        }}
        onSubmit={handleFormSubmit}
        initialData={editingData}
        mode={formMode}
      />
    </div>
  );
};

=== FILE: ./src/components/statistics/csv-statistics-page.tsx ===

"use client";
import React from "react";
import { BackgroundGradient } from "@/components/ui/background-gradient";
import { IconDatabase } from "@tabler/icons-react";
import { useRouter } from 'next/router';

export function CsvStatisticsPage() {
  const router = useRouter();

  return (
    <div className="min-h-screen w-full p-4 md:p-8 gap-4">
      <h1 className="text-2xl font-bold text-neutral-800 dark:text-neutral-200 mb-4">
        Statistics Dashboard
      </h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div 
          onClick={() => router.push('/statistics/csv')} 
          className="cursor-pointer"
        >
          <BackgroundGradient className="rounded-[22px] p-4 sm:p-10 bg-white dark:bg-zinc-900">
            <div className="flex flex-col items-center justify-center">
              <div className="p-4 bg-blue-500/10 dark:bg-blue-500/20 rounded-full">
                <IconDatabase className="w-8 h-8 text-blue-500" />
              </div>
              <h2 className="text-base sm:text-xl text-black mt-4 mb-2 dark:text-neutral-200 font-medium">
                Training Data Management
              </h2>
              <p className="text-sm text-neutral-600 dark:text-neutral-400 text-center">
                View and manage your AI training data records. Add, edit, or remove entries from your dataset.
              </p>
              <div className="mt-4 w-full">
                <button 
                  className="rounded-full w-full pl-4 pr-1 py-1 text-white flex items-center justify-center space-x-1 bg-black mt-4 text-xs font-bold dark:bg-zinc-800"
                  onClick={(e) => {
                    e.stopPropagation();
                    router.push('/statistics/csv');
                  }}
                >
                  <span>Open Manager</span>
                  <span className="bg-zinc-700 rounded-full px-2 py-0 text-white">→</span>
                </button>
              </div>
            </div>
          </BackgroundGradient>
        </div>
      </div>
    </div>
  );
}

=== FILE: ./src/pages/statistics.tsx ===

// src/pages/statistics
import { CsvStatisticsPage } from "@/components/statistics/CsvStatisticsPage";

export default function Statistics() {
  return <CsvStatisticsPage />;
}

=== FILE: ./src/pages/api/statistics/remove-csv-row.ts ===

// src/pages/api/statistics/remove-csv-row.ts
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/remove-csv-row`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(req.body),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(errorText);
    }

    const data = await response.json();
    res.status(200).json(data);
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to remove CSV row' });
  }
}

=== FILE: ./src/pages/api/statistics/csv-data.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import { API_URL } from '@/config'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const response = await fetch(`${API_URL}/api/keab-training-data`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.text();
    res.status(200).json({ data });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch CSV data' });
  }
}

=== FILE: ./src/pages/api/statistics/keab-training-data.ts ===

import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/keab-training-data`);
    const data = await response.text();
    
    if (!response.ok) {
      throw new Error(`Node server responded with status: ${response.status}`);
    }
    
    res.status(200).send(data);
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to fetch CSV data' });
  }
}

=== FILE: ./src/pages/api/statistics/add-csv-row.ts ===

// src/pages/api/statistics/add-csv-row.ts
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/add-csv-row`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    });
    
    if (!response.ok) {
      throw new Error(`Node server responded with status: ${response.status}`);
    }
    
    res.status(200).json({ success: true });
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to add CSV row' });
  }
}

=== FILE: ./src/pages/api/statistics/convert-docx.ts ===

import { NextApiRequest, NextApiResponse } from 'next'
import formidable from 'formidable'
import mammoth from 'mammoth'
import TurndownService from 'turndown'

export const config = {
  api: {
    bodyParser: false,
  },
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  const form = formidable()

  form.parse(req, async (err, fields, files) => {
    if (err) {
      console.error('Error parsing form:', err)
      return res.status(500).json({ error: 'Error processing file upload' })
    }

    const file = Array.isArray(files.file) ? files.file[0] : files.file
    if (!file) {
      return res.status(400).json({ error: 'No file uploaded' })
    }

    try {
      // Convert DOCX to HTML
      const result = await mammoth.convertToHtml({ path: file.filepath })
      const htmlContent = result.value

      // Configure Turndown service
      const turndownService = new TurndownService({
        headingStyle: 'atx',
        codeBlockStyle: 'fenced',
        bulletListMarker: '-',
        emDelimiter: '_'
      })

      // Add a custom rule to handle bold text and line breaks
      turndownService.addRule('handleBoldAndLineBreaks', {
        filter: ['strong', 'b', 'p'],
        replacement: function(content, node, options) {
          if (node.nodeName === 'P') {
            // For paragraphs, ensure there's no extra line break at the end
            return content.trim() + '\n\n'
          } else {
            // For bold text, ensure it's on the same line
            return options.strongDelimiter + content.trim() + options.strongDelimiter + ' '
          }
        }
      })

      // Convert HTML to Markdown
      let markdownContent = turndownService.turndown(htmlContent)

      // Post-processing to fix any remaining issues
      markdownContent = markdownContent
        .replace(/\*\*\n/g, '**') // Remove line breaks immediately after bold opening
        .replace(/\n\*\*/g, '**') // Remove line breaks immediately before bold closing
        .replace(/\n\n+/g, '\n\n') // Replace multiple consecutive line breaks with just two

      res.status(200).json({ 
        message: 'File converted successfully', 
        content: markdownContent
      })
    } catch (error) {
      console.error('Error converting file:', error)
      res.status(500).json({ error: 'Error converting file' })
    }
  })
}

=== FILE: ./src/pages/api/statistics/edit-csv-row.ts ===

// src/pages/api/statistics/edit-csv-row.ts
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const nodeServerUrl = process.env.NEXT_PUBLIC_SCRIPT_SERVER_URL;

  if (!nodeServerUrl) {
    return res.status(500).json({ error: 'Server URL not configured' });
  }

  try {
    const response = await fetch(`${nodeServerUrl}/api/statistics/edit-csv-row`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    });
    
    if (!response.ok) {
      throw new Error(`Node server responded with status: ${response.status}`);
    }
    
    res.status(200).json({ success: true });
  } catch (error) {
    console.error('API route error:', error);
    res.status(500).json({ error: 'Failed to edit CSV row' });
  }
}

=== FILE: ./src/pages/statistics/csv.tsx ===

import { CsvManager } from "@/components/statistics/csv-manager";

export default function CsvPage() {
  return <CsvManager />;
}

=== FILE: ./wiki_files.txt ===


=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import { createSearchIndex, searchDocuments } from '@/lib/search';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Document[]>([]);
  
  // Create search index whenever documents change
  const searchIndex = useMemo(() => createSearchIndex(documents), [documents]);

  const handleSearch = useCallback((query: string) => {
    if (query.trim()) {
      const results = searchDocuments(searchIndex, query);
      setSearchResults(results);
    } else {
      setSearchResults([]);
    }
  }, [searchIndex]);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  };
};
=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN
      );
    `);

    // Check if the category column exists, if not, add it
    const tableInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = tableInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }
  }
  return db;
}

export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.all('SELECT * FROM documents');
  } else {
    return db.all('SELECT * FROM documents WHERE restricted = 0');
  }
}

export async function getDocument(id: number, includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.get('SELECT * FROM documents WHERE id = ?', id);
  } else {
    return db.get('SELECT * FROM documents WHERE id = ? AND restricted = 0', id);
  }
}

export async function createDocument(title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('INSERT INTO documents (title, content, restricted, category) VALUES (?, ?, ?, ?)', title, content, restricted ? 1 : 0, category);
}

export async function updateDocument(id: number, title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('UPDATE documents SET title = ?, content = ?, restricted = ?, category = ? WHERE id = ?', title, content, restricted ? 1 : 0, category, id);
}

export async function toggleDocumentRestriction(id: number) {
  const db = await openDb();
  return db.run('UPDATE documents SET restricted = NOT restricted WHERE id = ?', id);
}

export async function getCategories() {
  const db = await openDb();
  return db.all('SELECT DISTINCT category FROM documents');
}

=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

// @/components/wiki/WikiHeader.tsx
// Manages the top navigation and controls
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";

interface WikiHeaderProps {
  isUnlocked: boolean;
  onUnlockToggle: (checked: boolean) => void;
  onAddDocument: () => void;
  onUploadDocument: () => void;
}

export const WikiHeader: React.FC<WikiHeaderProps> = ({
  isUnlocked,
  onUnlockToggle,
  onAddDocument,
  onUploadDocument
}) => (
  <div className="flex-shrink-0 p-4 bg-base-300 border-b">
    <div className="flex items-center justify-between">
      <h1 className="text-2xl font-bold">Wiki Documents</h1>
      <p className="text-[#D8DEE9]/80 mt-2">
        Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to open apps
      </p>
      <div className="flex items-center space-x-4">
        <Button onClick={onAddDocument}>Add New Page</Button>
        <Button variant="outline" onClick={onUploadDocument}>
          Upload Word Document
        </Button>
        <div className="flex items-center space-x-2">
          <Switch
            id="lock-mode"
            checked={isUnlocked}
            onCheckedChange={onUnlockToggle}
          />
          <Label htmlFor="lock-mode">
            {isUnlocked ? 'Unlocked' : 'Locked'}
          </Label>
        </div>
      </div>
    </div>
  </div>
);
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

// @/components/wiki/WikiDialogs.tsx
// Manages all modal/dialog interactions
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { cn } from "@/lib/utils";
import { motion, AnimatePresence } from 'framer-motion';

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchProps {
  onSearch: (value: string) => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  className?: string;
}

export default function WikiSearch({ onSearch, searchResults, onResultSelect, className }: WikiSearchProps) {
  const searchRef = useRef<HTMLInputElement>(null);
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState('');

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey) && e.code === 'Space') {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };

    const handleClickOutside = (e: MouseEvent) => {
      if (searchRef.current && !searchRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleClickOutside);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Function to highlight matched text
  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      // Add text before match
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      // Add highlighted match
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    // Add remaining text
    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  // Get focused context around matches
  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;  // Characters of context on each side
    const MAX_SNIPPETS = 3;   // Maximum number of snippets to show
    const MIN_GAP = 80;       // Minimum gap between snippets to show them separately

    // Sort indices by start position
    indices.sort((a, b) => a[0] - b[0]);

    let snippets: { text: string; indices: number[][] }[] = [];
    let currentSnippet = {
      start: 0,
      end: 0,
      indices: [[0, 0]],
    };

    indices.forEach((match, idx) => {
      const [start, end] = match;
      
      if (idx === 0) {
        currentSnippet = {
          start: Math.max(0, start - CONTEXT_SIZE),
          end: Math.min(content.length, end + CONTEXT_SIZE),
          indices: [match],
        };
      } else {
        // If this match is close to the previous one, extend the current snippet
        if (start - currentSnippet.end < MIN_GAP) {
          currentSnippet.end = Math.min(content.length, end + CONTEXT_SIZE);
          currentSnippet.indices.push(match);
        } else {
          // Add the current snippet and start a new one
          snippets.push({
            text: content.slice(currentSnippet.start, currentSnippet.end),
            indices: currentSnippet.indices.map(([s, e]) => [
              s - currentSnippet.start,
              e - currentSnippet.start,
            ]),
          });

          if (snippets.length >= MAX_SNIPPETS) return;

          currentSnippet = {
            start: Math.max(0, start - CONTEXT_SIZE),
            end: Math.min(content.length, end + CONTEXT_SIZE),
            indices: [match],
          };
        }
      }
    });

    // Add the last snippet if we haven't reached the maximum
    if (snippets.length < MAX_SNIPPETS) {
      snippets.push({
        text: content.slice(currentSnippet.start, currentSnippet.end),
        indices: currentSnippet.indices.map(([s, e]) => [
          s - currentSnippet.start,
          e - currentSnippet.start,
        ]),
      });
    }

    // Add ellipsis where needed
    return snippets.map((snippet, i) => ({
      text: (i > 0 ? '... ' : '') + snippet.text + (i < snippets.length - 1 ? ' ...' : ''),
      indices: snippet.indices.map(([s, e]) => [
        s + (i > 0 ? 4 : 0),
        e + (i > 0 ? 4 : 0),
      ]),
    }));
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setIsOpen(true);
  };

  return (
    <div className={cn("relative w-full", className)}>
      <Input
        ref={searchRef}
        type="text"
        value={inputValue}
        placeholder="Search documents... (Ctrl + Space)"
        onChange={handleInputChange}
        onFocus={() => setIsOpen(true)}
        className="pl-10"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && inputValue && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.slice(0, 10).map((result) => (
                <div
                  key={result.item.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    onResultSelect(result.item.id);
                    setIsOpen(false);
                    setInputValue('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">
                        {result.matches.find(m => m.key === 'title')
                          ? highlightMatches(
                              result.item.title,
                              result.matches.find(m => m.key === 'title')!.indices
                            )
                          : result.item.title}
                      </span>
                      <span className="text-xs text-muted-foreground">
                        {result.item.category}
                      </span>
                    </div>
                    {result.matches.find(m => m.key === 'content') && (
                      <div className="text-sm text-muted-foreground space-y-1">
                        {getMatchContext(
                          result.item.content,
                          result.matches.find(m => m.key === 'content')!.indices
                        ).map((snippet, i) => (
                          <div key={i} className="font-mono">
                            {highlightMatches(snippet.text, snippet.indices)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              ))}
              {searchResults.length > 10 && (
                <div className="p-2 text-center text-sm text-muted-foreground">
                  {searchResults.length - 10} more results...
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// @/components/wiki/WikiContent.tsx
// Handles document display and editing
import dynamic from 'next/dynamic';
import { Document } from '@/lib/types/wiki';
import WikiDocument from '@/components/wiki/WikiDocument';

const MarkdownEditor = dynamic(() => import('@/components/wiki/MarkdownEditor'), {
  ssr: false
});

interface WikiContentProps {
  selectedDocument: Document | null;
  isEditing: boolean;
  isUnlocked: boolean;
  onUpdateDocument: (id: number, title: string, content: string) => Promise<void>;
  setIsEditing: (value: boolean) => void;
}

export function WikiContent({
  selectedDocument,
  isEditing,
  isUnlocked,
  onUpdateDocument,
  setIsEditing
}: WikiContentProps) {
  if (!selectedDocument) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        Select a document to view its content
      </div>
    );
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <MarkdownEditor
          documentId={selectedDocument.id}
          initialTitle={selectedDocument.title}
          initialContent={selectedDocument.content}
          onSave={(title, content) => {
            onUpdateDocument(selectedDocument.id, title, content);
            setIsEditing(false);
          }}
          onCancel={() => setIsEditing(false)}
        />
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={onUpdateDocument}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React from 'react'
import MarkdownPreview from '@uiw/react-markdown-preview'
import '@uiw/react-markdown-preview/markdown.css';

interface WikiDocumentProps {
  document: {
    id: number
    title: string
    content: string
    restricted: boolean
    category: string
  }
  isUnlocked: boolean
  onDocumentUpdate: (id: number, content: string) => void
}

export default function WikiDocument({ document, isUnlocked, onDocumentUpdate }: WikiDocumentProps) {
  if (!document) {
    return <div>No document selected</div>
  }

  // Function to preprocess the Markdown content
  const preprocessMarkdown = (content: string) => {
    // Replace single line breaks with <br>, but preserve double line breaks
    return content.replace(/(?<!\n)\n(?!\n)/g, '  \n');
  };

  const processedContent = preprocessMarkdown(document.content);

  return (
    <div className="w-full h-full bg-background text-foreground">
      <h1 className="text-2xl font-bold mb-4">{document.title}</h1>
      <div className="prose dark:prose-invert max-w-none">
        <MarkdownPreview 
          source={processedContent} 
          style={{
            backgroundColor: 'var(--background)',
            color: 'var(--foreground)',
          }}
        />
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
// Handles the document tree display

import React, { useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { IconFileText, IconServer, IconDeviceDesktop, IconChevronDown, IconChevronRight, IconKey, IconEdit, IconTrash } from '@tabler/icons-react';

interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
}

interface WikiDocumentListProps {
  documents: Document[];
  onDocumentSelect: (id: number) => void;
  onEditDocument: (id: number) => void;
  onDeleteDocument: (id: number) => void;
  isUnlocked: boolean;
  onDocumentsChange: () => void;
  selectedDocumentId: number | null;
  canEditDocument: (document: Document) => boolean;
  expandedCategories: { [key: string]: boolean };
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

const categoryIcons: { [key: string]: React.ReactNode } = {
  "General": <IconFileText size={20} className="text-green transition-colors" />,
  "IT": <IconDeviceDesktop size={20} className="text-orange transition-colors" />,
  "Systems": <IconServer size={20} className="text-purple transition-colors" />,
};

export default function WikiDocumentList({
  documents,
  onDocumentSelect,
  onEditDocument,
  onDeleteDocument,
  isUnlocked,
  onDocumentsChange,
  selectedDocumentId,
  canEditDocument,
  expandedCategories,
  setExpandedCategories
}: WikiDocumentListProps) {
  const [isLoading, setIsLoading] = React.useState(true);
  const [isDeleting, setIsDeleting] = React.useState<number | null>(null);
  const [categories, setCategories] = React.useState<string[]>([]);

  useEffect(() => {
    const allCategories = [...new Set(documents.map(doc => doc.category))].sort();
    setCategories(allCategories);
    setIsLoading(false);
  }, [documents]);

  const toggleCategory = (category: string) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  };

  const handleDeleteDocument = async (id: number) => {
    if (isDeleting) return;
    setIsDeleting(id);
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        onDeleteDocument(id);
        onDocumentsChange();
      } else {
        console.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
    } finally {
      setIsDeleting(null);
    }
  };

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        <h2 className="text-xl font-bold mb-4">Categories</h2>
        {isLoading ? (
          <p>Loading categories...</p>
        ) : (
          <div className="space-y-2">
            {categories.map((category) => (
              <div key={category}>
                <Card
                  className="cursor-pointer"
                  onClick={() => toggleCategory(category)}
                >
                  <CardContent className="flex items-center justify-between p-2">
                    <div className="flex items-center">
                      {expandedCategories[category] ? <IconChevronDown size={20} /> : <IconChevronRight size={20} />}
                      <span className="font-medium ml-2">{category}</span>
                    </div>
                    <span>
                      {categoryIcons[category] || <IconFileText size={20} className="text-primary" />}
                    </span>
                  </CardContent>
                </Card>
                {expandedCategories[category] && (
                  <ul className="space-y-2 mt-2 ml-6">
                    {documents.filter(doc => doc.category === category).map((doc) => (
                      <li
                        key={doc.id}
                        className={`border rounded-md overflow-hidden shadow-sm ${
                          doc.restricted && !isUnlocked ? 'opacity-50' : ''
                        } ${selectedDocumentId === doc.id ? 'ring-2 ring-primary' : ''}`}
                      >
                        <div
                          className={`flex items-center justify-between p-2 ${
                            doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'
                          }`}
                          onClick={() => {
                            if (!(doc.restricted && !isUnlocked)) {
                              onDocumentSelect(doc.id);
                            }
                          }}
                        >
                          <span className={`${
                            doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'
                          }`}>
                            {doc.title}
                          </span>
                          <div className="flex items-center space-x-2">
                            {doc.restricted && (
                              <IconKey size={16} className="text-warning" />
                            )}
                            {canEditDocument(doc) && (
                              <>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    onEditDocument(doc.id);
                                  }}
                                >
                                  <IconEdit size={16} />
                                  <span className="sr-only">Edit</span>
                                </Button>
                                {isUnlocked && (
                                  <AlertDialog>
                                    <AlertDialogTrigger asChild>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={(e) => e.stopPropagation()}
                                      >
                                        <IconTrash size={16} />
                                        <span className="sr-only">Delete</span>
                                      </Button>
                                    </AlertDialogTrigger>
                                    <AlertDialogContent>
                                      <AlertDialogHeader>
                                        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                                        <AlertDialogDescription>
                                          This action cannot be undone. This will permanently delete the document
                                          "{doc.title}" and remove it from our servers.
                                        </AlertDialogDescription>
                                      </AlertDialogHeader>
                                      <AlertDialogFooter>
                                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                                        <AlertDialogAction 
                                          onClick={() => handleDeleteDocument(doc.id)} 
                                          disabled={isDeleting === doc.id}
                                        >
                                          {isDeleting === doc.id ? 'Deleting...' : 'Delete'}
                                        </AlertDialogAction>
                                      </AlertDialogFooter>
                                    </AlertDialogContent>
                                  </AlertDialog>
                                )}
                              </>
                            )}
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

// src/components/wiki/WikiSearchModal.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;

    e.stopPropagation(); // Prevent event bubbling

    switch (e.key) {
      case 'Tab':
        e.preventDefault();
        if (e.shiftKey) {
          setSelectedIndex(prev => 
            prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
          );
        } else {
          setSelectedIndex(prev => 
            (prev + 1) % Math.min(searchResults.length, 10)
          );
        }
        break;

      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        e.stopPropagation();
        onClose();
        break;
    }
  };

  // Add event listener for keyboard navigation
  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true); // Use capture phase
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  // Scroll selected item into view
  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  // Prevent event bubbling
  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <div className="container max-w-2xl mx-auto mt-[20vh]">
              <motion.div
                ref={modalRef}
                initial={{ scale: 0.95, opacity: 0 }}
                animate={{ scale: 1, opacity: 1 }}
                exit={{ scale: 0.95, opacity: 0 }}
                className="bg-background rounded-lg shadow-xl overflow-hidden"
                onClick={stopPropagation}
              >
                <div className="p-4 border-b">
                  <div className="relative">
                    <Input
                      ref={searchRef}
                      type="text"
                      value={inputValue}
                      onChange={handleInputChange}
                      placeholder="Search documents... (↑↓ to navigate)"
                      className="pl-10"
                      autoFocus
                    />
                    <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                  </div>
                </div>

                <div 
                  ref={resultsRef}
                  className="max-h-[60vh] overflow-y-auto"
                >
                  {searchResults.length === 0 && inputValue.trim() !== '' && (
                    <div className="p-4 text-center text-muted-foreground">
                      No results found
                    </div>
                  )}
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-3",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-2 mb-1">
                        <FileText className="w-4 h-4 text-muted-foreground" />
                        <span className="font-medium">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-xs text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-sm text-muted-foreground space-y-1">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="font-mono">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                  {searchResults.length > 10 && (
                    <div className="p-2 text-center text-sm text-muted-foreground">
                      {searchResults.length - 10} more results...
                    </div>
                  )}
                </div>

                <div className="p-3 border-t bg-muted/50">
                  <div className="flex gap-4 text-sm text-muted-foreground">
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">↑↓</kbd> to navigate
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">enter</kbd> to select
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">esc</kbd> to close
                    </span>
                  </div>
                </div>
              </motion.div>
            </div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useEffect, useCallback, useMemo } from 'react'
import dynamic from 'next/dynamic'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import 'easymde/dist/easymde.min.css'

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { ssr: false })

interface MarkdownEditorProps {
  documentId: number
  initialTitle: string
  initialContent: string
  onSave: (title: string, content: string) => void
  onCancel: () => void
}

export default function MarkdownEditor({ documentId, initialTitle, initialContent, onSave, onCancel }: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle)
  const [content, setContent] = useState(initialContent)

  useEffect(() => {
    setTitle(initialTitle)
    setContent(initialContent)
  }, [initialTitle, initialContent])

  const handleSave = useCallback(() => {
    onSave(title, content)
  }, [title, content, onSave])

  const handleTitleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value)
  }, [])

  const handleContentChange = useCallback((value: string) => {
    setContent(value)
  }, [])

  const editorOptions = useMemo(() => ({
    spellChecker: false,
    status: false,
    minHeight: '400px',
    autofocus: true,
    autosave: {
      enabled: true,
      uniqueId: `document-${documentId}`,
      delay: 1000,
    },
  }), [documentId])

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={handleTitleChange}
          placeholder="Document Title"
          className="text-xl font-bold mb-2"
        />
      </div>
      <SimpleMDE
        value={content}
        onChange={handleContentChange}
        options={editorOptions}
      />
      <div className="p-4 border-t flex justify-end space-x-2">
        <Button variant="outline" onClick={onCancel}>Cancel</Button>
        <Button onClick={handleSave}>Save</Button>
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/AddDocument.tsx ===

import React, { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"

interface AddDocumentProps {
  categories: string[]
  onCreateDocument: (title: string, category: string, restricted: boolean) => Promise<void>
  initialCategory?: string
  onClose?: () => void
}

export default function AddDocument({ categories, onCreateDocument, initialCategory = "", onClose }: AddDocumentProps) {
  const [title, setTitle] = useState("")
  const [category, setCategory] = useState(initialCategory)
  const [restricted, setRestricted] = useState(false)

  useEffect(() => {
    setCategory(initialCategory)
  }, [initialCategory])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    await onCreateDocument(title, category, restricted)
    setTitle("")
    setCategory("")
    setRestricted(false)
    if (onClose) onClose()
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>
      <div>
        <Label htmlFor="category">Category</Label>
        <Select value={category} onValueChange={setCategory} required>
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            {categories.map((cat) => (
              <SelectItem key={cat} value={cat}>
                {cat}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>
      <Button type="submit">Create Document</Button>
    </form>
  )
}

=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface PasswordPromptModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (password: string) => void
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(password)
    setPassword('')
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <Input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter password"
            className="mb-4"
          />
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query

  if (req.method === 'GET') {
    if (id) {
      const document = await prisma.document.findUnique({
        where: { id: parseInt(id as string) },
      })

      if (document) {
        res.status(200).json(document)
      } else {
        res.status(404).json({ error: 'Document not found' })
      }
    } else {
      const documents = await prisma.document.findMany({
        orderBy: { title: 'asc' },
      })
      res.status(200).json(documents)
    }
  } else if (req.method === 'POST') {
    const { title, content, restricted, category } = req.body

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.create({
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(201).json(document)
    } catch (error) {
      console.error('Error creating document:', error)
      res.status(500).json({ error: 'Error creating document' })
    }
  } else if (req.method === 'PUT') {
    const { title, content, restricted, category } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'PATCH') {
    const { restricted } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: { restricted },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'DELETE') {
    if (id) {
      try {
        await prisma.document.delete({
          where: { id: parseInt(id as string) },
        })
        res.status(200).json({ message: 'Document deleted successfully' })
      } catch (error) {
        console.error('Error deleting document:', error)
        res.status(404).json({ error: 'Document not found or could not be deleted' })
      }
    } else {
      res.status(400).json({ error: 'Document ID is required' })
    }
  } else {
    res.status(405).end() // Method Not Allowed
  }
}

=== FILE: ./src/pages/wiki.tsx ===

// @/pages/wiki.tsx
import { useState, useCallback } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';
import { useDocuments } from '@/lib/hooks/useDocuments';
import { useAuth } from '@/lib/hooks/useAuth';
import { useSearch } from '@/lib/hooks/useSearch';
import { Document } from '@/lib/types/wiki';

export default function WikiPage() {
  const {
    documents,
    categories,
    isLoading,
    createDocument,
    updateDocument,
    deleteDocument
  } = useDocuments();

  const {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  } = useAuth();

  const {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  } = useSearch(documents);

  const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState<{ [key: string]: boolean }>({});

  useHotkeys('ctrl+space', (e) => {
    e.preventDefault();
    setIsSearchOpen(true);
  }, []);

  const handleDocumentSelect = useCallback((id: number) => {
    const document = documents.find(doc => doc.id === id);
    if (document) {
      setSelectedDocument(document);
      setIsEditing(false);
    }
  }, [documents]);

  const canEditDocument = useCallback((document: Document) => {
    return isUnlocked || !document.restricted;
  }, [isUnlocked]);

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
              expandedCategories={expandedCategories}
              setExpandedCategories={setExpandedCategories}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={searchResults}
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={handleDocumentSelect}
        onSearch={handleSearch}
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={setSearchResults}
        setSelectedDocument={setSelectedDocument}
        setExpandedCategories={setExpandedCategories}
      />
    </div>
  );
}
=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./wiki_files.txt ===


=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285
=== FILE: ./server.js ===

const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const app = express();
app.use(cors());
app.use(express.json());
const CSV_PATH = process.env.CSV_PATH || '/app/completions.csv';

app.get('/api/statistics/keab-training-data', (req, res) => {
  console.log('Received request for CSV data');
  try {
    const csvData = fs.readFileSync(CSV_PATH, 'utf8');
    console.log('CSV data read successfully. First 100 chars:', csvData.substring(0, 100));
    res.send(csvData);
  } catch (error) {
    console.error('Error reading CSV file:', error);
    res.status(500).send('Error reading CSV file');
  }
});

app.post('/api/statistics/add-csv-row', (req, res) => {
  console.log('Received request to add CSV row:', req.body);
  const newRow = Object.values(req.body).join(',') + '\n';
  fs.appendFile(CSV_PATH, newRow, (err) => {
    if (err) {
      console.error('Error appending to file:', err);
      return res.status(500).json({ error: 'Error adding row to CSV' });
    }
    console.log('Row added successfully');
    res.status(200).json({ message: 'Row added successfully' });
  });
});

app.post('/api/statistics/remove-csv-row', (req, res) => {
  console.log('Received request to remove CSV row:', req.body);
  const { index } = req.body;
  fs.readFile(CSV_PATH, 'utf8', (err, data) => {
    if (err) {
      console.error('Error reading CSV file:', err);
      return res.status(500).json({ error: 'Error reading CSV file' });
    }
    const rows = data.split('\n');
    if (index < 1 || index >= rows.length) {
      console.error('Invalid row index:', index);
      return res.status(400).json({ error: 'Invalid row index' });
    }
    rows.splice(index, 1);
    const updatedCsv = rows.join('\n');
    fs.writeFile(CSV_PATH, updatedCsv, (err) => {
      if (err) {
        console.error('Error writing file:', err);
        return res.status(500).json({ error: 'Error updating CSV file' });
      }
      console.log('Row removed successfully');
      res.status(200).json({ message: 'Row removed successfully' });
    });
  });
});

app.post('/api/statistics/edit-csv-row', (req, res) => {
  console.log('Received request to edit CSV row:', req.body);
  const { index, data } = req.body;
  
  fs.readFile(CSV_PATH, 'utf8', (err, fileData) => {
    if (err) {
      console.error('Error reading CSV file:', err);
      return res.status(500).json({ error: 'Error reading CSV file' });
    }

    try {
      const rows = fileData.split('\n');
      const headers = rows[0].split(',');
      
      if (index < 0 || index >= rows.length - 1) {
        console.error('Invalid row index:', index);
        return res.status(400).json({ error: 'Invalid row index' });
      }

      const newRowArray = headers.map(header => {
        const value = data[header];
        return value !== undefined ? value : '';
      });
      const newRowString = newRowArray.join(',');
      
      rows[index + 1] = newRowString;
      const updatedCsv = rows.join('\n');
      
      fs.writeFile(CSV_PATH, updatedCsv, (writeErr) => {
        if (writeErr) {
          console.error('Error writing file:', writeErr);
          return res.status(500).json({ error: 'Error updating CSV file' });
        }
        console.log('Row edited successfully');
        res.status(200).json({ message: 'Row edited successfully' });
      });
    } catch (error) {
      console.error('Error processing CSV data:', error);
      res.status(500).json({ error: 'Error processing CSV data' });
    }
  });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Node server running at http://0.0.0.0:${PORT}`);
  console.log('CSV file path:', CSV_PATH);
});
=== FILE: ./hostapps_files.txt ===


=== FILE: ./src/components/hostapps/SftpUserCreationForm.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { AlertDialog, AlertDialogAction, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog"
import { Label } from "@/components/ui/label"

interface FormData {
  username: string
  firstName: string
  lastName: string
  userType: string
  department: string
  company: string
  responsibleFirstName: string
  responsibleLastName: string
  deletionTime: string
}

interface SftpUserCreationFormProps {
  onUserCreated: () => void
}

export default function SftpUserCreationForm({ onUserCreated }: SftpUserCreationFormProps) {
  const [formData, setFormData] = useState<FormData>({
    username: '',
    firstName: '',
    lastName: '',
    userType: '',
    department: '',
    company: '',
    responsibleFirstName: '',
    responsibleLastName: '',
    deletionTime: '',
  })

  const [message, setMessage] = useState<string>('')
  const [errorDetails, setErrorDetails] = useState<string>('')
  const [isAlertOpen, setIsAlertOpen] = useState<boolean>(false)
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [isError, setIsError] = useState<boolean>(false)

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setFormData(prevData => ({ ...prevData, [name]: value }))
  }

  const handleSelectChange = (name: string, value: string) => {
    setFormData(prevData => ({ ...prevData, [name]: value }))
  }

  const handleCreateUser = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setIsError(false)
    setErrorDetails('')

    const userData = {
      username: formData.username,
      user_info: {
        "First name": formData.firstName,
        "Last name": formData.lastName,
        "User Type": formData.userType,
        ...(formData.userType === 'internal' ? {
          "Department": formData.department,
          "Email": `${formData.firstName.toLowerCase()}.${formData.lastName.toLowerCase()}@karlshamnenergi.se`,
        } : {
          "Company": formData.company,
          "Handled by department": formData.department,
          "Responsible internally first name": formData.responsibleFirstName,
          "Responsible internally last name": formData.responsibleLastName,
          "Responsible internally email": `${formData.responsibleFirstName.toLowerCase()}.${formData.responsibleLastName.toLowerCase()}@karlshamnenergi.se`,
        }),
      },
      deletion_time: formData.deletionTime,
    }

    try {
      const response = await fetch('/api/hostapps/create_user', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.details || data.error || 'Failed to create user')
      }

      setMessage(data.message || 'User created successfully')
      setIsError(false)
      setIsAlertOpen(true)
      onUserCreated()

      // Clear form on success
      setFormData({
        username: '',
        firstName: '',
        lastName: '',
        userType: '',
        department: '',
        company: '',
        responsibleFirstName: '',
        responsibleLastName: '',
        deletionTime: '',
      })
    } catch (error) {
      console.error('Error creating user:', error)
      setIsError(true)
      setMessage('Failed to create user')
      setErrorDetails((error as Error).message)
      setIsAlertOpen(true)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleCreateUser} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="username">Username</Label>
        <Input
          id="username"
          name="username"
          value={formData.username}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="firstName">First Name</Label>
        <Input
          id="firstName"
          name="firstName"
          value={formData.firstName}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="lastName">Last Name</Label>
        <Input
          id="lastName"
          name="lastName"
          value={formData.lastName}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="userType">User Type</Label>
        <Select
          name="userType"
          value={formData.userType}
          onValueChange={(value) => handleSelectChange('userType', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select User Type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="internal">Internal</SelectItem>
            <SelectItem value="external">External</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label htmlFor="department">Department</Label>
        <Select
          name="department"
          value={formData.department}
          onValueChange={(value) => handleSelectChange('department', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select Department" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="Digit">Digit</SelectItem>
            <SelectItem value="El">El</SelectItem>
            <SelectItem value="Fjarrvarme">Fjarrvarme</SelectItem>
            <SelectItem value="Marknad">Marknad</SelectItem>
            <SelectItem value="Vatten">Vatten</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {formData.userType === 'external' && (
        <>
          <div className="space-y-2">
            <Label htmlFor="company">Company</Label>
            <Input
              id="company"
              name="company"
              value={formData.company}
              onChange={handleInputChange}
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="responsibleFirstName">Responsible First Name</Label>
            <Input
              id="responsibleFirstName"
              name="responsibleFirstName"
              value={formData.responsibleFirstName}
              onChange={handleInputChange}
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="responsibleLastName">Responsible Last Name</Label>
            <Input
              id="responsibleLastName"
              name="responsibleLastName"
              value={formData.responsibleLastName}
              onChange={handleInputChange}
              required
            />
          </div>
        </>
      )}

      <div className="space-y-2">
        <Label htmlFor="deletionTime">Deletion Time</Label>
        <Select
          name="deletionTime"
          value={formData.deletionTime}
          onValueChange={(value) => handleSelectChange('deletionTime', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select Deletion Time" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="0">No deletion</SelectItem>
            <SelectItem value="10">10 minutes</SelectItem>
            <SelectItem value="60">1 hour</SelectItem>
            <SelectItem value="1440">1 day</SelectItem>
            <SelectItem value="43200">30 days</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? 'Creating User...' : 'Create User'}
      </Button>

      <AlertDialog open={isAlertOpen} onOpenChange={setIsAlertOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{isError ? 'Error' : 'Success'}</AlertDialogTitle>
            <AlertDialogDescription>
              {message}
              {errorDetails && (
                <div className="mt-2 text-sm text-red-600">
                  Details: {errorDetails}
                </div>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogAction onClick={() => setIsAlertOpen(false)}>Okay</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </form>
  )
}

=== FILE: ./src/components/hostapps/PasswordPrompt.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Form, FormField, FormItem, FormControl } from "@/components/ui/form"
import { toast } from "sonner"

interface PasswordPromptProps {
  isOpen: boolean
  onPasswordSubmit: (password: string) => void
  onClose: () => void
}

const formSchema = z.object({
  password: z.string().min(1, "Password is required")
})

type FormValues = z.infer<typeof formSchema>

export function PasswordPrompt({ isOpen, onPasswordSubmit, onClose }: PasswordPromptProps) {
  const [isValidating, setIsValidating] = useState(false)
  
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      password: ""
    }
  })

  const onSubmit = async (values: FormValues) => {
    try {
      setIsValidating(true)

      const response = await fetch('/api/hostapps/handbrake?action=list_files', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          password: values.password 
        })
      });

      const data = await response.json();

      if (!response.ok) {
        if (response.status === 503 || response.status === 502) {
          throw new Error('Server is currently unavailable. Please try again later.');
        }
        throw new Error(data.error || data.details || 'Invalid password');
      }

      // If we got here, the password is valid
      onPasswordSubmit(values.password);
      form.reset();
    } catch (error) {
      console.error('Password validation error:', error);
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Failed to validate password. Please try again.';
      
      toast.error(errorMessage);
    } finally {
      setIsValidating(false);
    }
  }

  const handleClose = () => {
    form.reset();
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="password">Password</Label>
                  <FormControl>
                    <Input 
                      id="password"
                      type="password" 
                      placeholder="Enter SFTP password"
                      {...field}
                      autoComplete="off"
                      disabled={isValidating}
                    />
                  </FormControl>
                </FormItem>
              )}
            />
            <div className="flex gap-2 justify-end">
              <Button 
                type="button" 
                variant="outline" 
                onClick={handleClose}
                disabled={isValidating}
              >
                Cancel
              </Button>
              <Button 
                type="submit" 
                disabled={isValidating}
              >
                {isValidating ? "Validating..." : "Continue"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/hostapps/VideoProcessorCard.tsx ===

import React from 'react'
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
import { MultiStepLoader } from "@/components/ui/multi-step-loader"
import { cn } from "@/lib/utils"
import { Repeat } from "lucide-react"

interface ProcessingState {
  isProcessing: boolean
  currentStep: number
  progress: number
  steps: {
    title: string
    description: string
  }[]
}

interface VideoProcessorCardProps {
  onClick: () => void
  processingState: ProcessingState | null
}

export function VideoProcessorCard({ onClick, processingState }: VideoProcessorCardProps) {
  return (
    <Card 
      onClick={!processingState?.isProcessing ? onClick : undefined}
      className={cn(
        "relative group hover:shadow-md transition-all duration-300",
        !processingState?.isProcessing && "cursor-pointer hover:border-primary",
        processingState?.isProcessing && "border-primary"
      )}
    >
      {processingState?.isProcessing ? (
        <>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Repeat className="h-5 w-5 animate-pulse" />
              Processing Video
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <MultiStepLoader
                steps={processingState.steps}
                currentStep={processingState.currentStep}
              />
              <div className="space-y-2">
                <Progress 
                  value={processingState.progress} 
                  className="h-2"
                />
                <div className="flex justify-between text-sm text-muted-foreground">
                  <span>
                    {processingState.steps[processingState.currentStep].title}
                  </span>
                  <span>
                    {Math.round(processingState.progress)}%
                  </span>
                </div>
              </div>
            </div>
          </CardContent>
        </>
      ) : (
        <>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Repeat className="h-5 w-5 text-mprimary" />
              Video Processor
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Convert and process video files using HandBrake
            </p>
          </CardContent>
        </>
      )}
    </Card>
  )
}
=== FILE: ./src/components/hostapps/HandbrakeProcessorForm.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { toast } from "sonner"
import { Form, FormField, FormItem, FormControl } from "@/components/ui/form"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"

interface HandbrakeProcessorFormProps {
  password: string
  onProcessingStart: (file: File, preset: number) => void
  onCancel: () => void
  presets: Array<{ name: string; path: string | null }>
}

const formSchema = z.object({
  file: z.string().min(1, "Please select a file"),
  preset: z.string().min(1, "Please select a preset")
})

type FormValues = z.infer<typeof formSchema>

export function HandbrakeProcessorForm({ 
  password, 
  onProcessingStart,
  onCancel,
  presets 
}: HandbrakeProcessorFormProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null)

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      file: "",
      preset: "0"
    }
  })

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      const file = event.target.files[0]
      setSelectedFile(file)
      form.setValue('file', file.name)
    }
  }

  const onSubmit = async (values: FormValues) => {
    if (!selectedFile) {
      toast.error("Please select a file")
      return
    }
  
    try {
      const formData = new FormData()
      formData.append('file', selectedFile)
      formData.append('password', password)
  
      onProcessingStart(selectedFile, parseInt(values.preset))
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <div className="space-y-2">
          <Label>Select File</Label>
          <Input 
            type="file" 
            onChange={handleFileSelect}
          />
        </div>

        <FormField
          control={form.control}
          name="preset"
          render={({ field }) => (
            <FormItem>
              <Label>Select Preset</Label>
              <FormControl>
                <Select
                  value={field.value}
                  onValueChange={field.onChange}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Choose a preset" />
                  </SelectTrigger>
                  <SelectContent>
                    {presets.map((preset, index) => (
                      <SelectItem key={index} value={index.toString()}>
                        {preset.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </FormControl>
            </FormItem>
          )}
        />

        <div className="flex gap-2">
          <Button type="button" variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button type="submit">
            Start Processing
          </Button>
        </div>
      </form>
    </Form>
  )
}
=== FILE: ./src/components/hostapps/PasswordPromptDialog.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { usePasswordPromptStore } from '@/pages/hostapps/videoProcessor'

export function PasswordPromptDialog() {
  const [password, setPassword] = useState("")
  const { isOpen, setIsOpen, setPassword: storePassword, reset } = usePasswordPromptStore()

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    storePassword(password)
    setPassword("")
    setIsOpen(false)
  }

  const handleClose = () => {
    setPassword("")
    reset()
  }

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) handleClose()
    }}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
          <DialogDescription>
            Please provide your SFTP password to continue.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/pages/hostapps/videoProcessor.tsx ===

// @/pages/hostapps/videoProcessor.tsx
import React, { useState, useEffect } from 'react'
import { create } from "zustand"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { HandbrakeProcessorForm } from '@/components/hostapps/HandbrakeProcessorForm'
import { toast } from "sonner"

// Types
export type ProcessingStep = {
  title: string
  description: string
}

export type ProcessingState = {
  isProcessing: boolean
  currentStep: number
  progress: number
  steps: ProcessingStep[]
}

// Password Store
interface PasswordPromptStore {
  isOpen: boolean
  password: string
  setIsOpen: (isOpen: boolean) => void
  setPassword: (password: string) => void
  reset: () => void
}

export const usePasswordPromptStore = create<PasswordPromptStore>((set) => ({
  isOpen: false,
  password: "",
  setIsOpen: (isOpen) => set({ isOpen }),
  setPassword: (password) => set({ password }),
  reset: () => set({ isOpen: false, password: "" })
}))

// Video Processing Dialog Store
interface VideoProcessorStore {
  isOpen: boolean
  processingState: ProcessingState | null
  setIsOpen: (isOpen: boolean) => void
  setProcessingState: (state: ProcessingState | null) => void
}

export const useVideoProcessorStore = create<VideoProcessorStore>((set) => ({
  isOpen: false,
  processingState: null,
  setIsOpen: (isOpen) => set({ isOpen }),
  setProcessingState: (state) => set({ processingState: state })
}))

export const PROCESSING_STEPS: ProcessingStep[] = [
  {
    title: "Uploading File",
    description: "Transferring file to SFTP server..."
  },
  {
    title: "Preparing",
    description: "Setting up HandBrake processor..."
  },
  {
    title: "Converting",
    description: "Processing video with selected preset..."
  },
  {
    title: "Finalizing",
    description: "Cleaning up and verifying output..."
  }
]

// Core processing function
type ProcessVideoParams = {
  file: File
  presetIndex: number
  sftpPassword: string
  onProgressUpdate: (state: ProcessingState) => void
  onComplete: () => void
  onError: (error: string) => void
}

async function processVideo({
  file,
  presetIndex,
  sftpPassword,
  onProgressUpdate,
  onComplete,
  onError
}: ProcessVideoParams) {
  let uploadInterval: NodeJS.Timeout
  let processInterval: NodeJS.Timeout
  let finalizationInterval: NodeJS.Timeout

  try {
    onProgressUpdate({
      isProcessing: true,
      currentStep: 0,
      progress: 0,
      steps: PROCESSING_STEPS
    })

    const formData = new FormData()
    formData.append('file', file)
    formData.append('password', sftpPassword)

    uploadInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 1, 25)
      }))
    }, 100)

    const uploadResponse = await fetch('/api/hostapps/handbrake?action=upload_file', {
      method: 'POST',
      body: formData
    })

    clearInterval(uploadInterval)

    if (!uploadResponse.ok) {
      const data = await uploadResponse.json()
      throw new Error(data.error || data.details || 'Upload failed')
    }

    onProgressUpdate({
      isProcessing: true,
      currentStep: 1,
      progress: 25,
      steps: PROCESSING_STEPS
    })

    await new Promise(resolve => setTimeout(resolve, 1500))

    onProgressUpdate({
      isProcessing: true,
      currentStep: 2,
      progress: 30,
      steps: PROCESSING_STEPS
    })

    processInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 0.5, 90)
      }))
    }, 200)

    const processResponse = await fetch('/api/hostapps/handbrake?action=process_file', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        filename: file.name,
        preset_index: presetIndex,
        password: sftpPassword
      })
    })

    clearInterval(processInterval)

    if (!processResponse.ok) {
      throw new Error('Processing failed')
    }

    onProgressUpdate({
      isProcessing: true,
      currentStep: 3,
      progress: 95,
      steps: PROCESSING_STEPS
    })

    finalizationInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 1, 100)
      }))
    }, 100)

    await new Promise(resolve => setTimeout(resolve, 1000))
    clearInterval(finalizationInterval)
    
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    onComplete()

  } catch (error) {
    if (uploadInterval) clearInterval(uploadInterval)
    if (processInterval) clearInterval(processInterval)
    if (finalizationInterval) clearInterval(finalizationInterval)

    onError(error instanceof Error ? error.message : "Processing failed")
  }
}

// Password Prompt Component
export function PasswordPromptDialog() {
  const [password, setPassword] = useState("")
  const { isOpen, setIsOpen, setPassword: storePassword, reset } = usePasswordPromptStore()

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    storePassword(password)
    setPassword("")
    setIsOpen(false)
  }

  const handleClose = () => {
    setPassword("")
    reset()
  }

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) handleClose()
    }}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
          <DialogDescription>
            Please provide your SFTP password to continue.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

// Video Processor Dialog Component
export function VideoProcessorDialog() {
  const [presets, setPresets] = useState<Array<{ name: string; path: string | null }>>([])
  const { isOpen, setIsOpen, setProcessingState } = useVideoProcessorStore()

  useEffect(() => {
    if (isOpen) {
      fetchPresets()
    }
  }, [isOpen])

  const fetchPresets = async () => {
    try {
      const response = await fetch('/api/hostapps/handbrake?action=list_presets')
      const data = await response.json()
      if (data.presets) {
        setPresets(data.presets)
      }
    } catch (error) {
      toast.error("Failed to fetch presets")
    }
  }

  const handleProcessingStart = async (file: File, presetIndex: number) => {
    setIsOpen(false)
    
    try {
      await startVideoProcessing({
        file,
        presetIndex,
        onProgressUpdate: (state) => setProcessingState(state),
        onComplete: () => {
          toast.success("Video processing completed")
          setProcessingState(null)
        },
        onError: (error) => {
          toast.error(error)
          setProcessingState(null)
        }
      })
    } catch (error) {
      console.log("Processing was cancelled or failed")
    }
  }

  return (
    <Dialog 
      open={isOpen} 
      onOpenChange={(open) => {
        if (!open) {
          setIsOpen(false)
        }
      }}
    >
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Video Processor</DialogTitle>
          <DialogDescription>
            Select a video file and processing options to convert.
          </DialogDescription>
        </DialogHeader>
        <HandbrakeProcessorForm 
          presets={presets}
          onProcessingStart={handleProcessingStart}
          onCancel={() => setIsOpen(false)}
        />
      </DialogContent>
    </Dialog>
  )
}

// Helper function to open the video processor dialog
export function openVideoProcessor() {
  useVideoProcessorStore.getState().setIsOpen(true)
}

// Public interface for video processing
type StartVideoProcessingParams = {
  file: File
  presetIndex: number
  onProgressUpdate: (state: ProcessingState) => void
  onComplete: () => void
  onError: (error: string) => void
}

export function startVideoProcessing({
  file,
  presetIndex,
  onProgressUpdate,
  onComplete,
  onError
}: StartVideoProcessingParams): Promise<void> {
  return new Promise((resolve, reject) => {
    const passwordStore = usePasswordPromptStore.getState()
    passwordStore.setIsOpen(true)

    const cleanup = usePasswordPromptStore.subscribe((state) => {
      if (!state.isOpen && state.password) {
        cleanup()
        processVideo({
          file,
          presetIndex,
          sftpPassword: state.password,
          onProgressUpdate,
          onComplete: () => {
            passwordStore.reset()
            onComplete()
            resolve()
          },
          onError: (error) => {
            passwordStore.reset()
            onError(error)
            reject(error)
          }
        })
      } else if (!state.isOpen && !state.password) {
        cleanup()
        const error = "Password not provided"
        onError(error)
        reject(error)
      }
    })
  })
}
=== FILE: ./src/pages/hostapps.tsx ===

// src/pages/hostapps.tsx
import React, { useState } from 'react'
import { Card, CardHeader, CardContent, CardTitle } from "@/components/ui/card"
import SftpUserCreationForm from '@/components/hostapps/SftpUserCreationForm'
import { VideoProcessorCard } from '@/components/hostapps/VideoProcessorCard'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { UserPlus } from "lucide-react"
import { 
  openVideoProcessor, 
  VideoProcessorDialog, 
  PasswordPromptDialog, 
  useVideoProcessorStore 
} from '@/pages/hostapps/videoProcessor'

export default function HostApplications() {
  const [isSftpFormOpen, setIsSftpFormOpen] = useState(false)
  const processingState = useVideoProcessorStore((state) => state.processingState)

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Host Applications</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <Card
          onClick={() => setIsSftpFormOpen(true)}
          className="cursor-pointer hover:border-primary transition-all duration-300"
        >
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <UserPlus className="h-5 w-5" />
              Create SFTP User
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Click to create a new SFTP user
            </p>
          </CardContent>
        </Card>

        <VideoProcessorCard
          onClick={openVideoProcessor}
          processingState={processingState}
        />
      </div>

      <Dialog open={isSftpFormOpen} onOpenChange={setIsSftpFormOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Create SFTP User</DialogTitle>
            <DialogDescription>
              Fill in the details to create a new SFTP user.
            </DialogDescription>
          </DialogHeader>
          <SftpUserCreationForm onUserCreated={() => setIsSftpFormOpen(false)} />
        </DialogContent>
      </Dialog>

      <VideoProcessorDialog />
      <PasswordPromptDialog />
    </div>
  )
}
=== FILE: ./src/pages/api/hostapps/create_user.ts ===

// pages/api/create_user.ts
import type { NextApiRequest, NextApiResponse } from 'next'

const PYTHON_SERVER = process.env.NEXT_PUBLIC_SFTP_PYTHON_API_URL || 'http://172.20.96.22:5000'

interface UserInfo {
  'First name': string;
  'Last name': string;
  'User Type': string;
  Department: string;
  Email: string;
  'Responsible internally email'?: string;
}

interface UserData {
  username: string;
  user_info: UserInfo;
  deletion_time?: string;
}

async function getToken() {
  try {
    const response = await fetch(`${PYTHON_SERVER}/generate_token`)
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to get authentication token: ${error}`)
    }
    const data = await response.json()
    return data.access_token
  } catch (error) {
    console.error('Token generation error:', error)
    throw error
  }
}

function validateUserData(data: any): { isValid: boolean; error?: string } {
  if (!data) {
    return { isValid: false, error: 'No data provided' }
  }

  // Validate username
  if (!data.username || typeof data.username !== 'string') {
    return { isValid: false, error: 'Username is required and must be a string' }
  }

  if (!/^[a-z0-9-_]+$/.test(data.username)) {
    return { isValid: false, error: 'Username can only contain lowercase letters, numbers, hyphens, and underscores' }
  }

  // Validate user_info
  if (!data.user_info || typeof data.user_info !== 'object') {
    return { isValid: false, error: 'user_info is required and must be an object' }
  }

  const requiredFields = ['First name', 'Last name', 'User Type', 'Department', 'Email']
  for (const field of requiredFields) {
    if (!data.user_info[field] || typeof data.user_info[field] !== 'string') {
      return { isValid: false, error: `${field} is required in user_info and must be a string` }
    }
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(data.user_info.Email)) {
    return { isValid: false, error: 'Invalid email format' }
  }

  // Validate user type
  if (!['internal', 'external'].includes(data.user_info['User Type'].toLowerCase())) {
    return { isValid: false, error: 'User Type must be either "internal" or "external"' }
  }

  // Validate deletion_time if provided
  if (data.deletion_time !== undefined) {
    const deletion_time = parseInt(data.deletion_time)
    if (isNaN(deletion_time) || deletion_time < 0) {
      return { isValid: false, error: 'deletion_time must be a non-negative number or "0"' }
    }
  }

  return { isValid: true }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Security headers
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('X-Frame-Options', 'DENY')
  res.setHeader('X-XSS-Protection', '1; mode=block')

  // Method check
  if (req.method !== 'POST') {
    res.setHeader('Allow', ['POST'])
    return res.status(405).json({ error: 'Method not allowed' })
  }

  // Content-Type check
  if (!req.headers['content-type']?.includes('application/json')) {
    return res.status(400).json({ error: 'Content-Type must be application/json' })
  }

  try {
    const userData = req.body as UserData

    // Validate input data
    const validation = validateUserData(userData)
    if (!validation.isValid) {
      return res.status(400).json({ error: validation.error })
    }

    console.log('Attempting to get token...')
    const token = await getToken()
    console.log('Token received successfully')

    // Sanitize data before logging (remove password if present)
    const sanitizedData = { ...userData }
    if ('password' in sanitizedData) {
      delete (sanitizedData as any).password
    }
    console.log('Sending request to Python server with data:', sanitizedData)

    const response = await fetch(`${PYTHON_SERVER}/create_user`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(userData)
    })

    const data = await response.json()
    console.log('Python server response:', {
      ...data,
      // Remove sensitive data from logs
      details: data.details ? { ...data.details, password: undefined } : undefined
    })

    if (!response.ok) {
      return res.status(response.status).json({
        error: 'Python server error',
        details: data.error || data.message || 'Unknown error',
        pythonResponse: data
      })
    }

    // Success response
    res.status(200).json(data)

  } catch (error) {
    console.error('Error in create_user handler:', error)
    
    // Determine if error is network-related
    const isNetworkError = error instanceof Error && 
      (error.message.includes('fetch') || error.message.includes('network'))

    res.status(isNetworkError ? 503 : 500).json({ 
      error: isNetworkError ? 'Service temporarily unavailable' : 'Failed to create user',
      details: (error as Error).message,
      ...(process.env.NODE_ENV === 'development' && { stack: (error as Error).stack })
    })
  }
}

=== FILE: ./src/pages/api/hostapps/handbrake.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import formidable from 'formidable'
import fs from 'fs'
import path from 'path'

export const config = {
  api: {
    bodyParser: false,
  },
}

const PYTHON_SERVER = process.env.NEXT_PUBLIC_HANDBRAKE_PYTHON_API_URL || 'http://172.20.96.20:5000'

// Helper to parse JSON body
async function parseJsonBody(req: NextApiRequest) {
  const buffers = []
  for await (const chunk of req) {
    buffers.push(chunk)
  }
  const data = Buffer.concat(buffers).toString()
  try {
    return JSON.parse(data)
  } catch {
    return null
  }
}

async function getToken() {
  try {
    const response = await fetch(`${PYTHON_SERVER}/generate_token`, {
      signal: AbortSignal.timeout(5000)
    })
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to get authentication token: ${error}`)
    }
    const data = await response.json()
    return data.access_token
  } catch (error) {
    console.error('Token generation error:', error)
    if (error instanceof TypeError && error.message.includes('ECONNREFUSED')) {
      throw new Error('Unable to connect to Handbrake server. Please try again later.')
    }
    throw error
  }
}

const parseForm = async (req: NextApiRequest) => {
  const form = formidable({
    maxFileSize: 10 * 1024 * 1024 * 1024, // 10GB
    maxTotalFileSize: 10 * 1024 * 1024 * 1024, // 10GB
    allowEmptyFiles: false,
    multiples: false,
  });

  return new Promise<{ fields: formidable.Fields; files: formidable.Files }>((resolve, reject) => {
    form.parse(req, (err, fields, files) => {
      if (err) reject(err);
      resolve({ fields, files });
    });
  });
};

async function streamToBuffer(stream: fs.ReadStream): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
    stream.on('error', (err) => reject(err));
    stream.on('end', () => resolve(Buffer.concat(chunks)));
  });
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('X-Frame-Options', 'DENY')
  res.setHeader('X-XSS-Protection', '1; mode=block')

  try {
    const token = await getToken()
    console.log('Action:', req.query.action)

    switch (req.query.action) {
      case 'upload_file': {
        if (req.method !== 'POST') {
          return res.status(405).json({ error: 'Method not allowed for this action' })
        }

        try {
          const { fields, files } = await parseForm(req);
          console.log('Form data:', { fields, files });

          const fileArray = Array.isArray(files.file) ? files.file : [files.file];
          const file = fileArray[0];
          const password = fields.password as string;

          if (!password) {
            return res.status(400).json({ error: "Password is required" });
          }

          if (!file || !file.filepath) {
            console.error('No file or filepath:', file);
            return res.status(400).json({ error: "No file provided" });
          }

          console.log('Uploading file:', file.originalFilename, 'from path:', file.filepath);

          // Read file content
          const fileBuffer = await fs.promises.readFile(file.filepath);

          // Create form data for upload
          const formData = new FormData();
          formData.append('file', new Blob([fileBuffer]), file.originalFilename || 'unnamed_file');
          formData.append('password', password);

          const uploadResponse = await fetch(`${PYTHON_SERVER}/upload_file`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`
            },
            body: formData
          });

          let data;
          try {
            data = await uploadResponse.json();
          } catch (e) {
            console.error('Failed to parse upload response:', e);
            return res.status(500).json({
              error: 'Upload failed',
              details: 'Invalid server response'
            });
          }

          // Clean up temp file
          try {
            await fs.promises.unlink(file.filepath);
          } catch (e) {
            console.error('Failed to cleanup temp file:', e);
          }

          if (!uploadResponse.ok) {
            console.error('Upload failed:', data);
            return res.status(uploadResponse.status).json(data);
          }

          return res.status(200).json(data);
        } catch (error) {
          console.error('File handling error:', error);
          return res.status(500).json({ 
            error: 'Upload failed', 
            details: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      }

      case 'list_files': {
        const body = await parseJsonBody(req)
        if (!body?.password) {
          return res.status(400).json({ error: "Password is required" });
        }

        const response = await fetch(`${PYTHON_SERVER}/list_files`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            password: body.password
          })
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse list_files response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      case 'list_presets': {
        const response = await fetch(`${PYTHON_SERVER}/list_presets`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse list_presets response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      case 'process_file': {
        const body = await parseJsonBody(req)
        if (!body) {
          return res.status(400).json({ error: "Invalid request body" });
        }

        const response = await fetch(`${PYTHON_SERVER}/process_file`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse process_file response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      default:
        return res.status(400).json({ error: 'Invalid action' });
    }
  } catch (error) {
    console.error('Error in handbrake handler:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('ECONNREFUSED') || error.message.includes('Unable to connect')) {
        return res.status(503).json({
          error: 'Service temporarily unavailable',
          details: 'Unable to connect to Handbrake server. Please try again later.'
        });
      }
      
      if (error.message.includes('timeout')) {
        return res.status(504).json({
          error: 'Service timeout',
          details: 'Request timed out. Please try again.'
        });
      }
    }

    return res.status(500).json({
      error: 'Failed to process request',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
=== FILE: ./wiki_files.txt ===


=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import { createSearchIndex, searchDocuments } from '@/lib/search';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Document[]>([]);
  
  // Create search index whenever documents change
  const searchIndex = useMemo(() => createSearchIndex(documents), [documents]);

  const handleSearch = useCallback((query: string) => {
    if (query.trim()) {
      const results = searchDocuments(searchIndex, query);
      setSearchResults(results);
    } else {
      setSearchResults([]);
    }
  }, [searchIndex]);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  };
};
=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN
      );
    `);

    // Check if the category column exists, if not, add it
    const tableInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = tableInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }
  }
  return db;
}

export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.all('SELECT * FROM documents');
  } else {
    return db.all('SELECT * FROM documents WHERE restricted = 0');
  }
}

export async function getDocument(id: number, includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.get('SELECT * FROM documents WHERE id = ?', id);
  } else {
    return db.get('SELECT * FROM documents WHERE id = ? AND restricted = 0', id);
  }
}

export async function createDocument(title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('INSERT INTO documents (title, content, restricted, category) VALUES (?, ?, ?, ?)', title, content, restricted ? 1 : 0, category);
}

export async function updateDocument(id: number, title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('UPDATE documents SET title = ?, content = ?, restricted = ?, category = ? WHERE id = ?', title, content, restricted ? 1 : 0, category, id);
}

export async function toggleDocumentRestriction(id: number) {
  const db = await openDb();
  return db.run('UPDATE documents SET restricted = NOT restricted WHERE id = ?', id);
}

export async function getCategories() {
  const db = await openDb();
  return db.all('SELECT DISTINCT category FROM documents');
}

=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

// @/components/wiki/WikiHeader.tsx
// Manages the top navigation and controls
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";

interface WikiHeaderProps {
  isUnlocked: boolean;
  onUnlockToggle: (checked: boolean) => void;
  onAddDocument: () => void;
  onUploadDocument: () => void;
}

export const WikiHeader: React.FC<WikiHeaderProps> = ({
  isUnlocked,
  onUnlockToggle,
  onAddDocument,
  onUploadDocument
}) => (
  <div className="flex-shrink-0 p-4 bg-base-300 border-b">
    <div className="flex items-center justify-between">
      <h1 className="text-2xl font-bold">Wiki Documents</h1>
      <p className="text-[#D8DEE9]/80 mt-2">
        Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to open apps
      </p>
      <div className="flex items-center space-x-4">
        <Button onClick={onAddDocument}>Add New Page</Button>
        <Button variant="outline" onClick={onUploadDocument}>
          Upload Word Document
        </Button>
        <div className="flex items-center space-x-2">
          <Switch
            id="lock-mode"
            checked={isUnlocked}
            onCheckedChange={onUnlockToggle}
          />
          <Label htmlFor="lock-mode">
            {isUnlocked ? 'Unlocked' : 'Locked'}
          </Label>
        </div>
      </div>
    </div>
  </div>
);
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

// @/components/wiki/WikiDialogs.tsx
// Manages all modal/dialog interactions
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { cn } from "@/lib/utils";
import { motion, AnimatePresence } from 'framer-motion';

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchProps {
  onSearch: (value: string) => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  className?: string;
}

export default function WikiSearch({ onSearch, searchResults, onResultSelect, className }: WikiSearchProps) {
  const searchRef = useRef<HTMLInputElement>(null);
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState('');

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey) && e.code === 'Space') {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };

    const handleClickOutside = (e: MouseEvent) => {
      if (searchRef.current && !searchRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleClickOutside);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Function to highlight matched text
  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      // Add text before match
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      // Add highlighted match
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    // Add remaining text
    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  // Get focused context around matches
  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;  // Characters of context on each side
    const MAX_SNIPPETS = 3;   // Maximum number of snippets to show
    const MIN_GAP = 80;       // Minimum gap between snippets to show them separately

    // Sort indices by start position
    indices.sort((a, b) => a[0] - b[0]);

    let snippets: { text: string; indices: number[][] }[] = [];
    let currentSnippet = {
      start: 0,
      end: 0,
      indices: [[0, 0]],
    };

    indices.forEach((match, idx) => {
      const [start, end] = match;
      
      if (idx === 0) {
        currentSnippet = {
          start: Math.max(0, start - CONTEXT_SIZE),
          end: Math.min(content.length, end + CONTEXT_SIZE),
          indices: [match],
        };
      } else {
        // If this match is close to the previous one, extend the current snippet
        if (start - currentSnippet.end < MIN_GAP) {
          currentSnippet.end = Math.min(content.length, end + CONTEXT_SIZE);
          currentSnippet.indices.push(match);
        } else {
          // Add the current snippet and start a new one
          snippets.push({
            text: content.slice(currentSnippet.start, currentSnippet.end),
            indices: currentSnippet.indices.map(([s, e]) => [
              s - currentSnippet.start,
              e - currentSnippet.start,
            ]),
          });

          if (snippets.length >= MAX_SNIPPETS) return;

          currentSnippet = {
            start: Math.max(0, start - CONTEXT_SIZE),
            end: Math.min(content.length, end + CONTEXT_SIZE),
            indices: [match],
          };
        }
      }
    });

    // Add the last snippet if we haven't reached the maximum
    if (snippets.length < MAX_SNIPPETS) {
      snippets.push({
        text: content.slice(currentSnippet.start, currentSnippet.end),
        indices: currentSnippet.indices.map(([s, e]) => [
          s - currentSnippet.start,
          e - currentSnippet.start,
        ]),
      });
    }

    // Add ellipsis where needed
    return snippets.map((snippet, i) => ({
      text: (i > 0 ? '... ' : '') + snippet.text + (i < snippets.length - 1 ? ' ...' : ''),
      indices: snippet.indices.map(([s, e]) => [
        s + (i > 0 ? 4 : 0),
        e + (i > 0 ? 4 : 0),
      ]),
    }));
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setIsOpen(true);
  };

  return (
    <div className={cn("relative w-full", className)}>
      <Input
        ref={searchRef}
        type="text"
        value={inputValue}
        placeholder="Search documents... (Ctrl + Space)"
        onChange={handleInputChange}
        onFocus={() => setIsOpen(true)}
        className="pl-10"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && inputValue && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.slice(0, 10).map((result) => (
                <div
                  key={result.item.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    onResultSelect(result.item.id);
                    setIsOpen(false);
                    setInputValue('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">
                        {result.matches.find(m => m.key === 'title')
                          ? highlightMatches(
                              result.item.title,
                              result.matches.find(m => m.key === 'title')!.indices
                            )
                          : result.item.title}
                      </span>
                      <span className="text-xs text-muted-foreground">
                        {result.item.category}
                      </span>
                    </div>
                    {result.matches.find(m => m.key === 'content') && (
                      <div className="text-sm text-muted-foreground space-y-1">
                        {getMatchContext(
                          result.item.content,
                          result.matches.find(m => m.key === 'content')!.indices
                        ).map((snippet, i) => (
                          <div key={i} className="font-mono">
                            {highlightMatches(snippet.text, snippet.indices)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              ))}
              {searchResults.length > 10 && (
                <div className="p-2 text-center text-sm text-muted-foreground">
                  {searchResults.length - 10} more results...
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// @/components/wiki/WikiContent.tsx
// Handles document display and editing
import dynamic from 'next/dynamic';
import { Document } from '@/lib/types/wiki';
import WikiDocument from '@/components/wiki/WikiDocument';

const MarkdownEditor = dynamic(() => import('@/components/wiki/MarkdownEditor'), {
  ssr: false
});

interface WikiContentProps {
  selectedDocument: Document | null;
  isEditing: boolean;
  isUnlocked: boolean;
  onUpdateDocument: (id: number, title: string, content: string) => Promise<void>;
  setIsEditing: (value: boolean) => void;
}

export function WikiContent({
  selectedDocument,
  isEditing,
  isUnlocked,
  onUpdateDocument,
  setIsEditing
}: WikiContentProps) {
  if (!selectedDocument) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        Select a document to view its content
      </div>
    );
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <MarkdownEditor
          documentId={selectedDocument.id}
          initialTitle={selectedDocument.title}
          initialContent={selectedDocument.content}
          onSave={(title, content) => {
            onUpdateDocument(selectedDocument.id, title, content);
            setIsEditing(false);
          }}
          onCancel={() => setIsEditing(false)}
        />
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={onUpdateDocument}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React from 'react'
import MarkdownPreview from '@uiw/react-markdown-preview'
import '@uiw/react-markdown-preview/markdown.css';

interface WikiDocumentProps {
  document: {
    id: number
    title: string
    content: string
    restricted: boolean
    category: string
  }
  isUnlocked: boolean
  onDocumentUpdate: (id: number, content: string) => void
}

export default function WikiDocument({ document, isUnlocked, onDocumentUpdate }: WikiDocumentProps) {
  if (!document) {
    return <div>No document selected</div>
  }

  // Function to preprocess the Markdown content
  const preprocessMarkdown = (content: string) => {
    // Replace single line breaks with <br>, but preserve double line breaks
    return content.replace(/(?<!\n)\n(?!\n)/g, '  \n');
  };

  const processedContent = preprocessMarkdown(document.content);

  return (
    <div className="w-full h-full bg-background text-foreground">
      <h1 className="text-2xl font-bold mb-4">{document.title}</h1>
      <div className="prose dark:prose-invert max-w-none">
        <MarkdownPreview 
          source={processedContent} 
          style={{
            backgroundColor: 'var(--background)',
            color: 'var(--foreground)',
          }}
        />
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
// Handles the document tree display

import React, { useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { IconFileText, IconServer, IconDeviceDesktop, IconChevronDown, IconChevronRight, IconKey, IconEdit, IconTrash } from '@tabler/icons-react';

interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
}

interface WikiDocumentListProps {
  documents: Document[];
  onDocumentSelect: (id: number) => void;
  onEditDocument: (id: number) => void;
  onDeleteDocument: (id: number) => void;
  isUnlocked: boolean;
  onDocumentsChange: () => void;
  selectedDocumentId: number | null;
  canEditDocument: (document: Document) => boolean;
  expandedCategories: { [key: string]: boolean };
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

const categoryIcons: { [key: string]: React.ReactNode } = {
  "General": <IconFileText size={20} className="text-green transition-colors" />,
  "IT": <IconDeviceDesktop size={20} className="text-orange transition-colors" />,
  "Systems": <IconServer size={20} className="text-purple transition-colors" />,
};

export default function WikiDocumentList({
  documents,
  onDocumentSelect,
  onEditDocument,
  onDeleteDocument,
  isUnlocked,
  onDocumentsChange,
  selectedDocumentId,
  canEditDocument,
  expandedCategories,
  setExpandedCategories
}: WikiDocumentListProps) {
  const [isLoading, setIsLoading] = React.useState(true);
  const [isDeleting, setIsDeleting] = React.useState<number | null>(null);
  const [categories, setCategories] = React.useState<string[]>([]);

  useEffect(() => {
    const allCategories = [...new Set(documents.map(doc => doc.category))].sort();
    setCategories(allCategories);
    setIsLoading(false);
  }, [documents]);

  const toggleCategory = (category: string) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  };

  const handleDeleteDocument = async (id: number) => {
    if (isDeleting) return;
    setIsDeleting(id);
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        onDeleteDocument(id);
        onDocumentsChange();
      } else {
        console.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
    } finally {
      setIsDeleting(null);
    }
  };

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        <h2 className="text-xl font-bold mb-4">Categories</h2>
        {isLoading ? (
          <p>Loading categories...</p>
        ) : (
          <div className="space-y-2">
            {categories.map((category) => (
              <div key={category}>
                <Card
                  className="cursor-pointer"
                  onClick={() => toggleCategory(category)}
                >
                  <CardContent className="flex items-center justify-between p-2">
                    <div className="flex items-center">
                      {expandedCategories[category] ? <IconChevronDown size={20} /> : <IconChevronRight size={20} />}
                      <span className="font-medium ml-2">{category}</span>
                    </div>
                    <span>
                      {categoryIcons[category] || <IconFileText size={20} className="text-primary" />}
                    </span>
                  </CardContent>
                </Card>
                {expandedCategories[category] && (
                  <ul className="space-y-2 mt-2 ml-6">
                    {documents.filter(doc => doc.category === category).map((doc) => (
                      <li
                        key={doc.id}
                        className={`border rounded-md overflow-hidden shadow-sm ${
                          doc.restricted && !isUnlocked ? 'opacity-50' : ''
                        } ${selectedDocumentId === doc.id ? 'ring-2 ring-primary' : ''}`}
                      >
                        <div
                          className={`flex items-center justify-between p-2 ${
                            doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'
                          }`}
                          onClick={() => {
                            if (!(doc.restricted && !isUnlocked)) {
                              onDocumentSelect(doc.id);
                            }
                          }}
                        >
                          <span className={`${
                            doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'
                          }`}>
                            {doc.title}
                          </span>
                          <div className="flex items-center space-x-2">
                            {doc.restricted && (
                              <IconKey size={16} className="text-warning" />
                            )}
                            {canEditDocument(doc) && (
                              <>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    onEditDocument(doc.id);
                                  }}
                                >
                                  <IconEdit size={16} />
                                  <span className="sr-only">Edit</span>
                                </Button>
                                {isUnlocked && (
                                  <AlertDialog>
                                    <AlertDialogTrigger asChild>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={(e) => e.stopPropagation()}
                                      >
                                        <IconTrash size={16} />
                                        <span className="sr-only">Delete</span>
                                      </Button>
                                    </AlertDialogTrigger>
                                    <AlertDialogContent>
                                      <AlertDialogHeader>
                                        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                                        <AlertDialogDescription>
                                          This action cannot be undone. This will permanently delete the document
                                          "{doc.title}" and remove it from our servers.
                                        </AlertDialogDescription>
                                      </AlertDialogHeader>
                                      <AlertDialogFooter>
                                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                                        <AlertDialogAction 
                                          onClick={() => handleDeleteDocument(doc.id)} 
                                          disabled={isDeleting === doc.id}
                                        >
                                          {isDeleting === doc.id ? 'Deleting...' : 'Delete'}
                                        </AlertDialogAction>
                                      </AlertDialogFooter>
                                    </AlertDialogContent>
                                  </AlertDialog>
                                )}
                              </>
                            )}
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

// src/components/wiki/WikiSearchModal.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;

    e.stopPropagation(); // Prevent event bubbling

    switch (e.key) {
      case 'Tab':
        e.preventDefault();
        if (e.shiftKey) {
          setSelectedIndex(prev => 
            prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
          );
        } else {
          setSelectedIndex(prev => 
            (prev + 1) % Math.min(searchResults.length, 10)
          );
        }
        break;

      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        e.stopPropagation();
        onClose();
        break;
    }
  };

  // Add event listener for keyboard navigation
  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true); // Use capture phase
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  // Scroll selected item into view
  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  // Prevent event bubbling
  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <div className="container max-w-2xl mx-auto mt-[20vh]">
              <motion.div
                ref={modalRef}
                initial={{ scale: 0.95, opacity: 0 }}
                animate={{ scale: 1, opacity: 1 }}
                exit={{ scale: 0.95, opacity: 0 }}
                className="bg-background rounded-lg shadow-xl overflow-hidden"
                onClick={stopPropagation}
              >
                <div className="p-4 border-b">
                  <div className="relative">
                    <Input
                      ref={searchRef}
                      type="text"
                      value={inputValue}
                      onChange={handleInputChange}
                      placeholder="Search documents... (↑↓ to navigate)"
                      className="pl-10"
                      autoFocus
                    />
                    <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                  </div>
                </div>

                <div 
                  ref={resultsRef}
                  className="max-h-[60vh] overflow-y-auto"
                >
                  {searchResults.length === 0 && inputValue.trim() !== '' && (
                    <div className="p-4 text-center text-muted-foreground">
                      No results found
                    </div>
                  )}
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-3",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-2 mb-1">
                        <FileText className="w-4 h-4 text-muted-foreground" />
                        <span className="font-medium">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-xs text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-sm text-muted-foreground space-y-1">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="font-mono">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                  {searchResults.length > 10 && (
                    <div className="p-2 text-center text-sm text-muted-foreground">
                      {searchResults.length - 10} more results...
                    </div>
                  )}
                </div>

                <div className="p-3 border-t bg-muted/50">
                  <div className="flex gap-4 text-sm text-muted-foreground">
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">↑↓</kbd> to navigate
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">enter</kbd> to select
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">esc</kbd> to close
                    </span>
                  </div>
                </div>
              </motion.div>
            </div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useEffect, useCallback, useMemo } from 'react'
import dynamic from 'next/dynamic'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import 'easymde/dist/easymde.min.css'

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { ssr: false })

interface MarkdownEditorProps {
  documentId: number
  initialTitle: string
  initialContent: string
  onSave: (title: string, content: string) => void
  onCancel: () => void
}

export default function MarkdownEditor({ documentId, initialTitle, initialContent, onSave, onCancel }: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle)
  const [content, setContent] = useState(initialContent)

  useEffect(() => {
    setTitle(initialTitle)
    setContent(initialContent)
  }, [initialTitle, initialContent])

  const handleSave = useCallback(() => {
    onSave(title, content)
  }, [title, content, onSave])

  const handleTitleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value)
  }, [])

  const handleContentChange = useCallback((value: string) => {
    setContent(value)
  }, [])

  const editorOptions = useMemo(() => ({
    spellChecker: false,
    status: false,
    minHeight: '400px',
    autofocus: true,
    autosave: {
      enabled: true,
      uniqueId: `document-${documentId}`,
      delay: 1000,
    },
  }), [documentId])

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={handleTitleChange}
          placeholder="Document Title"
          className="text-xl font-bold mb-2"
        />
      </div>
      <SimpleMDE
        value={content}
        onChange={handleContentChange}
        options={editorOptions}
      />
      <div className="p-4 border-t flex justify-end space-x-2">
        <Button variant="outline" onClick={onCancel}>Cancel</Button>
        <Button onClick={handleSave}>Save</Button>
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/AddDocument.tsx ===

import React, { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"

interface AddDocumentProps {
  categories: string[]
  onCreateDocument: (title: string, category: string, restricted: boolean) => Promise<void>
  initialCategory?: string
  onClose?: () => void
}

export default function AddDocument({ categories, onCreateDocument, initialCategory = "", onClose }: AddDocumentProps) {
  const [title, setTitle] = useState("")
  const [category, setCategory] = useState(initialCategory)
  const [restricted, setRestricted] = useState(false)

  useEffect(() => {
    setCategory(initialCategory)
  }, [initialCategory])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    await onCreateDocument(title, category, restricted)
    setTitle("")
    setCategory("")
    setRestricted(false)
    if (onClose) onClose()
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>
      <div>
        <Label htmlFor="category">Category</Label>
        <Select value={category} onValueChange={setCategory} required>
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            {categories.map((cat) => (
              <SelectItem key={cat} value={cat}>
                {cat}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>
      <Button type="submit">Create Document</Button>
    </form>
  )
}

=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface PasswordPromptModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (password: string) => void
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(password)
    setPassword('')
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <Input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter password"
            className="mb-4"
          />
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query

  if (req.method === 'GET') {
    if (id) {
      const document = await prisma.document.findUnique({
        where: { id: parseInt(id as string) },
      })

      if (document) {
        res.status(200).json(document)
      } else {
        res.status(404).json({ error: 'Document not found' })
      }
    } else {
      const documents = await prisma.document.findMany({
        orderBy: { title: 'asc' },
      })
      res.status(200).json(documents)
    }
  } else if (req.method === 'POST') {
    const { title, content, restricted, category } = req.body

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.create({
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(201).json(document)
    } catch (error) {
      console.error('Error creating document:', error)
      res.status(500).json({ error: 'Error creating document' })
    }
  } else if (req.method === 'PUT') {
    const { title, content, restricted, category } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'PATCH') {
    const { restricted } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: { restricted },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'DELETE') {
    if (id) {
      try {
        await prisma.document.delete({
          where: { id: parseInt(id as string) },
        })
        res.status(200).json({ message: 'Document deleted successfully' })
      } catch (error) {
        console.error('Error deleting document:', error)
        res.status(404).json({ error: 'Document not found or could not be deleted' })
      }
    } else {
      res.status(400).json({ error: 'Document ID is required' })
    }
  } else {
    res.status(405).end() // Method Not Allowed
  }
}

=== FILE: ./src/pages/wiki.tsx ===

// @/pages/wiki.tsx
import { useState, useCallback } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';
import { useDocuments } from '@/lib/hooks/useDocuments';
import { useAuth } from '@/lib/hooks/useAuth';
import { useSearch } from '@/lib/hooks/useSearch';
import { Document } from '@/lib/types/wiki';

export default function WikiPage() {
  const {
    documents,
    categories,
    isLoading,
    createDocument,
    updateDocument,
    deleteDocument
  } = useDocuments();

  const {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  } = useAuth();

  const {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  } = useSearch(documents);

  const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState<{ [key: string]: boolean }>({});

  useHotkeys('ctrl+space', (e) => {
    e.preventDefault();
    setIsSearchOpen(true);
  }, []);

  const handleDocumentSelect = useCallback((id: number) => {
    const document = documents.find(doc => doc.id === id);
    if (document) {
      setSelectedDocument(document);
      setIsEditing(false);
    }
  }, [documents]);

  const canEditDocument = useCallback((document: Document) => {
    return isUnlocked || !document.restricted;
  }, [isUnlocked]);

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
              expandedCategories={expandedCategories}
              setExpandedCategories={setExpandedCategories}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={searchResults}
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={handleDocumentSelect}
        onSearch={handleSearch}
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={setSearchResults}
        setSelectedDocument={setSelectedDocument}
        setExpandedCategories={setExpandedCategories}
      />
    </div>
  );
}
=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./wiki_files.txt ===


=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285
=== FILE: ./hostapps_files.txt ===


=== FILE: ./src/lib/utils/apiUtils.ts ===

import { WikiError } from '@/lib/errors/wikiError';

export const handleApiResponse = async (response: Response, errorMessage: string) => {
  if (!response.ok) {
    throw new Error(errorMessage);
  }
  return response.json();
};
=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import Fuse from 'fuse.js';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Fuse.FuseResult<Document>[]>([]);

  // Enhanced Fuse configuration
  const searchIndex = useMemo(() => {
    return new Fuse(documents, {
      keys: [
        { 
          name: 'title',
          weight: 3.0  // Increased weight for titles
        },
        {
          name: 'content',
          weight: 1.0
        },
        {
          name: 'category',
          weight: 2.0
        }
      ],
      includeMatches: true,
      shouldSort: true,
      threshold: 0.3,      // Lower threshold for stricter matching
      location: 0,         // Start searching at beginning of strings
      distance: 200,       // Allow more distance for matches
      minMatchCharLength: 2,  // Minimum length for matches
      useExtendedSearch: true,
      ignoreLocation: false,  // Consider location in string for relevance
      findAllMatches: true,   // Find all matching instances
      // Add Swedish diacritics to equivalent chars
      getFn: (obj, path) => {
        const value = Fuse.config.getFn(obj, path);
        if (typeof value === 'string') {
          return value.toLowerCase()
            .replace(/[åä]/g, 'a')
            .replace(/ö/g, 'o');
        }
        return value;
      }
    });
  }, [documents]);

  const handleSearch = useCallback((query: string) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    // Use extended search syntax for better matching
    const searchPattern = query.split(' ').map(term => {
      // Exact match for terms with quotes
      if (term.startsWith('"') && term.endsWith('"')) {
        return `'${term.slice(1, -1)}`;
      }
      // Fuzzy matching for other terms
      return `${term}`;
    }).join(' ');

    const results = searchIndex.search(searchPattern);
    setSearchResults(results);
  }, [searchIndex]);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  };
};
=== FILE: ./src/lib/context/WikiContext.tsx ===

import React, { 
    createContext, 
    useContext, 
    useState, 
    useCallback, 
    useEffect,
    useMemo 
  } from 'react';
  import { toast } from 'react-hot-toast';
  import { 
    Document, 
    Category, 
    CategoryWithHierarchy, 
    Tag, 
    DocumentUpdate, 
    WikiState,
    DocumentFilter,
    SortOption
  } from '@/lib/types/wiki';
  
  interface WikiContextType extends WikiState {
    // Document actions
    selectDocument: (id: number | null) => void;
    createDocument: (title: string, category: string, restricted: boolean) => Promise<void>;
    updateDocument: (id: number, updates: DocumentUpdate) => Promise<void>;
    deleteDocument: (id: number) => Promise<void>;
    
    // Category actions
    createCategory: (name: string, parentId?: number) => Promise<void>;
    updateCategory: (id: number, name: string) => Promise<void>;
    deleteCategory: (id: number) => Promise<void>;
    reorderCategory: (id: number, newOrder: number) => Promise<void>;
    
    // Tag actions
    createTag: (name: string, color: string) => Promise<void>;
    deleteTag: (id: number) => Promise<void>;
    updateDocumentTags: (documentId: number, tagIds: number[]) => Promise<void>;
    
    // UI State actions
    setIsEditing: (value: boolean) => void;
    setIsUnlocked: (value: boolean) => void;
    
    // Search and filter
    filterDocuments: (filter: DocumentFilter) => void;
    sortDocuments: (sort: SortOption) => void;
    
    // Auth
    isPasswordPromptOpen: boolean;
    setIsPasswordPromptOpen: (value: boolean) => void;
    handlePasswordSubmit: (password: string) => Promise<void>;
  }
  
  const buildCategoryHierarchy = (
    categories: Category[],
    documents: Document[],
    parentId: number | null = null,
    level: number = 0
  ): CategoryWithHierarchy[] => {
    return categories
      .filter(cat => cat.parentId === parentId)
      .map(cat => ({
        ...cat,
        level,
        children: buildCategoryHierarchy(categories, documents, cat.id, level + 1),
        documentCount: documents.filter(doc => doc.category === cat.name).length
      }))
      .sort((a, b) => a.order - b.order);
  };
  
  const WikiContext = createContext<WikiContextType | null>(null);
  
  export function useWiki() {
    const context = useContext(WikiContext);
    if (!context) {
      throw new Error('useWiki must be used within a WikiProvider');
    }
    return context;
  }
  
  export function WikiProvider({ children }: { children: React.ReactNode }) {
    // State
    const [documents, setDocuments] = useState<Document[]>([]);
    const [categories, setCategories] = useState<Category[]>([]);
    const [tags, setTags] = useState<Tag[]>([]);
    const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
    const [isEditing, setIsEditing] = useState(false);
    const [isUnlocked, setIsUnlocked] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);
    const [filter, setFilter] = useState<DocumentFilter>({});
    const [sort, setSort] = useState<SortOption>({ field: 'updatedAt', direction: 'desc' });
  
    // Compute category hierarchy
    const categoryHierarchy = useMemo(() => 
      buildCategoryHierarchy(categories, documents),
      [categories, documents]
    );
  
    // Fetch initial data
    const fetchData = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        
        try {
          // Fetch documents first since we know that table exists
          const docsRes = await fetch('/api/wiki/wiki');
          if (!docsRes.ok) {
            throw new Error('Failed to fetch documents');
          }
          const docsData = await docsRes.json();
          setDocuments(docsData);
      
          try {
            // Try to fetch categories
            const catsRes = await fetch('/api/wiki/categories');
            if (catsRes.ok) {
              const catsData = await catsRes.json();
              setCategories(catsData);
            }
          } catch (error) {
            console.error('Error fetching categories:', error);
            setCategories([]); // Set empty array if categories fail
          }
      
          try {
            // Try to fetch tags
            const tagsRes = await fetch('/api/wiki/tags');
            if (tagsRes.ok) {
              const tagsData = await tagsRes.json();
              setTags(tagsData);
            }
          } catch (error) {
            console.error('Error fetching tags:', error);
            setTags([]); // Set empty array if tags fail
          }
      
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : 'An unexpected error occurred';
          console.error('Error fetching data:', err);
          setError(errorMessage);
          toast.error(errorMessage);
        } finally {
          setIsLoading(false);
        }
      }, []);
  
    useEffect(() => {
      fetchData();
    }, [fetchData]);
  
    // Document actions
    const selectDocument = useCallback((id: number | null) => {
      const doc = id ? documents.find(d => d.id === id) || null : null;
      setSelectedDocument(doc);
      setIsEditing(false);
    }, [documents]);
  
    const createDocument = useCallback(async (
      title: string,
      category: string,
      restricted: boolean
    ) => {
      try {
        const response = await fetch('/api/wiki/wiki', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, category, restricted }),
        });
  
        if (!response.ok) throw new Error('Failed to create document');
  
        await fetchData();
        toast.success('Document created successfully');
      } catch (error) {
        console.error('Error creating document:', error);
        toast.error('Failed to create document');
        throw error;
      }
    }, [fetchData]);
  
    const updateDocument = useCallback(async (
        id: number,
        updates: DocumentUpdate
      ) => {
        try {
          // Find the current document to merge with updates
          const currentDoc = documents.find(d => d.id === id);
          if (!currentDoc) {
            throw new Error('Document not found');
          }
      
          const response = await fetch('/api/wiki/wiki', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id,
              title: updates.title || currentDoc.title,
              content: updates.content || currentDoc.content,
              category: updates.category || currentDoc.category,
              restricted: updates.restricted ?? currentDoc.restricted,
              isPinned: updates.isPinned ?? currentDoc.isPinned
            }),
          });
      
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to update document');
          }
      
          await fetchData();
          toast.success('Document updated successfully');
        } catch (error) {
          console.error('Error updating document:', error);
          toast.error(error instanceof Error ? error.message : 'Failed to update document');
          throw error;
        }
      }, [documents, fetchData]);
  
    const deleteDocument = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/wiki?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete document');
  
        await fetchData();
        if (selectedDocument?.id === id) {
          setSelectedDocument(null);
        }
        toast.success('Document deleted successfully');
      } catch (error) {
        console.error('Error deleting document:', error);
        toast.error('Failed to delete document');
        throw error;
      }
    }, [fetchData, selectedDocument?.id]);
  
    // Category actions
    const createCategory = useCallback(async (name: string, parentId?: number) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, parentId }),
        });
  
        if (!response.ok) throw new Error('Failed to create category');
  
        await fetchData();
        toast.success('Category created successfully');
      } catch (error) {
        console.error('Error creating category:', error);
        toast.error('Failed to create category');
        throw error;
      }
    }, [fetchData]);
  
    const updateCategory = useCallback(async (id: number, name: string) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, name }),
        });
  
        if (!response.ok) throw new Error('Failed to update category');
  
        await fetchData();
        toast.success('Category updated successfully');
      } catch (error) {
        console.error('Error updating category:', error);
        toast.error('Failed to update category');
        throw error;
      }
    }, [fetchData]);
  
    const deleteCategory = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/categories?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete category');
  
        await fetchData();
        toast.success('Category deleted successfully');
      } catch (error) {
        console.error('Error deleting category:', error);
        toast.error('Failed to delete category');
        throw error;
      }
    }, [fetchData]);
  
    const reorderCategory = useCallback(async (id: number, newOrder: number) => {
      try {
        const response = await fetch('/api/wiki/categories', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id, order: newOrder }),
        });
  
        if (!response.ok) throw new Error('Failed to reorder category');
  
        await fetchData();
      } catch (error) {
        console.error('Error reordering category:', error);
        toast.error('Failed to reorder category');
        throw error;
      }
    }, [fetchData]);
  
    // Tag actions
    const createTag = useCallback(async (name: string, color: string) => {
      try {
        const response = await fetch('/api/wiki/tags', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, color }),
        });
  
        if (!response.ok) throw new Error('Failed to create tag');
  
        await fetchData();
        toast.success('Tag created successfully');
      } catch (error) {
        console.error('Error creating tag:', error);
        toast.error('Failed to create tag');
        throw error;
      }
    }, [fetchData]);
  
    const deleteTag = useCallback(async (id: number) => {
      try {
        const response = await fetch(`/api/wiki/tags?id=${id}`, {
          method: 'DELETE',
        });
  
        if (!response.ok) throw new Error('Failed to delete tag');
  
        await fetchData();
        toast.success('Tag deleted successfully');
      } catch (error) {
        console.error('Error deleting tag:', error);
        toast.error('Failed to delete tag');
        throw error;
      }
    }, [fetchData]);
  
    const updateDocumentTags = useCallback(async (documentId: number, tagIds: number[]) => {
      try {
        const response = await fetch('/api/wiki/tags', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ documentId, tagIds }),
        });
  
        if (!response.ok) throw new Error('Failed to update document tags');
  
        await fetchData();
        toast.success('Tags updated successfully');
      } catch (error) {
        console.error('Error updating document tags:', error);
        toast.error('Failed to update document tags');
        throw error;
      }
    }, [fetchData]);
  
    // Search and filter
    const filterDocuments = useCallback((newFilter: DocumentFilter) => {
      setFilter(newFilter);
    }, []);
  
    const sortDocuments = useCallback((newSort: SortOption) => {
      setSort(newSort);
    }, []);
  
    // Auth
    const handlePasswordSubmit = useCallback(async (password: string) => {
      try {
        const response = await fetch('/api/wiki/verify-password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password }),
        });
  
        if (response.ok) {
          setIsUnlocked(true);
          setIsPasswordPromptOpen(false);
          toast.success('Successfully unlocked');
        } else {
          toast.error('Incorrect password');
        }
      } catch (error) {
        console.error('Error during authentication:', error);
        toast.error('Authentication failed');
      }
    }, []);
  
    // Create value object after all functions are defined
    const value = {
      documents,
      selectedDocument,
      categories: categoryHierarchy,
      tags,
      isEditing,
      isUnlocked,
      isLoading,
      error,
      isPasswordPromptOpen,
      selectDocument,
      createDocument,
      updateDocument,
      deleteDocument,
      createCategory,
      updateCategory,
      deleteCategory,
      reorderCategory,
      createTag,
      deleteTag,
      updateDocumentTags,
      setIsEditing,
      setIsUnlocked,
      setIsPasswordPromptOpen,
      filterDocuments,
      sortDocuments,
      handlePasswordSubmit,
    };
  
    return (
      <WikiContext.Provider value={value}>
        {children}
      </WikiContext.Provider>
    );
  }
=== FILE: ./src/lib/types/wiki.ts ===

// src/lib/types/wiki.ts
export interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
  isPinned?: boolean;
  createdAt: Date;
  updatedAt: Date;
  tags?: Array<{
    id: number;
    name: string;
    color: string;
  }>;
}

export interface Tag {
  id: number;
  name: string;
  color: string;
}

export interface Category {
  id: number;
  name: string;
  parentId: number | null;
  order: number;
}

export interface CategoryWithHierarchy extends Category {
  level: number;
  children: CategoryWithHierarchy[];
  documentCount: number;
}

export interface DocumentUpdate {
  title?: string;
  content?: string;
  category?: string;
  restricted?: boolean;
  isPinned?: boolean;
}

export interface SearchResult {
  document: Document;
  matches: {
    indices: [number, number][];
    key: string;
    value: string;
  }[];
  score: number;
}

export interface TOCItem {
  id: string;
  text: string;
  level: number;
}

// API Response Types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface DocumentResponse extends ApiResponse<Document> {}
export interface DocumentsResponse extends ApiResponse<Document[]> {}
export interface CategoryResponse extends ApiResponse<Category> {}
export interface CategoriesResponse extends ApiResponse<Category[]> {}
export interface TagResponse extends ApiResponse<Tag> {}
export interface TagsResponse extends ApiResponse<Tag[]> {}

// Action Types for any reducers you might add later
export type DocumentAction = 
  | { type: 'SET_DOCUMENTS'; payload: Document[] }
  | { type: 'ADD_DOCUMENT'; payload: Document }
  | { type: 'UPDATE_DOCUMENT'; payload: Document }
  | { type: 'DELETE_DOCUMENT'; payload: number }
  | { type: 'SET_SELECTED_DOCUMENT'; payload: Document | null }
  | { type: 'SET_IS_EDITING'; payload: boolean };

export type CategoryAction =
  | { type: 'SET_CATEGORIES'; payload: Category[] }
  | { type: 'ADD_CATEGORY'; payload: Category }
  | { type: 'UPDATE_CATEGORY'; payload: Category }
  | { type: 'DELETE_CATEGORY'; payload: number }
  | { type: 'REORDER_CATEGORY'; payload: { id: number; order: number } };

export type TagAction =
  | { type: 'SET_TAGS'; payload: Tag[] }
  | { type: 'ADD_TAG'; payload: Tag }
  | { type: 'UPDATE_TAG'; payload: Tag }
  | { type: 'DELETE_TAG'; payload: number };

// State Types for context
export interface WikiState {
  documents: Document[];
  selectedDocument: Document | null;
  categories: CategoryWithHierarchy[];
  tags: Tag[];
  isEditing: boolean;
  isUnlocked: boolean;
  isLoading: boolean;
  error: string | null;
}

// Additional Types for specific features
export interface DocumentFilter {
  category?: string;
  tag?: string;
  searchQuery?: string;
  restricted?: boolean;
  isPinned?: boolean;
}

export interface SortOption {
  field: keyof Document;
  direction: 'asc' | 'desc';
}

export interface DocumentStats {
  totalCount: number;
  restrictedCount: number;
  pinnedCount: number;
  categoryCounts: Record<string, number>;
  tagCounts: Record<string, number>;
  lastUpdated: Date;
}
=== FILE: ./src/lib/types/types.ts ===

// @/lib/types/wiki.ts
export interface Document {
  id: number;
  title: string;
  content: string;
  category: string;
  restricted: boolean;
}
=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    // Create documents table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN,
        isPinned BOOLEAN DEFAULT 0,
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);

    // Check and add category column to documents
    const documentsInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = documentsInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }

    // Create categories table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        parentId INTEGER,
        orderIndex INTEGER DEFAULT 0,
        FOREIGN KEY (parentId) REFERENCES categories(id)
      );
    `);

    // Create tags table
    await db.exec(`
      CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        color TEXT NOT NULL
      );
    `);

    // Create document_tags table for many-to-many relationship
    await db.exec(`
      CREATE TABLE IF NOT EXISTS document_tags (
        documentId INTEGER,
        tagId INTEGER,
        PRIMARY KEY (documentId, tagId),
        FOREIGN KEY (documentId) REFERENCES documents(id) ON DELETE CASCADE,
        FOREIGN KEY (tagId) REFERENCES tags(id) ON DELETE CASCADE
      );
    `);
  }
  return db;
}

// Rest of your existing functions remain the same...

export async function getCategories(): Promise<Category[]> {
  const db = await openDb();
  return db.all(`
    SELECT 
      c.id, 
      c.name, 
      c.parentId,
      c.orderIndex,
      COUNT(d.id) as documentCount
    FROM categories c
    LEFT JOIN documents d ON d.category = c.name
    GROUP BY c.id
    ORDER BY c.orderIndex
  `);
}

export async function createCategory(name: string, parentId?: number): Promise<Category> {
  const db = await openDb();
  const maxOrder = await db.get('SELECT MAX(orderIndex) as maxOrder FROM categories');
  const result = await db.run(
    'INSERT INTO categories (name, parentId, orderIndex) VALUES (?, ?, ?)',
    name,
    parentId || null,
    (maxOrder?.maxOrder || 0) + 1
  );
  return {
    id: result.lastID!,
    name,
    parentId: parentId || null,
    order: (maxOrder?.maxOrder || 0) + 1
  };
}

export async function updateCategory(id: number, name: string): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET name = ? WHERE id = ?', name, id);
}

export async function deleteCategory(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM categories WHERE id = ?', id);
}

export async function reorderCategory(id: number, newOrder: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE categories SET orderIndex = ? WHERE id = ?', newOrder, id);
}

export async function getTags(): Promise<Tag[]> {
  const db = await openDb();
  return db.all('SELECT * FROM tags');
}

export async function createTag(name: string, color: string): Promise<Tag> {
  const db = await openDb();
  const result = await db.run(
    'INSERT INTO tags (name, color) VALUES (?, ?)',
    name,
    color
  );
  return { id: result.lastID!, name, color };
}

export async function deleteTag(id: number): Promise<void> {
  const db = await openDb();
  await db.run('DELETE FROM tags WHERE id = ?', id);
}

export async function updateDocumentTags(documentId: number, tagIds: number[]): Promise<void> {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    await db.run('DELETE FROM document_tags WHERE documentId = ?', documentId);
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        documentId,
        tagId
      );
    }
    await db.run('COMMIT');
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

// Update existing document functions to include new fields
export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  const documents = await db.all(`
    SELECT 
      d.*,
      GROUP_CONCAT(t.id) as tagIds,
      GROUP_CONCAT(t.name) as tagNames,
      GROUP_CONCAT(t.color) as tagColors
    FROM documents d
    LEFT JOIN document_tags dt ON d.id = dt.documentId
    LEFT JOIN tags t ON dt.tagId = t.id
    ${includeRestricted ? '' : 'WHERE d.restricted = 0'}
    GROUP BY d.id
    ORDER BY d.isPinned DESC, d.updatedAt DESC
  `);

  return documents.map(doc => ({
    ...doc,
    tags: doc.tagIds ? doc.tagIds.split(',').map((id: string, index: number) => ({
      id: parseInt(id),
      name: doc.tagNames.split(',')[index],
      color: doc.tagColors.split(',')[index]
    })) : []
  }));
}

export async function createDocument(
  title: string,
  content: string,
  restricted: boolean,
  categoryId: number,
  tagIds: number[] = []
) {
  const db = await openDb();
  await db.run('BEGIN TRANSACTION');
  try {
    const result = await db.run(
      `INSERT INTO documents (
        title, content, restricted, categoryId, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
      title,
      content,
      restricted ? 1 : 0,
      categoryId
    );
    
    for (const tagId of tagIds) {
      await db.run(
        'INSERT INTO document_tags (documentId, tagId) VALUES (?, ?)',
        result.lastID,
        tagId
      );
    }
    
    await db.run('COMMIT');
    return result.lastID;
  } catch (error) {
    await db.run('ROLLBACK');
    throw error;
  }
}

export async function toggleDocumentPin(id: number): Promise<void> {
  const db = await openDb();
  await db.run('UPDATE documents SET isPinned = NOT isPinned WHERE id = ?', id);
}
=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/WikiWelcome.tsx ===

// @/components/wiki/WikiWelcome.tsx
import React from 'react';
import { Document, Category } from '@/lib/types/wiki';
import { Card } from "@/components/ui/card";
import { Pin, Clock, Tags, FolderOpen } from 'lucide-react';

interface WikiWelcomeProps {
  documents: Document[];
  categories: Category[];
  onDocumentSelect: (id: number) => void;
}

export default function WikiWelcome({ 
  documents, 
  categories,
  onDocumentSelect 
}: WikiWelcomeProps) {
  const pinnedDocs = documents.filter(doc => doc.isPinned);
  const recentDocs = documents
    .filter(doc => !doc.isPinned)
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
    .slice(0, 5);

  const getCategoryPath = (categoryId: number): string => {
    const path: string[] = [];
    let currentId = categoryId;
    
    while (currentId) {
      const category = categories.find(c => c.id === currentId);
      if (category) {
        path.unshift(category.name);
        currentId = category.parentId!;
      } else {
        break;
      }
    }
    
    return path.join(' / ');
  };

  return (
    <div className="p-8 max-w-6xl mx-auto">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold mb-4">Welcome to the Wiki</h1>
        <p className="text-xl text-muted-foreground">
          Your central hub for documentation and knowledge sharing
        </p>
      </div>

      {pinnedDocs.length > 0 && (
        <div className="mb-8">
          <div className="flex items-center gap-2 mb-4">
            <Pin className="w-5 h-5" />
            <h2 className="text-xl font-semibold">Pinned Documents</h2>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {pinnedDocs.map(doc => (
              <Card
                key={doc.id}
                className="p-4 cursor-pointer hover:bg-muted/50 transition-colors"
                onClick={() => onDocumentSelect(doc.id)}
              >
                <h3 className="font-medium mb-2">{doc.title}</h3>
                <div className="text-sm text-muted-foreground mb-2 flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {getCategoryPath(doc.categoryId)}
                </div>
                {doc.tags.length > 0 && (
                  <div className="flex items-center gap-2 text-sm text-muted-foreground">
                    <Tags className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </Card>
            ))}
          </div>
        </div>
      )}

      <div>
        <div className="flex items-center gap-2 mb-4">
          <Clock className="w-5 h-5" />
          <h2 className="text-xl font-semibold">Recently Updated</h2>
        </div>
        <div className="space-y-2">
          {recentDocs.map(doc => (
            <div
              key={doc.id}
              className="p-4 border rounded-lg cursor-pointer hover:bg-muted/50 transition-colors"
              onClick={() => onDocumentSelect(doc.id)}
            >
              <div className="flex items-center justify-between mb-1">
                <h3 className="font-medium">{doc.title}</h3>
                <span className="text-sm text-muted-foreground">
                  {new Date(doc.updatedAt).toLocaleDateString()}
                </span>
              </div>
              <div className="flex items-center gap-4 text-sm text-muted-foreground">
                <div className="flex items-center gap-2">
                  <FolderOpen className="w-4 h-4" />
                  {getCategoryPath(doc.categoryId)}
                </div>
                {doc.tags.length > 0 && (
                  <div className="flex items-center gap-2">
                    <Tags className="w-4 h-4" />
                    {doc.tags.map(tag => tag.name).join(', ')}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

// src/components/wiki/WikiHeader.tsx
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { useWiki } from '@/lib/context/WikiContext';

export const WikiHeader = () => {
  const { 
    isUnlocked,
    setIsUnlocked,
    setIsPasswordPromptOpen,
    isLoading 
  } = useWiki();

  const handleUnlockToggle = (checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  };

  return (
    <div className="flex-shrink-0 p-4 bg-base-300 border-b">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <h1 className="text-2xl font-bold">Wiki Documents</h1>
          <p className="text-[#D8DEE9]/80">
            Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to open apps
          </p>
        </div>
        
        <div className="flex items-center space-x-4">
          <Button onClick={() => setIsPasswordPromptOpen(true)}>Add New Page</Button>
          <Button variant="outline" onClick={() => setIsPasswordPromptOpen(true)}>
            Upload Word Document
          </Button>
          <div className="flex items-center space-x-2">
            <Switch
              id="lock-mode"
              checked={isUnlocked}
              onCheckedChange={handleUnlockToggle}
              disabled={isLoading}
            />
            <Label htmlFor="lock-mode">
              {isUnlocked ? 'Unlocked' : 'Locked'}
            </Label>
          </div>
        </div>
      </div>
    </div>
  );
};
=== FILE: ./src/components/wiki/CategoryManager.tsx ===

// @/components/wiki/CategoryManager.tsx
import React, { useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus, Edit2, Trash2, GripVertical, ChevronRight, ChevronDown } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { CategoryWithHierarchy, Tag } from '@/lib/types/wiki';
import { cn } from "@/lib/utils";

interface CategoryManagerProps {
  categories: CategoryWithHierarchy[];
  onCategoryCreate: (name: string, parentId?: number) => Promise<void>;
  onCategoryUpdate: (id: number, name: string) => Promise<void>;
  onCategoryDelete: (id: number) => Promise<void>;
  onCategoryMove: (id: number, parentId: number | null) => Promise<void>;
  onCategoryReorder: (id: number, newOrder: number) => Promise<void>;
}

const CategoryManager: React.FC<CategoryManagerProps> = ({
  categories,
  onCategoryCreate,
  onCategoryUpdate,
  onCategoryDelete,
  onCategoryMove,
  onCategoryReorder,
}) => {
  const [expandedCategories, setExpandedCategories] = useState<Set<number>>(new Set());
  const [draggedCategory, setDraggedCategory] = useState<number | null>(null);
  const [editCategory, setEditCategory] = useState<{ id: number; name: string } | null>(null);
  const [newCategoryName, setNewCategoryName] = useState("");
  const [selectedParentId, setSelectedParentId] = useState<number | null>(null);

  const toggleExpanded = (categoryId: number) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      if (newSet.has(categoryId)) {
        newSet.delete(categoryId);
      } else {
        newSet.add(categoryId);
      }
      return newSet;
    });
  };

  const handleDragStart = (e: React.DragEvent, categoryId: number) => {
    setDraggedCategory(categoryId);
    e.dataTransfer.setData('text/plain', categoryId.toString());
  };

  const handleDragOver = (e: React.DragEvent, categoryId: number) => {
    e.preventDefault();
    if (draggedCategory === categoryId) return;
    
    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;
    
    target.classList.remove('border-t-2', 'border-b-2');
    if (y < rect.height / 3) {
      target.classList.add('border-t-2');
    } else if (y > (rect.height * 2) / 3) {
      target.classList.add('border-b-2');
    }
  };

  const handleDrop = async (e: React.DragEvent, targetId: number) => {
    e.preventDefault();
    if (!draggedCategory) return;

    const target = e.currentTarget as HTMLElement;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;

    if (y < rect.height / 3) {
      // Drop above
      await onCategoryReorder(draggedCategory, targetId - 0.5);
    } else if (y > (rect.height * 2) / 3) {
      // Drop below
      await onCategoryReorder(draggedCategory, targetId + 0.5);
    } else {
      // Drop as child
      await onCategoryMove(draggedCategory, targetId);
    }

    setDraggedCategory(null);
    target.classList.remove('border-t-2', 'border-b-2');
  };

  const renderCategory = (category: CategoryWithHierarchy) => {
    const isExpanded = expandedCategories.has(category.id);
    
    return (
      <div key={category.id}>
        <div
          className={cn(
            "flex items-center p-2 rounded-lg hover:bg-muted/50 cursor-pointer",
            draggedCategory === category.id && "opacity-50"
          )}
          draggable
          onDragStart={(e) => handleDragStart(e, category.id)}
          onDragOver={(e) => handleDragOver(e, category.id)}
          onDrop={(e) => handleDrop(e, category.id)}
          style={{ marginLeft: `${category.level * 1.5}rem` }}
        >
          <button
            className="mr-2"
            onClick={() => toggleExpanded(category.id)}
          >
            {category.children.length > 0 && (
              isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />
            )}
          </button>
          
          <GripVertical className="w-4 h-4 mr-2 cursor-grab" />
          
          <span className="flex-1">{category.name}</span>
          
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                setEditCategory({ id: category.id, name: category.name });
              }}
            >
              <Edit2 size={16} />
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={(e) => {
                e.stopPropagation();
                onCategoryDelete(category.id);
              }}
            >
              <Trash2 size={16} />
            </Button>
          </div>
        </div>
        
        {isExpanded && (
          <motion.div
            initial={{ height: 0 }}
            animate={{ height: "auto" }}
            exit={{ height: 0 }}
          >
            {category.children.map(renderCategory)}
          </motion.div>
        )}
      </div>
    );
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Categories</h2>
        <Button onClick={() => setEditCategory({ id: -1, name: '' })}>
          <Plus size={16} className="mr-2" />
          Add Category
        </Button>
      </div>

      <div className="space-y-1">
        {categories.map(renderCategory)}
      </div>

      <Dialog open={!!editCategory} onOpenChange={() => setEditCategory(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {editCategory?.id === -1 ? 'Add Category' : 'Edit Category'}
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={editCategory?.name ?? ''}
                onChange={(e) => setEditCategory(prev => prev ? { ...prev, name: e.target.value } : null)}
                placeholder="Category name"
              />
            </div>

            {editCategory?.id === -1 && (
              <div>
                <select
                  value={selectedParentId?.toString() ?? ''}
                  onChange={(e) => setSelectedParentId(e.target.value ? Number(e.target.value) : null)}
                  className="w-full p-2 rounded-md border"
                >
                  <option value="">No parent (root category)</option>
                  {categories.map(cat => (
                    <option key={cat.id} value={cat.id}>
                      {'  '.repeat(cat.level)}{cat.name}
                    </option>
                  ))}
                </select>
              </div>
            )}

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setEditCategory(null)}>
                Cancel
              </Button>
              <Button
                onClick={async () => {
                  if (editCategory) {
                    if (editCategory.id === -1) {
                      await onCategoryCreate(editCategory.name, selectedParentId ?? undefined);
                    } else {
                      await onCategoryUpdate(editCategory.id, editCategory.name);
                    }
                    setEditCategory(null);
                  }
                }}
              >
                {editCategory?.id === -1 ? 'Create' : 'Update'}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default CategoryManager;
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useWiki } from '@/lib/context/WikiContext';
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content?: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/wiki/TagManager.tsx ===

// @/components/wiki/TagManager.tsx
import React, { useState } from 'react';
import { Plus, X } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Tag } from '@/lib/types/wiki';

interface TagManagerProps {
  tags: Tag[];
  onTagCreate: (name: string, color: string) => Promise<void>;
  onTagDelete: (id: number) => Promise<void>;
  onTagsChange: (documentId: number, tagIds: number[]) => Promise<void>;
}

const TagManager: React.FC<TagManagerProps> = ({
  tags,
  onTagCreate,
  onTagDelete,
  onTagsChange,
}) => {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [newTag, setNewTag] = useState({ name: '', color: '#3B82F6' });

  const handleCreateTag = async () => {
    await onTagCreate(newTag.name, newTag.color);
    setNewTag({ name: '', color: '#3B82F6' });
    setIsDialogOpen(false);
  };

  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium">Tags</h2>
        <Button onClick={() => setIsDialogOpen(true)}>
          <Plus size={16} className="mr-2" />
          Add Tag
        </Button>
      </div>

      <div className="flex flex-wrap gap-2">
        {tags.map(tag => (
          <div
            key={tag.id}
            className="flex items-center gap-2 px-3 py-1 rounded-full"
            style={{ backgroundColor: tag.color + '20', color: tag.color }}
          >
            <span>{tag.name}</span>
            <button
              onClick={() => onTagDelete(tag.id)}
              className="hover:opacity-75"
            >
              <X size={14} />
            </button>
          </div>
        ))}
      </div>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add Tag</DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Input
                value={newTag.name}
                onChange={(e) => setNewTag(prev => ({ ...prev, name: e.target.value }))}
                placeholder="Tag name"
              />
            </div>

            <div>
              <input
                type="color"
                value={newTag.color}
                onChange={(e) => setNewTag(prev => ({ ...prev, color: e.target.value }))}
                className="w-full h-10 p-1 rounded border"
              />
            </div>

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleCreateTag}>
                Create
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default TagManager;
=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import { useWiki } from '@/lib/context/WikiContext';
import { cn } from "@/lib/utils";

export default function WikiSearch() {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<Array<any>>([]);
  const searchRef = useRef<HTMLInputElement>(null);
  const { documents, selectDocument } = useWiki();

  // Handle keyboard shortcut
  export function WikiSearch({ onOpen }: { onOpen: () => void }) {
    useEffect(() => {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.ctrlKey && e.code === 'Space') {
          e.preventDefault();
          onOpen();
        }
      };

      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onOpen]);

  // Search functionality
  const handleSearch = (value: string) => {
    setSearchQuery(value);
    if (!value.trim()) {
      setSearchResults([]);
      return;
    }

    const query = value.toLowerCase();
    const results = documents.filter(doc => 
      doc.title.toLowerCase().includes(query) ||
      doc.content.toLowerCase().includes(query) ||
      doc.category.toLowerCase().includes(query)
    );

    setSearchResults(results);
  };

  return (
    <div className="relative w-full">
      <Input
        ref={searchRef}
        type="text"
        value={searchQuery}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search documents... (Ctrl + Space)"
        onFocus={() => setIsOpen(true)}
        className="pl-10 py-6 text-lg"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.map((doc) => (
                <div
                  key={doc.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    selectDocument(doc.id);
                    setIsOpen(false);
                    setSearchQuery('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">{doc.title}</span>
                      <span className="text-xs text-muted-foreground">
                        {doc.category}
                      </span>
                    </div>
                    <p className="text-sm text-muted-foreground line-clamp-2">
                      {doc.content}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// src/components/wiki/WikiContent.tsx
import dynamic from 'next/dynamic';
import { useWiki } from '@/lib/context/WikiContext';
import WikiDocument from '@/components/wiki/WikiDocument';

const MarkdownEditor = dynamic(() => import('@/components/wiki/MarkdownEditor'), {
  ssr: false
});

export function WikiContent() {
  const {
    selectedDocument,
    isEditing,
    isUnlocked,
    updateDocument,
    setIsEditing,
  } = useWiki();

  if (!selectedDocument) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        Select a document to view its content
      </div>
    );
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <MarkdownEditor
          documentId={selectedDocument.id}
          initialTitle={selectedDocument.title}
          initialContent={selectedDocument.content}
          onSave={async (title, content) => {
            await updateDocument(selectedDocument.id, title, content);
            setIsEditing(false);
          }}
          onCancel={() => setIsEditing(false)}
        />
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={updateDocument}
        onEdit={() => setIsEditing(true)}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React from 'react';
import MarkdownPreview from '@uiw/react-markdown-preview';
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Breadcrumb, BreadcrumbItem, BreadcrumbLink } from "@/components/ui/breadcrumb";
import { Pin, PinOff, Lock, Pencil } from 'lucide-react';
import { Document } from '@/lib/types/wiki';
import '@uiw/react-markdown-preview/markdown.css';

interface WikiDocumentProps {
  document: Document;
  isUnlocked: boolean;
  onDocumentUpdate: (id: number, updates: Partial<Document>) => Promise<void>;
  onEdit: () => void;
}

export default function WikiDocument({ 
  document, 
  isUnlocked, 
  onDocumentUpdate,
  onEdit
}: WikiDocumentProps) {
  if (!document) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        No document selected
      </div>
    );
  }

  const togglePin = async () => {
    try {
      await onDocumentUpdate(document.id, {
        title: document.title,
        content: document.content,
        category: document.category,
        restricted: document.restricted,
        isPinned: !document.isPinned
      });
    } catch (error) {
      console.error('Error toggling pin:', error);
      toast.error('Failed to update document');
    }
  };

  // Function to preprocess the Markdown content
  const preprocessMarkdown = (content: string) => {
    // Replace single line breaks with <br>, but preserve double line breaks
    return content.replace(/(?<!\n)\n(?!\n)/g, '  \n');
  };

  const processedContent = preprocessMarkdown(document.content);
  const canEdit = isUnlocked || !document.restricted;

  return (
    <div className="w-full h-full bg-background text-foreground">
      <div className="p-6 border-b">
        <Breadcrumb>
          <BreadcrumbItem>
            <BreadcrumbLink>Wiki</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem>
            <BreadcrumbLink>{document.category}</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbItem isCurrentPage>
            <span className="font-medium">{document.title}</span>
          </BreadcrumbItem>
        </Breadcrumb>

        <div className="mt-4 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <h1 className="text-2xl font-bold">{document.title}</h1>
            {document.restricted && (
              <Lock className="w-5 h-5 text-warning" />
            )}
          </div>

          <div className="flex items-center gap-2">
            {canEdit && (
              <>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={togglePin}
                  title={document.isPinned ? "Unpin document" : "Pin document"}
                >
                  {document.isPinned ? (
                    <PinOff className="w-4 h-4" />
                  ) : (
                    <Pin className="w-4 h-4" />
                  )}
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={onEdit}
                  title="Edit document"
                >
                  <Pencil className="w-4 h-4" />
                </Button>
              </>
            )}
          </div>
        </div>

        {document.tags && document.tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mt-4">
            {document.tags.map(tag => (
              <Badge
                key={tag.id}
                variant="outline"
                style={{
                  borderColor: tag.color,
                  color: tag.color,
                  backgroundColor: `${tag.color}10`
                }}
              >
                {tag.name}
              </Badge>
            ))}
          </div>
        )}

        <div className="text-sm text-muted-foreground mt-4">
          Last updated: {new Date(document.updatedAt).toLocaleString()}
        </div>
      </div>

      <div className="p-6 prose dark:prose-invert max-w-none">
        <MarkdownPreview 
          source={processedContent} 
          style={{
            backgroundColor: 'var(--background)',
            color: 'var(--foreground)',
          }}
        />
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
import { useWiki } from '@/lib/context/WikiContext';
import { Button } from "@/components/ui/button";
import { IconFileText, IconLock, IconEdit, IconTrash } from '@tabler/icons-react';

export default function WikiDocumentList() {
  const { 
    documents,
    selectedDocument,
    isUnlocked,
    selectDocument,
    deleteDocument,
    setIsEditing,
    isLoading
  } = useWiki();

  if (isLoading) {
    return (
      <div className="p-4 text-center">Loading documents...</div>
    );
  }

  const groupedDocuments = documents.reduce((acc, doc) => {
    if (!acc[doc.category]) {
      acc[doc.category] = [];
    }
    acc[doc.category].push(doc);
    return acc;
  }, {} as Record<string, typeof documents>);

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        {Object.entries(groupedDocuments).map(([category, docs]) => (
          <div key={category} className="mb-6">
            <h2 className="text-lg font-semibold mb-2">{category}</h2>
            <div className="space-y-2">
              {docs.map((doc) => (
                <div
                  key={doc.id}
                  className={`
                    border rounded-md overflow-hidden shadow-sm
                    ${doc.restricted && !isUnlocked ? 'opacity-50' : ''}
                    ${selectedDocument?.id === doc.id ? 'ring-2 ring-primary' : ''}
                  `}
                >
                  <div
                    className={`
                      flex items-center justify-between p-2
                      ${doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'}
                    `}
                    onClick={() => {
                      if (!(doc.restricted && !isUnlocked)) {
                        selectDocument(doc.id);
                      }
                    }}
                  >
                    <span className={doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'}>
                      {doc.title}
                    </span>
                    <div className="flex items-center space-x-2">
                      {doc.restricted && (
                        <IconLock size={16} className="text-warning" />
                      )}
                      {(!doc.restricted || isUnlocked) && (
                        <>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              selectDocument(doc.id);
                              setIsEditing(true);
                            }}
                          >
                            <IconEdit size={16} />
                            <span className="sr-only">Edit</span>
                          </Button>
                          {isUnlocked && (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={(e) => {
                                e.stopPropagation();
                                deleteDocument(doc.id);
                              }}
                            >
                              <IconTrash size={16} />
                              <span className="sr-only">Delete</span>
                            </Button>
                          )}
                        </>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;
    e.stopPropagation();

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        onClose();
        break;
    }
  };

  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true);
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm flex items-center justify-center"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <motion.div
              initial={{ scale: 0.95, opacity: 0, y: -20 }}
              animate={{ scale: 1, opacity: 1, y: 0 }}
              exit={{ scale: 0.95, opacity: 0, y: -20 }}
              className="w-full max-w-5xl mx-4 bg-background rounded-xl shadow-2xl overflow-hidden"
              onClick={stopPropagation}
            >
              <div className="p-6 border-b">
                <div className="relative">
                  <Input
                    ref={searchRef}
                    type="text"
                    value={inputValue}
                    onChange={handleInputChange}
                    placeholder="Search documents..."
                    className="pl-20 py-6 text-lg"
                    autoFocus
                  />
                  <Search className="w-6 h-6 absolute left-4 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                </div>
              </div>

              <div 
                ref={resultsRef}
                className="max-h-[400px] overflow-y-auto"
              >
                {searchResults.length === 0 && inputValue.trim() !== '' && (
                  <div className="p-8 text-center text-lg text-muted-foreground">
                    No results found
                  </div>
                )}
                <div className="h-auto">
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-6 min-h-[100px]",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-3 mb-2">
                        <FileText className="w-5 h-5 flex-shrink-0 text-muted-foreground" />
                        <span className="text-lg font-medium truncate">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-sm flex-shrink-0 text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-base text-muted-foreground ml-8 line-clamp-2">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="line-clamp-1">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
                {searchResults.length > 10 && (
                  <div className="p-4 text-center text-base text-muted-foreground">
                    {searchResults.length - 10} more results...
                  </div>
                )}
              </div>
            </motion.div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useCallback, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import 'easymde/dist/easymde.min.css';

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { ssr: false });

interface MarkdownEditorProps {
  documentId: number;
  initialTitle: string;
  initialContent: string;
  onSave: (title: string, content: string) => Promise<void>;
  onCancel: () => void;
}

export default function MarkdownEditor({
  documentId,
  initialTitle,
  initialContent,
  onSave,
  onCancel
}: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle);
  const [content, setContent] = useState(initialContent);
  const [isSaving, setIsSaving] = useState(false);

  // Handle Ctrl+S shortcut
  useEffect(() => {
    const handleKeyDown = async (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        await handleSave();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [title, content]);

  const handleSave = async () => {
    if (isSaving) return;
    setIsSaving(true);
    try {
      await onSave(title, content);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="Document Title"
          className="text-xl font-bold"
        />
      </div>

      <div className="flex-1">
        <SimpleMDE
          value={content}
          onChange={setContent}
          options={{
            spellChecker: false,
            status: false,
            minHeight: '400px',
            autofocus: true,
            autosave: {
              enabled: true,
              uniqueId: `document-${documentId}`,
              delay: 1000,
            },
          }}
        />
      </div>

      <div className="p-4 border-t flex justify-between items-center">
        <div className="text-sm text-muted-foreground">
          Press Ctrl + S to save
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button 
            onClick={handleSave}
            disabled={isSaving}
          >
            {isSaving ? 'Saving...' : 'Save'}
          </Button>
        </div>
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/AddDocument.tsx ===

// @/components/wiki/AddDocument.tsx
import React, { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Category, Tag } from '@/lib/types/wiki';
import { X } from 'lucide-react';

interface AddDocumentProps {
  categories: Category[];
  tags: Tag[];
  onCreateDocument: (
    title: string,
    category: string,
    restricted: boolean,
    tagIds: number[],
    content?: string
  ) => Promise<void>;
  initialCategory?: string;
  onClose?: () => void;
}

export default function AddDocument({
  categories,
  tags,
  onCreateDocument,
  initialCategory = "",
  onClose
}: AddDocumentProps) {
  const [title, setTitle] = useState("");
  const [category, setCategory] = useState(initialCategory);
  const [restricted, setRestricted] = useState(false);
  const [selectedTags, setSelectedTags] = useState<number[]>([]);

  useEffect(() => {
    setCategory(initialCategory);
  }, [initialCategory]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await onCreateDocument(title, category, restricted, selectedTags);
    setTitle("");
    setCategory("");
    setRestricted(false);
    setSelectedTags([]);
    if (onClose) onClose();
  };

  const toggleTag = (tagId: number) => {
    setSelectedTags(prev => 
      prev.includes(tagId)
        ? prev.filter(id => id !== tagId)
        : [...prev, tagId]
    );
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>

      <div>
        <Label htmlFor="category">Category</Label>
        <Select value={category} onValueChange={setCategory} required>
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            {categories.map((cat) => (
              <SelectItem key={cat.id} value={cat.id.toString()}>
                {'  '.repeat(cat.level)}{cat.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div>
        <Label>Tags</Label>
        <div className="flex flex-wrap gap-2 mt-2">
          {tags.map(tag => (
            <Badge
              key={tag.id}
              variant={selectedTags.includes(tag.id) ? "default" : "outline"}
              className="cursor-pointer"
              style={{
                backgroundColor: selectedTags.includes(tag.id) ? tag.color + '20' : 'transparent',
                borderColor: tag.color,
                color: selectedTags.includes(tag.id) ? tag.color : 'inherit'
              }}
              onClick={() => toggleTag(tag.id)}
            >
              {tag.name}
              {selectedTags.includes(tag.id) && (
                <X className="w-3 h-3 ml-1" onClick={(e) => {
                  e.stopPropagation();
                  toggleTag(tag.id);
                }} />
              )}
            </Badge>
          ))}
        </div>
      </div>

      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>

      <Button type="submit">Create Document</Button>
    </form>
  );
}
=== FILE: ./src/components/wiki/KeyboardShortcutsHelp.tsx ===

export const KeyboardShortcutsHelp = ({ shortcuts }: { shortcuts: KeyboardShortcuts }) => {
    const groupedShortcuts = Object.values(shortcuts).reduce((acc, shortcut) => {
      if (!acc[shortcut.group]) {
        acc[shortcut.group] = [];
      }
      acc[shortcut.group].push(shortcut);
      return acc;
    }, {} as Record<string, KeyBinding[]>);
  
    return (
      <div className="space-y-6">
        {Object.entries(groupedShortcuts).map(([group, bindings]) => (
          <div key={group}>
            <h3 className="text-lg font-medium mb-2">{group}</h3>
            <div className="space-y-2">
              {bindings.map((binding) => (
                <div key={binding.key} className="flex justify-between">
                  <span>{binding.description}</span>
                  <kbd className="px-2 py-1 bg-muted rounded text-sm">
                    {binding.key.split('+').map(k => k.charAt(0).toUpperCase() + k.slice(1)).join(' + ')}
                  </kbd>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    );
  };
=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface PasswordPromptModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (password: string) => void
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(password)
    setPassword('')
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <Input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter password"
            className="mb-4"
          />
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/tags.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { getTags, createTag, deleteTag, updateDocumentTags } from '@/lib/db';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const tags = await getTags();
        res.status(200).json(tags);
        break;

      case 'POST':
        const { name, color } = req.body;
        const newTag = await createTag(name, color);
        res.status(201).json(newTag);
        break;

      case 'DELETE':
        await deleteTag(Number(req.query.id));
        res.status(200).json({ message: 'Tag deleted' });
        break;

      case 'PATCH':
        const { documentId, tagIds } = req.body;
        await updateDocumentTags(documentId, tagIds);
        res.status(200).json({ message: 'Document tags updated' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'DELETE', 'PATCH']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Tag API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;

  try {
    switch (req.method) {
      case 'GET':
        if (id) {
          const document = await prisma.document.findUnique({
            where: { id: parseInt(id as string) },
          });

          if (document) {
            res.status(200).json(document);
          } else {
            res.status(404).json({ error: 'Document not found' });
          }
        } else {
          const documents = await prisma.document.findMany({
            orderBy: [
              { isPinned: 'desc' },
              { updatedAt: 'desc' }
            ],
          });
          res.status(200).json(documents);
        }
        break;

      case 'POST':
        const { title, content, restricted, category } = req.body;

        if (!title) {
          return res.status(400).json({ error: 'Title is required' });
        }

        const newDocument = await prisma.document.create({
          data: {
            title,
            content: content || '',
            restricted: restricted || false,
            category: category || 'General',
            isPinned: false,
          },
        });
        res.status(201).json(newDocument);
        break;

        case 'PUT': {
          if (!id) {
            return res.status(400).json({ error: 'Document ID is required' });
          }
        
          const updates = req.body;
          const documentId = parseInt(id as string);
        
          try {
            // First get the existing document
            const existingDoc = await prisma.document.findUnique({
              where: { id: documentId },
            });
        
            if (!existingDoc) {
              return res.status(404).json({ error: 'Document not found' });
            }
        
            // Update with merged data
            const updatedDocument = await prisma.document.update({
              where: { id: documentId },
              data: {
                title: updates.title ?? existingDoc.title,
                content: updates.content ?? existingDoc.content,
                category: updates.category ?? existingDoc.category,
                restricted: updates.restricted ?? existingDoc.restricted,
                isPinned: updates.isPinned ?? existingDoc.isPinned,
              },
            });
        
            res.status(200).json(updatedDocument);
          } catch (error) {
            console.error('Error updating document:', error);
            res.status(500).json({ error: 'Error updating document' });
          }
          break;
        }

      case 'PATCH':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        const { restricted: patchRestricted, isPinned: patchIsPinned } = req.body;

        const patchedDocument = await prisma.document.update({
          where: { id: parseInt(id as string) },
          data: {
            ...(patchRestricted !== undefined && { restricted: patchRestricted }),
            ...(patchIsPinned !== undefined && { isPinned: patchIsPinned }),
          },
        });
        res.status(200).json(patchedDocument);
        break;

      case 'DELETE':
        if (!id) {
          return res.status(400).json({ error: 'Document ID is required' });
        }

        await prisma.document.delete({
          where: { id: parseInt(id as string) },
        });
        res.status(200).json({ message: 'Document deleted successfully' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('API error:', error);
    
    // Check if it's a Prisma error
    if ((error as any).code === 'P2025') {
      return res.status(404).json({ error: 'Document not found' });
    }

    res.status(500).json({ 
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error : undefined
    });
  }
}
=== FILE: ./src/pages/api/wiki/categories.ts ===

import { NextApiRequest, NextApiResponse } from 'next';
import { getCategories, createCategory, updateCategory, deleteCategory } from '@/lib/db';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case 'GET':
        const categories = await getCategories();
        res.status(200).json(categories);
        break;

      case 'POST':
        const { name, parentId } = req.body;
        const newCategory = await createCategory(name, parentId);
        res.status(201).json(newCategory);
        break;

      case 'PUT':
        const { id, name: updateName } = req.body;
        await updateCategory(id, updateName);
        res.status(200).json({ message: 'Category updated' });
        break;

      case 'DELETE':
        await deleteCategory(Number(req.query.id));
        res.status(200).json({ message: 'Category deleted' });
        break;

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE']);
        res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Category API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
=== FILE: ./src/pages/wiki.tsx ===

import { useState } from 'react';
import { useWiki } from '@/lib/context/WikiContext';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';

export default function WikiPage() {
  // Local state for dialogs
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isSearchOpen, setIsSearchOpen] = useState(false);

  // Get everything else from context
  const {
    documents,
    selectedDocument,
    categories,
    tags,
    isEditing,
    isUnlocked,
    isLoading,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    setIsEditing,
    selectDocument,
    updateDocument,
    deleteDocument,
    createDocument,
    setIsUnlocked,
    handlePasswordSubmit
  } = useWiki();

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={[]} // You might want to handle search results properly
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={selectDocument}
        onSearch={() => {}} // Implement search handling
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={() => {}} // Implement search results handling
        setSelectedDocument={selectDocument}
        setExpandedCategories={() => {}} // Implement category expansion handling
      />
    </div>
  );

  // Helper functions
  function handleDocumentSelect(id: number) {
    selectDocument(id);
    setIsEditing(false);
  }

  function handleUnlockToggle(checked: boolean) {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }

  function canEditDocument(document: any) {
    return isUnlocked || !document.restricted;
  }
}
=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./wiki_files.txt ===


=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285
=== FILE: ./hostapps_files.txt ===


=== FILE: ./src/components/hostapps/SftpUserCreationForm.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { AlertDialog, AlertDialogAction, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog"
import { Label } from "@/components/ui/label"

interface FormData {
  username: string
  firstName: string
  lastName: string
  userType: string
  department: string
  company: string
  responsibleFirstName: string
  responsibleLastName: string
  deletionTime: string
}

interface SftpUserCreationFormProps {
  onUserCreated: () => void
}

export default function SftpUserCreationForm({ onUserCreated }: SftpUserCreationFormProps) {
  const [formData, setFormData] = useState<FormData>({
    username: '',
    firstName: '',
    lastName: '',
    userType: '',
    department: '',
    company: '',
    responsibleFirstName: '',
    responsibleLastName: '',
    deletionTime: '',
  })

  const [message, setMessage] = useState<string>('')
  const [errorDetails, setErrorDetails] = useState<string>('')
  const [isAlertOpen, setIsAlertOpen] = useState<boolean>(false)
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [isError, setIsError] = useState<boolean>(false)

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setFormData(prevData => ({ ...prevData, [name]: value }))
  }

  const handleSelectChange = (name: string, value: string) => {
    setFormData(prevData => ({ ...prevData, [name]: value }))
  }

  const handleCreateUser = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setIsError(false)
    setErrorDetails('')

    const userData = {
      username: formData.username,
      user_info: {
        "First name": formData.firstName,
        "Last name": formData.lastName,
        "User Type": formData.userType,
        ...(formData.userType === 'internal' ? {
          "Department": formData.department,
          "Email": `${formData.firstName.toLowerCase()}.${formData.lastName.toLowerCase()}@karlshamnenergi.se`,
        } : {
          "Company": formData.company,
          "Handled by department": formData.department,
          "Responsible internally first name": formData.responsibleFirstName,
          "Responsible internally last name": formData.responsibleLastName,
          "Responsible internally email": `${formData.responsibleFirstName.toLowerCase()}.${formData.responsibleLastName.toLowerCase()}@karlshamnenergi.se`,
        }),
      },
      deletion_time: formData.deletionTime,
    }

    try {
      const response = await fetch('/api/hostapps/create_user', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.details || data.error || 'Failed to create user')
      }

      setMessage(data.message || 'User created successfully')
      setIsError(false)
      setIsAlertOpen(true)
      onUserCreated()

      // Clear form on success
      setFormData({
        username: '',
        firstName: '',
        lastName: '',
        userType: '',
        department: '',
        company: '',
        responsibleFirstName: '',
        responsibleLastName: '',
        deletionTime: '',
      })
    } catch (error) {
      console.error('Error creating user:', error)
      setIsError(true)
      setMessage('Failed to create user')
      setErrorDetails((error as Error).message)
      setIsAlertOpen(true)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleCreateUser} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="username">Username</Label>
        <Input
          id="username"
          name="username"
          value={formData.username}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="firstName">First Name</Label>
        <Input
          id="firstName"
          name="firstName"
          value={formData.firstName}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="lastName">Last Name</Label>
        <Input
          id="lastName"
          name="lastName"
          value={formData.lastName}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="userType">User Type</Label>
        <Select
          name="userType"
          value={formData.userType}
          onValueChange={(value) => handleSelectChange('userType', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select User Type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="internal">Internal</SelectItem>
            <SelectItem value="external">External</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label htmlFor="department">Department</Label>
        <Select
          name="department"
          value={formData.department}
          onValueChange={(value) => handleSelectChange('department', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select Department" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="Digit">Digit</SelectItem>
            <SelectItem value="El">El</SelectItem>
            <SelectItem value="Fjarrvarme">Fjarrvarme</SelectItem>
            <SelectItem value="Marknad">Marknad</SelectItem>
            <SelectItem value="Vatten">Vatten</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {formData.userType === 'external' && (
        <>
          <div className="space-y-2">
            <Label htmlFor="company">Company</Label>
            <Input
              id="company"
              name="company"
              value={formData.company}
              onChange={handleInputChange}
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="responsibleFirstName">Responsible First Name</Label>
            <Input
              id="responsibleFirstName"
              name="responsibleFirstName"
              value={formData.responsibleFirstName}
              onChange={handleInputChange}
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="responsibleLastName">Responsible Last Name</Label>
            <Input
              id="responsibleLastName"
              name="responsibleLastName"
              value={formData.responsibleLastName}
              onChange={handleInputChange}
              required
            />
          </div>
        </>
      )}

      <div className="space-y-2">
        <Label htmlFor="deletionTime">Deletion Time</Label>
        <Select
          name="deletionTime"
          value={formData.deletionTime}
          onValueChange={(value) => handleSelectChange('deletionTime', value)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select Deletion Time" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="0">No deletion</SelectItem>
            <SelectItem value="10">10 minutes</SelectItem>
            <SelectItem value="60">1 hour</SelectItem>
            <SelectItem value="1440">1 day</SelectItem>
            <SelectItem value="43200">30 days</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? 'Creating User...' : 'Create User'}
      </Button>

      <AlertDialog open={isAlertOpen} onOpenChange={setIsAlertOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{isError ? 'Error' : 'Success'}</AlertDialogTitle>
            <AlertDialogDescription>
              {message}
              {errorDetails && (
                <div className="mt-2 text-sm text-red-600">
                  Details: {errorDetails}
                </div>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogAction onClick={() => setIsAlertOpen(false)}>Okay</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </form>
  )
}

=== FILE: ./src/components/hostapps/PasswordPrompt.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Form, FormField, FormItem, FormControl } from "@/components/ui/form"
import { toast } from "sonner"

interface PasswordPromptProps {
  isOpen: boolean
  onPasswordSubmit: (password: string) => void
  onClose: () => void
}

const formSchema = z.object({
  password: z.string().min(1, "Password is required")
})

type FormValues = z.infer<typeof formSchema>

export function PasswordPrompt({ isOpen, onPasswordSubmit, onClose }: PasswordPromptProps) {
  const [isValidating, setIsValidating] = useState(false)
  
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      password: ""
    }
  })

  const onSubmit = async (values: FormValues) => {
    try {
      setIsValidating(true)

      const response = await fetch('/api/hostapps/handbrake?action=list_files', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          password: values.password 
        })
      });

      const data = await response.json();

      if (!response.ok) {
        if (response.status === 503 || response.status === 502) {
          throw new Error('Server is currently unavailable. Please try again later.');
        }
        throw new Error(data.error || data.details || 'Invalid password');
      }

      // If we got here, the password is valid
      onPasswordSubmit(values.password);
      form.reset();
    } catch (error) {
      console.error('Password validation error:', error);
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Failed to validate password. Please try again.';
      
      toast.error(errorMessage);
    } finally {
      setIsValidating(false);
    }
  }

  const handleClose = () => {
    form.reset();
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="password">Password</Label>
                  <FormControl>
                    <Input 
                      id="password"
                      type="password" 
                      placeholder="Enter SFTP password"
                      {...field}
                      autoComplete="off"
                      disabled={isValidating}
                    />
                  </FormControl>
                </FormItem>
              )}
            />
            <div className="flex gap-2 justify-end">
              <Button 
                type="button" 
                variant="outline" 
                onClick={handleClose}
                disabled={isValidating}
              >
                Cancel
              </Button>
              <Button 
                type="submit" 
                disabled={isValidating}
              >
                {isValidating ? "Validating..." : "Continue"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/hostapps/VideoProcessorCard.tsx ===

import React from 'react'
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
import { MultiStepLoader } from "@/components/ui/multi-step-loader"
import { cn } from "@/lib/utils"
import { Repeat } from "lucide-react"

interface ProcessingState {
  isProcessing: boolean
  currentStep: number
  progress: number
  steps: {
    title: string
    description: string
  }[]
}

interface VideoProcessorCardProps {
  onClick: () => void
  processingState: ProcessingState | null
}

export function VideoProcessorCard({ onClick, processingState }: VideoProcessorCardProps) {
  return (
    <Card 
      onClick={!processingState?.isProcessing ? onClick : undefined}
      className={cn(
        "relative group hover:shadow-md transition-all duration-300",
        !processingState?.isProcessing && "cursor-pointer hover:border-primary",
        processingState?.isProcessing && "border-primary"
      )}
    >
      {processingState?.isProcessing ? (
        <>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Repeat className="h-5 w-5 animate-pulse" />
              Processing Video
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <MultiStepLoader
                steps={processingState.steps}
                currentStep={processingState.currentStep}
              />
              <div className="space-y-2">
                <Progress 
                  value={processingState.progress} 
                  className="h-2"
                />
                <div className="flex justify-between text-sm text-muted-foreground">
                  <span>
                    {processingState.steps[processingState.currentStep].title}
                  </span>
                  <span>
                    {Math.round(processingState.progress)}%
                  </span>
                </div>
              </div>
            </div>
          </CardContent>
        </>
      ) : (
        <>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Repeat className="h-5 w-5 text-mprimary" />
              Video Processor
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Convert and process video files using HandBrake
            </p>
          </CardContent>
        </>
      )}
    </Card>
  )
}
=== FILE: ./src/components/hostapps/HandbrakeProcessorForm.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { toast } from "sonner"
import { Form, FormField, FormItem, FormControl } from "@/components/ui/form"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"

interface HandbrakeProcessorFormProps {
  password: string
  onProcessingStart: (file: File, preset: number) => void
  onCancel: () => void
  presets: Array<{ name: string; path: string | null }>
}

const formSchema = z.object({
  file: z.string().min(1, "Please select a file"),
  preset: z.string().min(1, "Please select a preset")
})

type FormValues = z.infer<typeof formSchema>

export function HandbrakeProcessorForm({ 
  password, 
  onProcessingStart,
  onCancel,
  presets 
}: HandbrakeProcessorFormProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null)

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      file: "",
      preset: "0"
    }
  })

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      const file = event.target.files[0]
      setSelectedFile(file)
      form.setValue('file', file.name)
    }
  }

  const onSubmit = async (values: FormValues) => {
    if (!selectedFile) {
      toast.error("Please select a file")
      return
    }
  
    try {
      const formData = new FormData()
      formData.append('file', selectedFile)
      formData.append('password', password)
  
      onProcessingStart(selectedFile, parseInt(values.preset))
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <div className="space-y-2">
          <Label>Select File</Label>
          <Input 
            type="file" 
            onChange={handleFileSelect}
          />
        </div>

        <FormField
          control={form.control}
          name="preset"
          render={({ field }) => (
            <FormItem>
              <Label>Select Preset</Label>
              <FormControl>
                <Select
                  value={field.value}
                  onValueChange={field.onChange}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Choose a preset" />
                  </SelectTrigger>
                  <SelectContent>
                    {presets.map((preset, index) => (
                      <SelectItem key={index} value={index.toString()}>
                        {preset.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </FormControl>
            </FormItem>
          )}
        />

        <div className="flex gap-2">
          <Button type="button" variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button type="submit">
            Start Processing
          </Button>
        </div>
      </form>
    </Form>
  )
}
=== FILE: ./src/components/hostapps/PasswordPromptDialog.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { usePasswordPromptStore } from '@/pages/hostapps/videoProcessor'

export function PasswordPromptDialog() {
  const [password, setPassword] = useState("")
  const { isOpen, setIsOpen, setPassword: storePassword, reset } = usePasswordPromptStore()

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    storePassword(password)
    setPassword("")
    setIsOpen(false)
  }

  const handleClose = () => {
    setPassword("")
    reset()
  }

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) handleClose()
    }}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
          <DialogDescription>
            Please provide your SFTP password to continue.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/pages/hostapps/videoProcessor.tsx ===

// @/pages/hostapps/videoProcessor.tsx
import React, { useState, useEffect } from 'react'
import { create } from "zustand"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { HandbrakeProcessorForm } from '@/components/hostapps/HandbrakeProcessorForm'
import { toast } from "sonner"

// Types
export type ProcessingStep = {
  title: string
  description: string
}

export type ProcessingState = {
  isProcessing: boolean
  currentStep: number
  progress: number
  steps: ProcessingStep[]
}

// Password Store
interface PasswordPromptStore {
  isOpen: boolean
  password: string
  setIsOpen: (isOpen: boolean) => void
  setPassword: (password: string) => void
  reset: () => void
}

export const usePasswordPromptStore = create<PasswordPromptStore>((set) => ({
  isOpen: false,
  password: "",
  setIsOpen: (isOpen) => set({ isOpen }),
  setPassword: (password) => set({ password }),
  reset: () => set({ isOpen: false, password: "" })
}))

// Video Processing Dialog Store
interface VideoProcessorStore {
  isOpen: boolean
  processingState: ProcessingState | null
  setIsOpen: (isOpen: boolean) => void
  setProcessingState: (state: ProcessingState | null) => void
}

export const useVideoProcessorStore = create<VideoProcessorStore>((set) => ({
  isOpen: false,
  processingState: null,
  setIsOpen: (isOpen) => set({ isOpen }),
  setProcessingState: (state) => set({ processingState: state })
}))

export const PROCESSING_STEPS: ProcessingStep[] = [
  {
    title: "Uploading File",
    description: "Transferring file to SFTP server..."
  },
  {
    title: "Preparing",
    description: "Setting up HandBrake processor..."
  },
  {
    title: "Converting",
    description: "Processing video with selected preset..."
  },
  {
    title: "Finalizing",
    description: "Cleaning up and verifying output..."
  }
]

// Core processing function
type ProcessVideoParams = {
  file: File
  presetIndex: number
  sftpPassword: string
  onProgressUpdate: (state: ProcessingState) => void
  onComplete: () => void
  onError: (error: string) => void
}

async function processVideo({
  file,
  presetIndex,
  sftpPassword,
  onProgressUpdate,
  onComplete,
  onError
}: ProcessVideoParams) {
  let uploadInterval: NodeJS.Timeout
  let processInterval: NodeJS.Timeout
  let finalizationInterval: NodeJS.Timeout

  try {
    onProgressUpdate({
      isProcessing: true,
      currentStep: 0,
      progress: 0,
      steps: PROCESSING_STEPS
    })

    const formData = new FormData()
    formData.append('file', file)
    formData.append('password', sftpPassword)

    uploadInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 1, 25)
      }))
    }, 100)

    const uploadResponse = await fetch('/api/hostapps/handbrake?action=upload_file', {
      method: 'POST',
      body: formData
    })

    clearInterval(uploadInterval)

    if (!uploadResponse.ok) {
      const data = await uploadResponse.json()
      throw new Error(data.error || data.details || 'Upload failed')
    }

    onProgressUpdate({
      isProcessing: true,
      currentStep: 1,
      progress: 25,
      steps: PROCESSING_STEPS
    })

    await new Promise(resolve => setTimeout(resolve, 1500))

    onProgressUpdate({
      isProcessing: true,
      currentStep: 2,
      progress: 30,
      steps: PROCESSING_STEPS
    })

    processInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 0.5, 90)
      }))
    }, 200)

    const processResponse = await fetch('/api/hostapps/handbrake?action=process_file', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        filename: file.name,
        preset_index: presetIndex,
        password: sftpPassword
      })
    })

    clearInterval(processInterval)

    if (!processResponse.ok) {
      throw new Error('Processing failed')
    }

    onProgressUpdate({
      isProcessing: true,
      currentStep: 3,
      progress: 95,
      steps: PROCESSING_STEPS
    })

    finalizationInterval = setInterval(() => {
      onProgressUpdate((prev) => ({
        ...prev,
        progress: Math.min(prev.progress + 1, 100)
      }))
    }, 100)

    await new Promise(resolve => setTimeout(resolve, 1000))
    clearInterval(finalizationInterval)
    
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    onComplete()

  } catch (error) {
    if (uploadInterval) clearInterval(uploadInterval)
    if (processInterval) clearInterval(processInterval)
    if (finalizationInterval) clearInterval(finalizationInterval)

    onError(error instanceof Error ? error.message : "Processing failed")
  }
}

// Password Prompt Component
export function PasswordPromptDialog() {
  const [password, setPassword] = useState("")
  const { isOpen, setIsOpen, setPassword: storePassword, reset } = usePasswordPromptStore()

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    storePassword(password)
    setPassword("")
    setIsOpen(false)
  }

  const handleClose = () => {
    setPassword("")
    reset()
  }

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) handleClose()
    }}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Enter SFTP Password</DialogTitle>
          <DialogDescription>
            Please provide your SFTP password to continue.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

// Video Processor Dialog Component
export function VideoProcessorDialog() {
  const [presets, setPresets] = useState<Array<{ name: string; path: string | null }>>([])
  const { isOpen, setIsOpen, setProcessingState } = useVideoProcessorStore()

  useEffect(() => {
    if (isOpen) {
      fetchPresets()
    }
  }, [isOpen])

  const fetchPresets = async () => {
    try {
      const response = await fetch('/api/hostapps/handbrake?action=list_presets')
      const data = await response.json()
      if (data.presets) {
        setPresets(data.presets)
      }
    } catch (error) {
      toast.error("Failed to fetch presets")
    }
  }

  const handleProcessingStart = async (file: File, presetIndex: number) => {
    setIsOpen(false)
    
    try {
      await startVideoProcessing({
        file,
        presetIndex,
        onProgressUpdate: (state) => setProcessingState(state),
        onComplete: () => {
          toast.success("Video processing completed")
          setProcessingState(null)
        },
        onError: (error) => {
          toast.error(error)
          setProcessingState(null)
        }
      })
    } catch (error) {
      console.log("Processing was cancelled or failed")
    }
  }

  return (
    <Dialog 
      open={isOpen} 
      onOpenChange={(open) => {
        if (!open) {
          setIsOpen(false)
        }
      }}
    >
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Video Processor</DialogTitle>
          <DialogDescription>
            Select a video file and processing options to convert.
          </DialogDescription>
        </DialogHeader>
        <HandbrakeProcessorForm 
          presets={presets}
          onProcessingStart={handleProcessingStart}
          onCancel={() => setIsOpen(false)}
        />
      </DialogContent>
    </Dialog>
  )
}

// Helper function to open the video processor dialog
export function openVideoProcessor() {
  useVideoProcessorStore.getState().setIsOpen(true)
}

// Public interface for video processing
type StartVideoProcessingParams = {
  file: File
  presetIndex: number
  onProgressUpdate: (state: ProcessingState) => void
  onComplete: () => void
  onError: (error: string) => void
}

export function startVideoProcessing({
  file,
  presetIndex,
  onProgressUpdate,
  onComplete,
  onError
}: StartVideoProcessingParams): Promise<void> {
  return new Promise((resolve, reject) => {
    const passwordStore = usePasswordPromptStore.getState()
    passwordStore.setIsOpen(true)

    const cleanup = usePasswordPromptStore.subscribe((state) => {
      if (!state.isOpen && state.password) {
        cleanup()
        processVideo({
          file,
          presetIndex,
          sftpPassword: state.password,
          onProgressUpdate,
          onComplete: () => {
            passwordStore.reset()
            onComplete()
            resolve()
          },
          onError: (error) => {
            passwordStore.reset()
            onError(error)
            reject(error)
          }
        })
      } else if (!state.isOpen && !state.password) {
        cleanup()
        const error = "Password not provided"
        onError(error)
        reject(error)
      }
    })
  })
}
=== FILE: ./src/pages/hostapps.tsx ===

// src/pages/hostapps.tsx
import React, { useState } from 'react'
import { Card, CardHeader, CardContent, CardTitle } from "@/components/ui/card"
import SftpUserCreationForm from '@/components/hostapps/SftpUserCreationForm'
import { VideoProcessorCard } from '@/components/hostapps/VideoProcessorCard'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { UserPlus } from "lucide-react"
import { 
  openVideoProcessor, 
  VideoProcessorDialog, 
  PasswordPromptDialog, 
  useVideoProcessorStore 
} from '@/pages/hostapps/videoProcessor'

export default function HostApplications() {
  const [isSftpFormOpen, setIsSftpFormOpen] = useState(false)
  const processingState = useVideoProcessorStore((state) => state.processingState)

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Host Applications</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <Card
          onClick={() => setIsSftpFormOpen(true)}
          className="cursor-pointer hover:border-primary transition-all duration-300"
        >
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <UserPlus className="h-5 w-5" />
              Create SFTP User
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground">
              Click to create a new SFTP user
            </p>
          </CardContent>
        </Card>

        <VideoProcessorCard
          onClick={openVideoProcessor}
          processingState={processingState}
        />
      </div>

      <Dialog open={isSftpFormOpen} onOpenChange={setIsSftpFormOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Create SFTP User</DialogTitle>
            <DialogDescription>
              Fill in the details to create a new SFTP user.
            </DialogDescription>
          </DialogHeader>
          <SftpUserCreationForm onUserCreated={() => setIsSftpFormOpen(false)} />
        </DialogContent>
      </Dialog>

      <VideoProcessorDialog />
      <PasswordPromptDialog />
    </div>
  )
}
=== FILE: ./src/pages/api/hostapps/create_user.ts ===

// pages/api/create_user.ts
import type { NextApiRequest, NextApiResponse } from 'next'

const PYTHON_SERVER = process.env.NEXT_PUBLIC_SFTP_PYTHON_API_URL || 'http://172.20.96.22:5000'

interface UserInfo {
  'First name': string;
  'Last name': string;
  'User Type': string;
  Department: string;
  Email: string;
  'Responsible internally email'?: string;
}

interface UserData {
  username: string;
  user_info: UserInfo;
  deletion_time?: string;
}

async function getToken() {
  try {
    const response = await fetch(`${PYTHON_SERVER}/generate_token`)
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to get authentication token: ${error}`)
    }
    const data = await response.json()
    return data.access_token
  } catch (error) {
    console.error('Token generation error:', error)
    throw error
  }
}

function validateUserData(data: any): { isValid: boolean; error?: string } {
  if (!data) {
    return { isValid: false, error: 'No data provided' }
  }

  // Validate username
  if (!data.username || typeof data.username !== 'string') {
    return { isValid: false, error: 'Username is required and must be a string' }
  }

  if (!/^[a-z0-9-_]+$/.test(data.username)) {
    return { isValid: false, error: 'Username can only contain lowercase letters, numbers, hyphens, and underscores' }
  }

  // Validate user_info
  if (!data.user_info || typeof data.user_info !== 'object') {
    return { isValid: false, error: 'user_info is required and must be an object' }
  }

  const requiredFields = ['First name', 'Last name', 'User Type', 'Department', 'Email']
  for (const field of requiredFields) {
    if (!data.user_info[field] || typeof data.user_info[field] !== 'string') {
      return { isValid: false, error: `${field} is required in user_info and must be a string` }
    }
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(data.user_info.Email)) {
    return { isValid: false, error: 'Invalid email format' }
  }

  // Validate user type
  if (!['internal', 'external'].includes(data.user_info['User Type'].toLowerCase())) {
    return { isValid: false, error: 'User Type must be either "internal" or "external"' }
  }

  // Validate deletion_time if provided
  if (data.deletion_time !== undefined) {
    const deletion_time = parseInt(data.deletion_time)
    if (isNaN(deletion_time) || deletion_time < 0) {
      return { isValid: false, error: 'deletion_time must be a non-negative number or "0"' }
    }
  }

  return { isValid: true }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Security headers
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('X-Frame-Options', 'DENY')
  res.setHeader('X-XSS-Protection', '1; mode=block')

  // Method check
  if (req.method !== 'POST') {
    res.setHeader('Allow', ['POST'])
    return res.status(405).json({ error: 'Method not allowed' })
  }

  // Content-Type check
  if (!req.headers['content-type']?.includes('application/json')) {
    return res.status(400).json({ error: 'Content-Type must be application/json' })
  }

  try {
    const userData = req.body as UserData

    // Validate input data
    const validation = validateUserData(userData)
    if (!validation.isValid) {
      return res.status(400).json({ error: validation.error })
    }

    console.log('Attempting to get token...')
    const token = await getToken()
    console.log('Token received successfully')

    // Sanitize data before logging (remove password if present)
    const sanitizedData = { ...userData }
    if ('password' in sanitizedData) {
      delete (sanitizedData as any).password
    }
    console.log('Sending request to Python server with data:', sanitizedData)

    const response = await fetch(`${PYTHON_SERVER}/create_user`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(userData)
    })

    const data = await response.json()
    console.log('Python server response:', {
      ...data,
      // Remove sensitive data from logs
      details: data.details ? { ...data.details, password: undefined } : undefined
    })

    if (!response.ok) {
      return res.status(response.status).json({
        error: 'Python server error',
        details: data.error || data.message || 'Unknown error',
        pythonResponse: data
      })
    }

    // Success response
    res.status(200).json(data)

  } catch (error) {
    console.error('Error in create_user handler:', error)
    
    // Determine if error is network-related
    const isNetworkError = error instanceof Error && 
      (error.message.includes('fetch') || error.message.includes('network'))

    res.status(isNetworkError ? 503 : 500).json({ 
      error: isNetworkError ? 'Service temporarily unavailable' : 'Failed to create user',
      details: (error as Error).message,
      ...(process.env.NODE_ENV === 'development' && { stack: (error as Error).stack })
    })
  }
}

=== FILE: ./src/pages/api/hostapps/handbrake.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import formidable from 'formidable'
import fs from 'fs'
import path from 'path'

export const config = {
  api: {
    bodyParser: false,
  },
}

const PYTHON_SERVER = process.env.NEXT_PUBLIC_HANDBRAKE_PYTHON_API_URL || 'http://172.20.96.20:5000'

// Helper to parse JSON body
async function parseJsonBody(req: NextApiRequest) {
  const buffers = []
  for await (const chunk of req) {
    buffers.push(chunk)
  }
  const data = Buffer.concat(buffers).toString()
  try {
    return JSON.parse(data)
  } catch {
    return null
  }
}

async function getToken() {
  try {
    const response = await fetch(`${PYTHON_SERVER}/generate_token`, {
      signal: AbortSignal.timeout(5000)
    })
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to get authentication token: ${error}`)
    }
    const data = await response.json()
    return data.access_token
  } catch (error) {
    console.error('Token generation error:', error)
    if (error instanceof TypeError && error.message.includes('ECONNREFUSED')) {
      throw new Error('Unable to connect to Handbrake server. Please try again later.')
    }
    throw error
  }
}

const parseForm = async (req: NextApiRequest) => {
  const form = formidable({
    maxFileSize: 10 * 1024 * 1024 * 1024, // 10GB
    maxTotalFileSize: 10 * 1024 * 1024 * 1024, // 10GB
    allowEmptyFiles: false,
    multiples: false,
  });

  return new Promise<{ fields: formidable.Fields; files: formidable.Files }>((resolve, reject) => {
    form.parse(req, (err, fields, files) => {
      if (err) reject(err);
      resolve({ fields, files });
    });
  });
};

async function streamToBuffer(stream: fs.ReadStream): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
    stream.on('error', (err) => reject(err));
    stream.on('end', () => resolve(Buffer.concat(chunks)));
  });
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('X-Frame-Options', 'DENY')
  res.setHeader('X-XSS-Protection', '1; mode=block')

  try {
    const token = await getToken()
    console.log('Action:', req.query.action)

    switch (req.query.action) {
      case 'upload_file': {
        if (req.method !== 'POST') {
          return res.status(405).json({ error: 'Method not allowed for this action' })
        }

        try {
          const { fields, files } = await parseForm(req);
          console.log('Form data:', { fields, files });

          const fileArray = Array.isArray(files.file) ? files.file : [files.file];
          const file = fileArray[0];
          const password = fields.password as string;

          if (!password) {
            return res.status(400).json({ error: "Password is required" });
          }

          if (!file || !file.filepath) {
            console.error('No file or filepath:', file);
            return res.status(400).json({ error: "No file provided" });
          }

          console.log('Uploading file:', file.originalFilename, 'from path:', file.filepath);

          // Read file content
          const fileBuffer = await fs.promises.readFile(file.filepath);

          // Create form data for upload
          const formData = new FormData();
          formData.append('file', new Blob([fileBuffer]), file.originalFilename || 'unnamed_file');
          formData.append('password', password);

          const uploadResponse = await fetch(`${PYTHON_SERVER}/upload_file`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`
            },
            body: formData
          });

          let data;
          try {
            data = await uploadResponse.json();
          } catch (e) {
            console.error('Failed to parse upload response:', e);
            return res.status(500).json({
              error: 'Upload failed',
              details: 'Invalid server response'
            });
          }

          // Clean up temp file
          try {
            await fs.promises.unlink(file.filepath);
          } catch (e) {
            console.error('Failed to cleanup temp file:', e);
          }

          if (!uploadResponse.ok) {
            console.error('Upload failed:', data);
            return res.status(uploadResponse.status).json(data);
          }

          return res.status(200).json(data);
        } catch (error) {
          console.error('File handling error:', error);
          return res.status(500).json({ 
            error: 'Upload failed', 
            details: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      }

      case 'list_files': {
        const body = await parseJsonBody(req)
        if (!body?.password) {
          return res.status(400).json({ error: "Password is required" });
        }

        const response = await fetch(`${PYTHON_SERVER}/list_files`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            password: body.password
          })
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse list_files response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      case 'list_presets': {
        const response = await fetch(`${PYTHON_SERVER}/list_presets`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse list_presets response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      case 'process_file': {
        const body = await parseJsonBody(req)
        if (!body) {
          return res.status(400).json({ error: "Invalid request body" });
        }

        const response = await fetch(`${PYTHON_SERVER}/process_file`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          console.error('Failed to parse process_file response:', e);
          return res.status(500).json({
            error: 'Invalid response from server',
            details: 'Failed to parse server response'
          });
        }

        return res.status(response.status).json(data);
      }

      default:
        return res.status(400).json({ error: 'Invalid action' });
    }
  } catch (error) {
    console.error('Error in handbrake handler:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('ECONNREFUSED') || error.message.includes('Unable to connect')) {
        return res.status(503).json({
          error: 'Service temporarily unavailable',
          details: 'Unable to connect to Handbrake server. Please try again later.'
        });
      }
      
      if (error.message.includes('timeout')) {
        return res.status(504).json({
          error: 'Service timeout',
          details: 'Request timed out. Please try again.'
        });
      }
    }

    return res.status(500).json({
      error: 'Failed to process request',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
=== FILE: ./wiki_files.txt ===


=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import { createSearchIndex, searchDocuments } from '@/lib/search';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Document[]>([]);
  
  // Create search index whenever documents change
  const searchIndex = useMemo(() => createSearchIndex(documents), [documents]);

  const handleSearch = useCallback((query: string) => {
    if (query.trim()) {
      const results = searchDocuments(searchIndex, query);
      setSearchResults(results);
    } else {
      setSearchResults([]);
    }
  }, [searchIndex]);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  };
};
=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN
      );
    `);

    // Check if the category column exists, if not, add it
    const tableInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = tableInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }
  }
  return db;
}

export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.all('SELECT * FROM documents');
  } else {
    return db.all('SELECT * FROM documents WHERE restricted = 0');
  }
}

export async function getDocument(id: number, includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.get('SELECT * FROM documents WHERE id = ?', id);
  } else {
    return db.get('SELECT * FROM documents WHERE id = ? AND restricted = 0', id);
  }
}

export async function createDocument(title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('INSERT INTO documents (title, content, restricted, category) VALUES (?, ?, ?, ?)', title, content, restricted ? 1 : 0, category);
}

export async function updateDocument(id: number, title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('UPDATE documents SET title = ?, content = ?, restricted = ?, category = ? WHERE id = ?', title, content, restricted ? 1 : 0, category, id);
}

export async function toggleDocumentRestriction(id: number) {
  const db = await openDb();
  return db.run('UPDATE documents SET restricted = NOT restricted WHERE id = ?', id);
}

export async function getCategories() {
  const db = await openDb();
  return db.all('SELECT DISTINCT category FROM documents');
}

=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

// @/components/wiki/WikiHeader.tsx
// Manages the top navigation and controls
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";

interface WikiHeaderProps {
  isUnlocked: boolean;
  onUnlockToggle: (checked: boolean) => void;
  onAddDocument: () => void;
  onUploadDocument: () => void;
}

export const WikiHeader: React.FC<WikiHeaderProps> = ({
  isUnlocked,
  onUnlockToggle,
  onAddDocument,
  onUploadDocument
}) => (
  <div className="flex-shrink-0 p-4 bg-base-300 border-b">
    <div className="flex items-center justify-between">
      <h1 className="text-2xl font-bold">Wiki Documents</h1>
      <p className="text-[#D8DEE9]/80 mt-2">
        Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to open apps
      </p>
      <div className="flex items-center space-x-4">
        <Button onClick={onAddDocument}>Add New Page</Button>
        <Button variant="outline" onClick={onUploadDocument}>
          Upload Word Document
        </Button>
        <div className="flex items-center space-x-2">
          <Switch
            id="lock-mode"
            checked={isUnlocked}
            onCheckedChange={onUnlockToggle}
          />
          <Label htmlFor="lock-mode">
            {isUnlocked ? 'Unlocked' : 'Locked'}
          </Label>
        </div>
      </div>
    </div>
  </div>
);
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

// @/components/wiki/WikiDialogs.tsx
// Manages all modal/dialog interactions
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { cn } from "@/lib/utils";
import { motion, AnimatePresence } from 'framer-motion';

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchProps {
  onSearch: (value: string) => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  className?: string;
}

export default function WikiSearch({ onSearch, searchResults, onResultSelect, className }: WikiSearchProps) {
  const searchRef = useRef<HTMLInputElement>(null);
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState('');

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey) && e.code === 'Space') {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };

    const handleClickOutside = (e: MouseEvent) => {
      if (searchRef.current && !searchRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleClickOutside);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Function to highlight matched text
  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      // Add text before match
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      // Add highlighted match
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    // Add remaining text
    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  // Get focused context around matches
  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;  // Characters of context on each side
    const MAX_SNIPPETS = 3;   // Maximum number of snippets to show
    const MIN_GAP = 80;       // Minimum gap between snippets to show them separately

    // Sort indices by start position
    indices.sort((a, b) => a[0] - b[0]);

    let snippets: { text: string; indices: number[][] }[] = [];
    let currentSnippet = {
      start: 0,
      end: 0,
      indices: [[0, 0]],
    };

    indices.forEach((match, idx) => {
      const [start, end] = match;
      
      if (idx === 0) {
        currentSnippet = {
          start: Math.max(0, start - CONTEXT_SIZE),
          end: Math.min(content.length, end + CONTEXT_SIZE),
          indices: [match],
        };
      } else {
        // If this match is close to the previous one, extend the current snippet
        if (start - currentSnippet.end < MIN_GAP) {
          currentSnippet.end = Math.min(content.length, end + CONTEXT_SIZE);
          currentSnippet.indices.push(match);
        } else {
          // Add the current snippet and start a new one
          snippets.push({
            text: content.slice(currentSnippet.start, currentSnippet.end),
            indices: currentSnippet.indices.map(([s, e]) => [
              s - currentSnippet.start,
              e - currentSnippet.start,
            ]),
          });

          if (snippets.length >= MAX_SNIPPETS) return;

          currentSnippet = {
            start: Math.max(0, start - CONTEXT_SIZE),
            end: Math.min(content.length, end + CONTEXT_SIZE),
            indices: [match],
          };
        }
      }
    });

    // Add the last snippet if we haven't reached the maximum
    if (snippets.length < MAX_SNIPPETS) {
      snippets.push({
        text: content.slice(currentSnippet.start, currentSnippet.end),
        indices: currentSnippet.indices.map(([s, e]) => [
          s - currentSnippet.start,
          e - currentSnippet.start,
        ]),
      });
    }

    // Add ellipsis where needed
    return snippets.map((snippet, i) => ({
      text: (i > 0 ? '... ' : '') + snippet.text + (i < snippets.length - 1 ? ' ...' : ''),
      indices: snippet.indices.map(([s, e]) => [
        s + (i > 0 ? 4 : 0),
        e + (i > 0 ? 4 : 0),
      ]),
    }));
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setIsOpen(true);
  };

  return (
    <div className={cn("relative w-full", className)}>
      <Input
        ref={searchRef}
        type="text"
        value={inputValue}
        placeholder="Search documents... (Ctrl + Space)"
        onChange={handleInputChange}
        onFocus={() => setIsOpen(true)}
        className="pl-10"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && inputValue && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.slice(0, 10).map((result) => (
                <div
                  key={result.item.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    onResultSelect(result.item.id);
                    setIsOpen(false);
                    setInputValue('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">
                        {result.matches.find(m => m.key === 'title')
                          ? highlightMatches(
                              result.item.title,
                              result.matches.find(m => m.key === 'title')!.indices
                            )
                          : result.item.title}
                      </span>
                      <span className="text-xs text-muted-foreground">
                        {result.item.category}
                      </span>
                    </div>
                    {result.matches.find(m => m.key === 'content') && (
                      <div className="text-sm text-muted-foreground space-y-1">
                        {getMatchContext(
                          result.item.content,
                          result.matches.find(m => m.key === 'content')!.indices
                        ).map((snippet, i) => (
                          <div key={i} className="font-mono">
                            {highlightMatches(snippet.text, snippet.indices)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              ))}
              {searchResults.length > 10 && (
                <div className="p-2 text-center text-sm text-muted-foreground">
                  {searchResults.length - 10} more results...
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// @/components/wiki/WikiContent.tsx
// Handles document display and editing
import dynamic from 'next/dynamic';
import { Document } from '@/lib/types/wiki';
import WikiDocument from '@/components/wiki/WikiDocument';

const MarkdownEditor = dynamic(() => import('@/components/wiki/MarkdownEditor'), {
  ssr: false
});

interface WikiContentProps {
  selectedDocument: Document | null;
  isEditing: boolean;
  isUnlocked: boolean;
  onUpdateDocument: (id: number, title: string, content: string) => Promise<void>;
  setIsEditing: (value: boolean) => void;
}

export function WikiContent({
  selectedDocument,
  isEditing,
  isUnlocked,
  onUpdateDocument,
  setIsEditing
}: WikiContentProps) {
  if (!selectedDocument) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        Select a document to view its content
      </div>
    );
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <MarkdownEditor
          documentId={selectedDocument.id}
          initialTitle={selectedDocument.title}
          initialContent={selectedDocument.content}
          onSave={(title, content) => {
            onUpdateDocument(selectedDocument.id, title, content);
            setIsEditing(false);
          }}
          onCancel={() => setIsEditing(false)}
        />
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={onUpdateDocument}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React from 'react'
import MarkdownPreview from '@uiw/react-markdown-preview'
import '@uiw/react-markdown-preview/markdown.css';

interface WikiDocumentProps {
  document: {
    id: number
    title: string
    content: string
    restricted: boolean
    category: string
  }
  isUnlocked: boolean
  onDocumentUpdate: (id: number, content: string) => void
}

export default function WikiDocument({ document, isUnlocked, onDocumentUpdate }: WikiDocumentProps) {
  if (!document) {
    return <div>No document selected</div>
  }

  // Function to preprocess the Markdown content
  const preprocessMarkdown = (content: string) => {
    // Replace single line breaks with <br>, but preserve double line breaks
    return content.replace(/(?<!\n)\n(?!\n)/g, '  \n');
  };

  const processedContent = preprocessMarkdown(document.content);

  return (
    <div className="w-full h-full bg-background text-foreground">
      <h1 className="text-2xl font-bold mb-4">{document.title}</h1>
      <div className="prose dark:prose-invert max-w-none">
        <MarkdownPreview 
          source={processedContent} 
          style={{
            backgroundColor: 'var(--background)',
            color: 'var(--foreground)',
          }}
        />
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
// Handles the document tree display

import React, { useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { IconFileText, IconServer, IconDeviceDesktop, IconChevronDown, IconChevronRight, IconKey, IconEdit, IconTrash } from '@tabler/icons-react';

interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
}

interface WikiDocumentListProps {
  documents: Document[];
  onDocumentSelect: (id: number) => void;
  onEditDocument: (id: number) => void;
  onDeleteDocument: (id: number) => void;
  isUnlocked: boolean;
  onDocumentsChange: () => void;
  selectedDocumentId: number | null;
  canEditDocument: (document: Document) => boolean;
  expandedCategories: { [key: string]: boolean };
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

const categoryIcons: { [key: string]: React.ReactNode } = {
  "General": <IconFileText size={20} className="text-green transition-colors" />,
  "IT": <IconDeviceDesktop size={20} className="text-orange transition-colors" />,
  "Systems": <IconServer size={20} className="text-purple transition-colors" />,
};

export default function WikiDocumentList({
  documents,
  onDocumentSelect,
  onEditDocument,
  onDeleteDocument,
  isUnlocked,
  onDocumentsChange,
  selectedDocumentId,
  canEditDocument,
  expandedCategories,
  setExpandedCategories
}: WikiDocumentListProps) {
  const [isLoading, setIsLoading] = React.useState(true);
  const [isDeleting, setIsDeleting] = React.useState<number | null>(null);
  const [categories, setCategories] = React.useState<string[]>([]);

  useEffect(() => {
    const allCategories = [...new Set(documents.map(doc => doc.category))].sort();
    setCategories(allCategories);
    setIsLoading(false);
  }, [documents]);

  const toggleCategory = (category: string) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  };

  const handleDeleteDocument = async (id: number) => {
    if (isDeleting) return;
    setIsDeleting(id);
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        onDeleteDocument(id);
        onDocumentsChange();
      } else {
        console.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
    } finally {
      setIsDeleting(null);
    }
  };

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        <h2 className="text-xl font-bold mb-4">Categories</h2>
        {isLoading ? (
          <p>Loading categories...</p>
        ) : (
          <div className="space-y-2">
            {categories.map((category) => (
              <div key={category}>
                <Card
                  className="cursor-pointer"
                  onClick={() => toggleCategory(category)}
                >
                  <CardContent className="flex items-center justify-between p-2">
                    <div className="flex items-center">
                      {expandedCategories[category] ? <IconChevronDown size={20} /> : <IconChevronRight size={20} />}
                      <span className="font-medium ml-2">{category}</span>
                    </div>
                    <span>
                      {categoryIcons[category] || <IconFileText size={20} className="text-primary" />}
                    </span>
                  </CardContent>
                </Card>
                {expandedCategories[category] && (
                  <ul className="space-y-2 mt-2 ml-6">
                    {documents.filter(doc => doc.category === category).map((doc) => (
                      <li
                        key={doc.id}
                        className={`border rounded-md overflow-hidden shadow-sm ${
                          doc.restricted && !isUnlocked ? 'opacity-50' : ''
                        } ${selectedDocumentId === doc.id ? 'ring-2 ring-primary' : ''}`}
                      >
                        <div
                          className={`flex items-center justify-between p-2 ${
                            doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'
                          }`}
                          onClick={() => {
                            if (!(doc.restricted && !isUnlocked)) {
                              onDocumentSelect(doc.id);
                            }
                          }}
                        >
                          <span className={`${
                            doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'
                          }`}>
                            {doc.title}
                          </span>
                          <div className="flex items-center space-x-2">
                            {doc.restricted && (
                              <IconKey size={16} className="text-warning" />
                            )}
                            {canEditDocument(doc) && (
                              <>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    onEditDocument(doc.id);
                                  }}
                                >
                                  <IconEdit size={16} />
                                  <span className="sr-only">Edit</span>
                                </Button>
                                {isUnlocked && (
                                  <AlertDialog>
                                    <AlertDialogTrigger asChild>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={(e) => e.stopPropagation()}
                                      >
                                        <IconTrash size={16} />
                                        <span className="sr-only">Delete</span>
                                      </Button>
                                    </AlertDialogTrigger>
                                    <AlertDialogContent>
                                      <AlertDialogHeader>
                                        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                                        <AlertDialogDescription>
                                          This action cannot be undone. This will permanently delete the document
                                          "{doc.title}" and remove it from our servers.
                                        </AlertDialogDescription>
                                      </AlertDialogHeader>
                                      <AlertDialogFooter>
                                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                                        <AlertDialogAction 
                                          onClick={() => handleDeleteDocument(doc.id)} 
                                          disabled={isDeleting === doc.id}
                                        >
                                          {isDeleting === doc.id ? 'Deleting...' : 'Delete'}
                                        </AlertDialogAction>
                                      </AlertDialogFooter>
                                    </AlertDialogContent>
                                  </AlertDialog>
                                )}
                              </>
                            )}
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

// src/components/wiki/WikiSearchModal.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;

    e.stopPropagation(); // Prevent event bubbling

    switch (e.key) {
      case 'Tab':
        e.preventDefault();
        if (e.shiftKey) {
          setSelectedIndex(prev => 
            prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
          );
        } else {
          setSelectedIndex(prev => 
            (prev + 1) % Math.min(searchResults.length, 10)
          );
        }
        break;

      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        e.stopPropagation();
        onClose();
        break;
    }
  };

  // Add event listener for keyboard navigation
  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true); // Use capture phase
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  // Scroll selected item into view
  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  // Prevent event bubbling
  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <div className="container max-w-2xl mx-auto mt-[20vh]">
              <motion.div
                ref={modalRef}
                initial={{ scale: 0.95, opacity: 0 }}
                animate={{ scale: 1, opacity: 1 }}
                exit={{ scale: 0.95, opacity: 0 }}
                className="bg-background rounded-lg shadow-xl overflow-hidden"
                onClick={stopPropagation}
              >
                <div className="p-4 border-b">
                  <div className="relative">
                    <Input
                      ref={searchRef}
                      type="text"
                      value={inputValue}
                      onChange={handleInputChange}
                      placeholder="Search documents... (↑↓ to navigate)"
                      className="pl-10"
                      autoFocus
                    />
                    <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                  </div>
                </div>

                <div 
                  ref={resultsRef}
                  className="max-h-[60vh] overflow-y-auto"
                >
                  {searchResults.length === 0 && inputValue.trim() !== '' && (
                    <div className="p-4 text-center text-muted-foreground">
                      No results found
                    </div>
                  )}
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-3",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-2 mb-1">
                        <FileText className="w-4 h-4 text-muted-foreground" />
                        <span className="font-medium">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-xs text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-sm text-muted-foreground space-y-1">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="font-mono">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                  {searchResults.length > 10 && (
                    <div className="p-2 text-center text-sm text-muted-foreground">
                      {searchResults.length - 10} more results...
                    </div>
                  )}
                </div>

                <div className="p-3 border-t bg-muted/50">
                  <div className="flex gap-4 text-sm text-muted-foreground">
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">↑↓</kbd> to navigate
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">enter</kbd> to select
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">esc</kbd> to close
                    </span>
                  </div>
                </div>
              </motion.div>
            </div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useEffect, useCallback, useMemo } from 'react'
import dynamic from 'next/dynamic'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import 'easymde/dist/easymde.min.css'

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { ssr: false })

interface MarkdownEditorProps {
  documentId: number
  initialTitle: string
  initialContent: string
  onSave: (title: string, content: string) => void
  onCancel: () => void
}

export default function MarkdownEditor({ documentId, initialTitle, initialContent, onSave, onCancel }: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle)
  const [content, setContent] = useState(initialContent)

  useEffect(() => {
    setTitle(initialTitle)
    setContent(initialContent)
  }, [initialTitle, initialContent])

  const handleSave = useCallback(() => {
    onSave(title, content)
  }, [title, content, onSave])

  const handleTitleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value)
  }, [])

  const handleContentChange = useCallback((value: string) => {
    setContent(value)
  }, [])

  const editorOptions = useMemo(() => ({
    spellChecker: false,
    status: false,
    minHeight: '400px',
    autofocus: true,
    autosave: {
      enabled: true,
      uniqueId: `document-${documentId}`,
      delay: 1000,
    },
  }), [documentId])

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={handleTitleChange}
          placeholder="Document Title"
          className="text-xl font-bold mb-2"
        />
      </div>
      <SimpleMDE
        value={content}
        onChange={handleContentChange}
        options={editorOptions}
      />
      <div className="p-4 border-t flex justify-end space-x-2">
        <Button variant="outline" onClick={onCancel}>Cancel</Button>
        <Button onClick={handleSave}>Save</Button>
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/AddDocument.tsx ===

import React, { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"

interface AddDocumentProps {
  categories: string[]
  onCreateDocument: (title: string, category: string, restricted: boolean) => Promise<void>
  initialCategory?: string
  onClose?: () => void
}

export default function AddDocument({ categories, onCreateDocument, initialCategory = "", onClose }: AddDocumentProps) {
  const [title, setTitle] = useState("")
  const [category, setCategory] = useState(initialCategory)
  const [restricted, setRestricted] = useState(false)

  useEffect(() => {
    setCategory(initialCategory)
  }, [initialCategory])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    await onCreateDocument(title, category, restricted)
    setTitle("")
    setCategory("")
    setRestricted(false)
    if (onClose) onClose()
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>
      <div>
        <Label htmlFor="category">Category</Label>
        <Select value={category} onValueChange={setCategory} required>
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            {categories.map((cat) => (
              <SelectItem key={cat} value={cat}>
                {cat}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>
      <Button type="submit">Create Document</Button>
    </form>
  )
}

=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface PasswordPromptModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (password: string) => void
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(password)
    setPassword('')
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <Input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter password"
            className="mb-4"
          />
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query

  if (req.method === 'GET') {
    if (id) {
      const document = await prisma.document.findUnique({
        where: { id: parseInt(id as string) },
      })

      if (document) {
        res.status(200).json(document)
      } else {
        res.status(404).json({ error: 'Document not found' })
      }
    } else {
      const documents = await prisma.document.findMany({
        orderBy: { title: 'asc' },
      })
      res.status(200).json(documents)
    }
  } else if (req.method === 'POST') {
    const { title, content, restricted, category } = req.body

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.create({
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(201).json(document)
    } catch (error) {
      console.error('Error creating document:', error)
      res.status(500).json({ error: 'Error creating document' })
    }
  } else if (req.method === 'PUT') {
    const { title, content, restricted, category } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'PATCH') {
    const { restricted } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: { restricted },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'DELETE') {
    if (id) {
      try {
        await prisma.document.delete({
          where: { id: parseInt(id as string) },
        })
        res.status(200).json({ message: 'Document deleted successfully' })
      } catch (error) {
        console.error('Error deleting document:', error)
        res.status(404).json({ error: 'Document not found or could not be deleted' })
      }
    } else {
      res.status(400).json({ error: 'Document ID is required' })
    }
  } else {
    res.status(405).end() // Method Not Allowed
  }
}

=== FILE: ./src/pages/wiki.tsx ===

// @/pages/wiki.tsx
import { useState, useCallback } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';
import { useDocuments } from '@/lib/hooks/useDocuments';
import { useAuth } from '@/lib/hooks/useAuth';
import { useSearch } from '@/lib/hooks/useSearch';
import { Document } from '@/lib/types/wiki';

export default function WikiPage() {
  const {
    documents,
    categories,
    isLoading,
    createDocument,
    updateDocument,
    deleteDocument
  } = useDocuments();

  const {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  } = useAuth();

  const {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  } = useSearch(documents);

  const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState<{ [key: string]: boolean }>({});

  useHotkeys('ctrl+space', (e) => {
    e.preventDefault();
    setIsSearchOpen(true);
  }, []);

  const handleDocumentSelect = useCallback((id: number) => {
    const document = documents.find(doc => doc.id === id);
    if (document) {
      setSelectedDocument(document);
      setIsEditing(false);
    }
  }, [documents]);

  const canEditDocument = useCallback((document: Document) => {
    return isUnlocked || !document.restricted;
  }, [isUnlocked]);

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
              expandedCategories={expandedCategories}
              setExpandedCategories={setExpandedCategories}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={searchResults}
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={handleDocumentSelect}
        onSearch={handleSearch}
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={setSearchResults}
        setSelectedDocument={setSelectedDocument}
        setExpandedCategories={setExpandedCategories}
      />
    </div>
  );
}
=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./wiki_files.txt ===


=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285
=== FILE: ./hostapps_files.txt ===

