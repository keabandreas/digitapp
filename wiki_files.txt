
=== FILE: ./src/lib/hooks/useDocuments.ts ===

// @/lib/hooks/useDocuments.ts
import { useState, useCallback, useEffect } from 'react';
import { Document } from '@/lib/types/wiki';
import { toast } from 'react-hot-toast';

export const useDocuments = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [categories, setCategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchDocuments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/wiki/wiki');
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
        const allCategories = [...new Set(data.map((doc: Document) => doc.category))].sort();
        setCategories(allCategories);
      } else {
        console.error('Failed to fetch documents');
        toast.error('Failed to fetch documents');
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      toast.error('Error fetching documents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch documents on mount
  useEffect(() => {
    fetchDocuments();
  }, [fetchDocuments]);

  const createDocument = useCallback(async (title: string, category: string, restricted: boolean, content: string = '') => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, category, restricted, content }),
      });
      if (response.ok) {
        const newDocument = await response.json();
        await fetchDocuments(); // Refresh the documents list
        toast.success('Document created successfully');
        return newDocument;
      } else {
        toast.error('Failed to create document');
      }
    } catch (error) {
      console.error('Error creating document:', error);
      toast.error('Error creating document');
    }
  }, [fetchDocuments]);

  const updateDocument = useCallback(async (id: number, title: string, content: string) => {
    try {
      const response = await fetch('/api/wiki/wiki', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, title, content }),
      });
      if (response.ok) {
        const updatedDoc = await response.json();
        setDocuments(prevDocs => prevDocs.map(doc => doc.id === id ? updatedDoc : doc));
        return updatedDoc;
      } else {
        console.error('Failed to update document');
        toast.error('Failed to update document');
      }
    } catch (error) {
      console.error('Error updating document:', error);
      toast.error('Error updating document');
    }
  }, []);

  const deleteDocument = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        setDocuments(docs => docs.filter(doc => doc.id !== id));
        toast.success('Document deleted successfully');
        return true;
      } else {
        toast.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      toast.error('Error deleting document');
    }
    return false;
  }, []);

  return {
    documents,
    categories,
    isLoading,
    fetchDocuments,
    createDocument,
    updateDocument,
    deleteDocument
  };
};
=== FILE: ./src/lib/hooks/useAuth.ts ===

import { useState, useCallback } from 'react';
import { toast } from 'react-hot-toast';

export const useAuth = () => {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isPasswordPromptOpen, setIsPasswordPromptOpen] = useState(false);

  const handleUnlockToggle = useCallback((checked: boolean) => {
    if (checked && !isUnlocked) {
      setIsPasswordPromptOpen(true);
    } else if (!checked && isUnlocked) {
      setIsUnlocked(false);
    }
  }, [isUnlocked]);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    try {
      const response = await fetch('/api/wiki/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password }),
      });

      if (response.ok) {
        setIsUnlocked(true);
        setIsPasswordPromptOpen(false);
      } else {
        toast.error('Incorrect password');
      }
    } catch (error) {
      console.error('Error during authentication:', error);
      toast.error('Authentication failed');
    }
  }, []);

  return {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  };
};
=== FILE: ./src/lib/hooks/useSearch.ts ===

// @/lib/hooks/useSearch.ts
import { useState, useCallback, useMemo } from 'react';
import { Document } from '@/lib/types/wiki';
import { createSearchIndex, searchDocuments } from '@/lib/search';

export const useSearch = (documents: Document[]) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState<Document[]>([]);
  
  // Create search index whenever documents change
  const searchIndex = useMemo(() => createSearchIndex(documents), [documents]);

  const handleSearch = useCallback((query: string) => {
    if (query.trim()) {
      const results = searchDocuments(searchIndex, query);
      setSearchResults(results);
    } else {
      setSearchResults([]);
    }
  }, [searchIndex]);

  return {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  };
};
=== FILE: ./src/lib/db.ts ===

import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import path from 'path'

let db: any = null;

async function openDb() {
  if (!db) {
    const dbPath = process.env.SQLITE_DB_PATH || path.resolve('./wiki.sqlite');
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    await db.exec(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        restricted BOOLEAN
      );
    `);

    // Check if the category column exists, if not, add it
    const tableInfo = await db.all("PRAGMA table_info(documents)");
    const categoryExists = tableInfo.some((column: any) => column.name === 'category');
    if (!categoryExists) {
      await db.exec('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT "General";');
    }
  }
  return db;
}

export async function getDocuments(includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.all('SELECT * FROM documents');
  } else {
    return db.all('SELECT * FROM documents WHERE restricted = 0');
  }
}

export async function getDocument(id: number, includeRestricted: boolean) {
  const db = await openDb();
  if (includeRestricted) {
    return db.get('SELECT * FROM documents WHERE id = ?', id);
  } else {
    return db.get('SELECT * FROM documents WHERE id = ? AND restricted = 0', id);
  }
}

export async function createDocument(title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('INSERT INTO documents (title, content, restricted, category) VALUES (?, ?, ?, ?)', title, content, restricted ? 1 : 0, category);
}

export async function updateDocument(id: number, title: string, content: string, restricted: boolean, category: string) {
  const db = await openDb();
  return db.run('UPDATE documents SET title = ?, content = ?, restricted = ?, category = ? WHERE id = ?', title, content, restricted ? 1 : 0, category, id);
}

export async function toggleDocumentRestriction(id: number) {
  const db = await openDb();
  return db.run('UPDATE documents SET restricted = NOT restricted WHERE id = ?', id);
}

export async function getCategories() {
  const db = await openDb();
  return db.all('SELECT DISTINCT category FROM documents');
}

=== FILE: ./src/components/dashboard/CommandPalette.tsx ===

// src/components/dashboard/CommandPalette.tsx
import { useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Command } from 'cmdk';
import { CommandItem } from './CommandItem';
import { CommandItem as CommandItemType } from '@/components/dashboard/types';

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  onCommandSelect: (index: number) => void;
}

export const CommandPalette = ({ isOpen, onClose, onCommandSelect }: CommandPaletteProps) => {
  const [recentCommands, setRecentCommands] = useState<CommandItemType[]>([]);

  // Base commands for navigation
  const baseCommands = [
    {
      id: 'host-apps',
      name: "Host Applications",
      description: "Manage and monitor your host applications",
      shortcut: "Alt + 1",
      category: 'navigation',
      action: () => onCommandSelect(0)
    },
    {
      id: 'statistics',
      name: "Statistics",
      description: "View system statistics and analytics",
      shortcut: "Alt + 2",
      category: 'navigation',
      action: () => onCommandSelect(1)
    },
    {
      id: 'wiki',
      name: "Documentation",
      description: "Access guides and documentation",
      shortcut: "Alt + 3",
      category: 'navigation',
      action: () => onCommandSelect(2)
    }
  ];

  // Execute command and update recent commands
  const executeCommand = (command: CommandItemType) => {
    command.action();
    setRecentCommands(prev => {
      const newRecent = [command, ...prev.filter(cmd => cmd.id !== command.id)].slice(0, 5);
      return newRecent;
    });
    onClose();
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-2xl overflow-hidden rounded-xl border bg-[#3B4252] shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Command>
              <Command.List className="max-h-[300px] overflow-y-auto custom-scrollbar">
                {recentCommands.length > 0 && (
                  <Command.Group heading="Recent">
                    {recentCommands.map((cmd) => (
                      <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                    ))}
                  </Command.Group>
                )}

                <Command.Group heading="Navigation">
                  {baseCommands.map((cmd) => (
                    <CommandItem key={cmd.id} command={cmd} onSelect={() => executeCommand(cmd)} />
                  ))}
                </Command.Group>
              </Command.List>
            </Command>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default CommandPalette;
=== FILE: ./src/components/dashboard/BentoGrid.tsx ===

// src/components/dashboard/BentoGrid.tsx
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Database, BarChart3, BookOpen } from 'lucide-react';
import { cn } from "@/lib/utils";
import Window from './Window';
import ShortcutsModal from './ShortcutsModal';
import { BentoItem } from '@/components/dashboard/types';

const HostApps = dynamic(() => import('@/pages/hostapps'), { ssr: false });
const Statistics = dynamic(() => import('@/pages/statistics'), { ssr: false });
const Wiki = dynamic(() => import('@/pages/wiki'), { ssr: false });

export const BentoGrid = () => {
  const [activeWindow, setActiveWindow] = useState<BentoItem | null>(null);
  const [isShortcutsOpen, setIsShortcutsOpen] = useState(false);

  const items: BentoItem[] = [
    {
      title: "Host Applications",
      description: "Manage and monitor your host applications",
      icon: <Database className="w-6 h-6 text-info" />,
      className: "md:col-span-2",
      component: <HostApps />,
      hoverColor: "hover:bg-info/20"
    },
    {
      title: "Statistics",
      description: "View system statistics and analytics",
      icon: <BarChart3 className="w-6 h-6 text-primary" />,
      className: "row-span-2",
      component: <Statistics />,
      hoverColor: "hover:bg-primary/20"
    },
    {
      title: "Wiki",
      description: "Access documentation and guides",
      icon: <BookOpen className="w-6 h-6 text-secondary" />,
      className: "md:col-span-2",
      component: <Wiki />,
      hoverColor: "hover:bg-secondary/20"
    }
  ];

  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.altKey && !isNaN(Number(e.key))) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num > 0 && num <= items.length) {
          setActiveWindow(items[num - 1]);
        }
      }
      
      if (e.key === '?') {
        e.preventDefault();
        setIsShortcutsOpen(true);
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [items]);
  
  return (
    <>
      <div className="grid md:grid-cols-4 gap-4">
        {items.map((item, i) => (
          <motion.button 
            key={i}
            onClick={() => setActiveWindow(item)}
            className={cn(
              "group relative overflow-hidden rounded-xl border border-border",
              "bg-card/80 backdrop-blur-sm p-6",
              "transition-all duration-300",
              item.className,
              item.hoverColor
            )}
            whileHover={{ 
              scale: 1.02,
              transition: { duration: 0.2 }
            }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1 }}
          >
            <div className="relative z-10 h-full text-left">
              <motion.div 
                className="flex items-center gap-2"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.3, ease: "easeOut" }
                  }
                }}
              >
                <div className="rounded-lg p-2">
                  {item.icon}
                </div>
                <h3 className="font-semibold text-foreground">{item.title}</h3>
              </motion.div>
              <motion.p 
                className="mt-2 text-sm text-muted-foreground"
                variants={{
                  hover: {
                    x: 10,
                    transition: { duration: 0.4, ease: "easeOut", delay: 0.1 }
                  }
                }}
              >
                {item.description}
              </motion.p>
            </div>
          </motion.button>
        ))}
      </div>

      <Window 
        isOpen={!!activeWindow}
        onClose={() => setActiveWindow(null)}
        title={activeWindow?.title}
      >
        {activeWindow?.component}
      </Window>

      <ShortcutsModal 
        isOpen={isShortcutsOpen}
        onClose={() => setIsShortcutsOpen(false)}
      />
    </>
  );
};

export default BentoGrid;
=== FILE: ./src/components/wiki/WikiHeader.tsx ===

// @/components/wiki/WikiHeader.tsx
// Manages the top navigation and controls
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";

interface WikiHeaderProps {
  isUnlocked: boolean;
  onUnlockToggle: (checked: boolean) => void;
  onAddDocument: () => void;
  onUploadDocument: () => void;
}

export const WikiHeader: React.FC<WikiHeaderProps> = ({
  isUnlocked,
  onUnlockToggle,
  onAddDocument,
  onUploadDocument
}) => (
  <div className="flex-shrink-0 p-4 bg-base-300 border-b">
    <div className="flex items-center justify-between">
      <h1 className="text-2xl font-bold">Wiki Documents</h1>
      <p className="text-[#D8DEE9]/80 mt-2">
        Press <kbd className="px-1.5 py-0.5 rounded bg-[#4C566A] text-sm">Ctrl + Space</kbd> to open apps
      </p>
      <div className="flex items-center space-x-4">
        <Button onClick={onAddDocument}>Add New Page</Button>
        <Button variant="outline" onClick={onUploadDocument}>
          Upload Word Document
        </Button>
        <div className="flex items-center space-x-2">
          <Switch
            id="lock-mode"
            checked={isUnlocked}
            onCheckedChange={onUnlockToggle}
          />
          <Label htmlFor="lock-mode">
            {isUnlocked ? 'Unlocked' : 'Locked'}
          </Label>
        </div>
      </div>
    </div>
  </div>
);
=== FILE: ./src/components/wiki/WikiDialogs.tsx ===

// @/components/wiki/WikiDialogs.tsx
// Manages all modal/dialog interactions
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { PasswordPromptModal } from '@/components/wiki/PasswordPromptModal';
import AddDocument from '@/components/wiki/AddDocument';
import { FileUpload } from '@/components/wiki/FileUpload';
import WikiSearchModal from '@/components/wiki/WikiSearchModal';
import { Document } from '@/lib/types/wiki';

interface WikiDialogsProps {
  isPasswordPromptOpen: boolean;
  isAddDocumentOpen: boolean;
  isUploadDialogOpen: boolean;
  isSearchOpen: boolean;
  searchResults: any[];
  categories: string[];
  documents: Document[];
  onPasswordSubmit: (password: string) => Promise<void>;
  onCreateDocument: (title: string, category: string, restricted: boolean, content: string) => Promise<void>;
  onDocumentSelect: (id: number) => void;
  onSearch: (query: string) => void;
  setIsPasswordPromptOpen: (value: boolean) => void;
  setIsAddDocumentOpen: (value: boolean) => void;
  setIsUploadDialogOpen: (value: boolean) => void;
  setIsSearchOpen: (value: boolean) => void;
  setSearchResults: (results: any[]) => void;
  setSelectedDocument: (doc: Document | null) => void;
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

export function WikiDialogs({
  isPasswordPromptOpen,
  isAddDocumentOpen,
  isUploadDialogOpen,
  isSearchOpen,
  searchResults,
  categories,
  documents,
  onPasswordSubmit,
  onCreateDocument,
  onDocumentSelect,
  onSearch,
  setIsPasswordPromptOpen,
  setIsAddDocumentOpen,
  setIsUploadDialogOpen,
  setIsSearchOpen,
  setSearchResults,
  setSelectedDocument,
  setExpandedCategories
}: WikiDialogsProps) {
  return (
    <>
      <PasswordPromptModal
        isOpen={isPasswordPromptOpen}
        onClose={() => setIsPasswordPromptOpen(false)}
        onSubmit={onPasswordSubmit}
      />

      <WikiSearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
          setSearchResults([]);
        }}
        searchResults={searchResults}
        onResultSelect={onDocumentSelect}
        expandToDocument={(id) => {
          const document = documents.find(doc => doc.id === id);
          if (document) {
            setExpandedCategories(prev => ({
              ...prev,
              [document.category]: true
            }));
          }
        }}
        onSearch={onSearch}
      />

      <Dialog open={isAddDocumentOpen} onOpenChange={setIsAddDocumentOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Page</DialogTitle>
          </DialogHeader>
          <AddDocument
            categories={categories}
            onCreateDocument={async (title, category, restricted, content) => {
              await onCreateDocument(title, category, restricted, content);
              setIsAddDocumentOpen(false);
            }}
            onClose={() => setIsAddDocumentOpen(false)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upload Word Document</DialogTitle>
          </DialogHeader>
          <FileUpload
            onFileProcessed={async (data) => {
              await onCreateDocument(
                data.title,
                data.category,
                data.restricted,
                data.content
              );
              setIsUploadDialogOpen(false);
            }}
          />
        </DialogContent>
      </Dialog>
    </>
  );
}
=== FILE: ./src/components/wiki/FileUpload.tsx ===

import React, { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDropzone } from 'react-dropzone'
import { toast } from 'react-hot-toast'

interface FileUploadProps {
  onFileProcessed: (data: {
    title: string,
    content: string,
    category: string,
    restricted: boolean
  }) => void
}

export const FileUpload: React.FC<FileUploadProps> = ({ onFileProcessed }) => {
  const [file, setFile] = useState<File | null>(null)
  const [title, setTitle] = useState('')
  const [category, setCategory] = useState('General')
  const [restricted, setRestricted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)

  const { getRootProps, getInputProps } = useDropzone({
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        const uploadedFile = acceptedFiles[0]
        setFile(uploadedFile)
        setTitle(uploadedFile.name.replace(/\.[^/.]+$/, "")) // Remove file extension
      }
    },
    multiple: false,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/msword': ['.doc']
    }
  })

  const handleUpload = async () => {
    if (!file) return

    setIsProcessing(true)
    const formData = new FormData()
    formData.append('file', file)

    try {
      const response = await fetch('/api/statistics/convert-docx', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Upload failed')
      }

      const data = await response.json()
      
      onFileProcessed({
        title,
        content: data.content,
        category,
        restricted
      })

      toast.success('File uploaded and converted successfully')
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <div className="space-y-4">
      <div {...getRootProps()} className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer">
        <input {...getInputProps()} />
        <p>{file ? file.name : "Drag 'n' drop a Word file here, or click to select one"}</p>
      </div>
      {file && (
        <>
          <div>
            <Label htmlFor="title">Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>
          <div>
            <Label htmlFor="category">Category</Label>
            <Select value={category} onValueChange={setCategory}>
              <SelectTrigger>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="General">General</SelectItem>
                <SelectItem value="IT">IT</SelectItem>
                <SelectItem value="Systems">Systems</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="flex items-center space-x-2">
            <Switch id="restricted" checked={restricted} onCheckedChange={setRestricted} />
            <Label htmlFor="restricted">Restricted</Label>
          </div>
          <Button onClick={handleUpload} disabled={isProcessing}>
            {isProcessing ? 'Processing...' : 'Upload and Process'}
          </Button>
        </>
      )}
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiSearch.tsx ===

// src/components/wiki/WikiSearch.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { cn } from "@/lib/utils";
import { motion, AnimatePresence } from 'framer-motion';

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchProps {
  onSearch: (value: string) => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  className?: string;
}

export default function WikiSearch({ onSearch, searchResults, onResultSelect, className }: WikiSearchProps) {
  const searchRef = useRef<HTMLInputElement>(null);
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState('');

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey) && e.code === 'Space') {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };

    const handleClickOutside = (e: MouseEvent) => {
      if (searchRef.current && !searchRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleClickOutside);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Function to highlight matched text
  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      // Add text before match
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      // Add highlighted match
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    // Add remaining text
    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  // Get focused context around matches
  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;  // Characters of context on each side
    const MAX_SNIPPETS = 3;   // Maximum number of snippets to show
    const MIN_GAP = 80;       // Minimum gap between snippets to show them separately

    // Sort indices by start position
    indices.sort((a, b) => a[0] - b[0]);

    let snippets: { text: string; indices: number[][] }[] = [];
    let currentSnippet = {
      start: 0,
      end: 0,
      indices: [[0, 0]],
    };

    indices.forEach((match, idx) => {
      const [start, end] = match;
      
      if (idx === 0) {
        currentSnippet = {
          start: Math.max(0, start - CONTEXT_SIZE),
          end: Math.min(content.length, end + CONTEXT_SIZE),
          indices: [match],
        };
      } else {
        // If this match is close to the previous one, extend the current snippet
        if (start - currentSnippet.end < MIN_GAP) {
          currentSnippet.end = Math.min(content.length, end + CONTEXT_SIZE);
          currentSnippet.indices.push(match);
        } else {
          // Add the current snippet and start a new one
          snippets.push({
            text: content.slice(currentSnippet.start, currentSnippet.end),
            indices: currentSnippet.indices.map(([s, e]) => [
              s - currentSnippet.start,
              e - currentSnippet.start,
            ]),
          });

          if (snippets.length >= MAX_SNIPPETS) return;

          currentSnippet = {
            start: Math.max(0, start - CONTEXT_SIZE),
            end: Math.min(content.length, end + CONTEXT_SIZE),
            indices: [match],
          };
        }
      }
    });

    // Add the last snippet if we haven't reached the maximum
    if (snippets.length < MAX_SNIPPETS) {
      snippets.push({
        text: content.slice(currentSnippet.start, currentSnippet.end),
        indices: currentSnippet.indices.map(([s, e]) => [
          s - currentSnippet.start,
          e - currentSnippet.start,
        ]),
      });
    }

    // Add ellipsis where needed
    return snippets.map((snippet, i) => ({
      text: (i > 0 ? '... ' : '') + snippet.text + (i < snippets.length - 1 ? ' ...' : ''),
      indices: snippet.indices.map(([s, e]) => [
        s + (i > 0 ? 4 : 0),
        e + (i > 0 ? 4 : 0),
      ]),
    }));
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setIsOpen(true);
  };

  return (
    <div className={cn("relative w-full", className)}>
      <Input
        ref={searchRef}
        type="text"
        value={inputValue}
        placeholder="Search documents... (Ctrl + Space)"
        onChange={handleInputChange}
        onFocus={() => setIsOpen(true)}
        className="pl-10"
      />
      <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />

      <AnimatePresence>
        {isOpen && searchResults.length > 0 && inputValue && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute z-50 w-full mt-2 bg-background border rounded-lg shadow-lg overflow-hidden"
          >
            <div className="max-h-[60vh] overflow-y-auto">
              {searchResults.slice(0, 10).map((result) => (
                <div
                  key={result.item.id}
                  className="border-b last:border-b-0 hover:bg-muted/50 cursor-pointer"
                  onClick={() => {
                    onResultSelect(result.item.id);
                    setIsOpen(false);
                    setInputValue('');
                  }}
                >
                  <div className="p-3">
                    <div className="flex items-center gap-2 mb-1">
                      <FileText className="w-4 h-4 text-muted-foreground" />
                      <span className="font-medium">
                        {result.matches.find(m => m.key === 'title')
                          ? highlightMatches(
                              result.item.title,
                              result.matches.find(m => m.key === 'title')!.indices
                            )
                          : result.item.title}
                      </span>
                      <span className="text-xs text-muted-foreground">
                        {result.item.category}
                      </span>
                    </div>
                    {result.matches.find(m => m.key === 'content') && (
                      <div className="text-sm text-muted-foreground space-y-1">
                        {getMatchContext(
                          result.item.content,
                          result.matches.find(m => m.key === 'content')!.indices
                        ).map((snippet, i) => (
                          <div key={i} className="font-mono">
                            {highlightMatches(snippet.text, snippet.indices)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              ))}
              {searchResults.length > 10 && (
                <div className="p-2 text-center text-sm text-muted-foreground">
                  {searchResults.length - 10} more results...
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiContent.tsx ===

// @/components/wiki/WikiContent.tsx
// Handles document display and editing
import dynamic from 'next/dynamic';
import { Document } from '@/lib/types/wiki';
import WikiDocument from '@/components/wiki/WikiDocument';

const MarkdownEditor = dynamic(() => import('@/components/wiki/MarkdownEditor'), {
  ssr: false
});

interface WikiContentProps {
  selectedDocument: Document | null;
  isEditing: boolean;
  isUnlocked: boolean;
  onUpdateDocument: (id: number, title: string, content: string) => Promise<void>;
  setIsEditing: (value: boolean) => void;
}

export function WikiContent({
  selectedDocument,
  isEditing,
  isUnlocked,
  onUpdateDocument,
  setIsEditing
}: WikiContentProps) {
  if (!selectedDocument) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground">
        Select a document to view its content
      </div>
    );
  }

  if (isEditing) {
    return (
      <div className="h-full flex flex-col">
        <MarkdownEditor
          documentId={selectedDocument.id}
          initialTitle={selectedDocument.title}
          initialContent={selectedDocument.content}
          onSave={(title, content) => {
            onUpdateDocument(selectedDocument.id, title, content);
            setIsEditing(false);
          }}
          onCancel={() => setIsEditing(false)}
        />
      </div>
    );
  }

  return (
    <div className="p-4">
      <WikiDocument
        document={selectedDocument}
        isUnlocked={isUnlocked}
        onDocumentUpdate={onUpdateDocument}
      />
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiDocument.tsx ===

import React from 'react'
import MarkdownPreview from '@uiw/react-markdown-preview'
import '@uiw/react-markdown-preview/markdown.css';

interface WikiDocumentProps {
  document: {
    id: number
    title: string
    content: string
    restricted: boolean
    category: string
  }
  isUnlocked: boolean
  onDocumentUpdate: (id: number, content: string) => void
}

export default function WikiDocument({ document, isUnlocked, onDocumentUpdate }: WikiDocumentProps) {
  if (!document) {
    return <div>No document selected</div>
  }

  // Function to preprocess the Markdown content
  const preprocessMarkdown = (content: string) => {
    // Replace single line breaks with <br>, but preserve double line breaks
    return content.replace(/(?<!\n)\n(?!\n)/g, '  \n');
  };

  const processedContent = preprocessMarkdown(document.content);

  return (
    <div className="w-full h-full bg-background text-foreground">
      <h1 className="text-2xl font-bold mb-4">{document.title}</h1>
      <div className="prose dark:prose-invert max-w-none">
        <MarkdownPreview 
          source={processedContent} 
          style={{
            backgroundColor: 'var(--background)',
            color: 'var(--foreground)',
          }}
        />
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/WikiDocumentList.tsx ===

// src/components/wiki/WikiDocumentList.tsx
// Handles the document tree display

import React, { useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { IconFileText, IconServer, IconDeviceDesktop, IconChevronDown, IconChevronRight, IconKey, IconEdit, IconTrash } from '@tabler/icons-react';

interface Document {
  id: number;
  title: string;
  content: string;
  restricted: boolean;
  category: string;
}

interface WikiDocumentListProps {
  documents: Document[];
  onDocumentSelect: (id: number) => void;
  onEditDocument: (id: number) => void;
  onDeleteDocument: (id: number) => void;
  isUnlocked: boolean;
  onDocumentsChange: () => void;
  selectedDocumentId: number | null;
  canEditDocument: (document: Document) => boolean;
  expandedCategories: { [key: string]: boolean };
  setExpandedCategories: (categories: { [key: string]: boolean }) => void;
}

const categoryIcons: { [key: string]: React.ReactNode } = {
  "General": <IconFileText size={20} className="text-green transition-colors" />,
  "IT": <IconDeviceDesktop size={20} className="text-orange transition-colors" />,
  "Systems": <IconServer size={20} className="text-purple transition-colors" />,
};

export default function WikiDocumentList({
  documents,
  onDocumentSelect,
  onEditDocument,
  onDeleteDocument,
  isUnlocked,
  onDocumentsChange,
  selectedDocumentId,
  canEditDocument,
  expandedCategories,
  setExpandedCategories
}: WikiDocumentListProps) {
  const [isLoading, setIsLoading] = React.useState(true);
  const [isDeleting, setIsDeleting] = React.useState<number | null>(null);
  const [categories, setCategories] = React.useState<string[]>([]);

  useEffect(() => {
    const allCategories = [...new Set(documents.map(doc => doc.category))].sort();
    setCategories(allCategories);
    setIsLoading(false);
  }, [documents]);

  const toggleCategory = (category: string) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  };

  const handleDeleteDocument = async (id: number) => {
    if (isDeleting) return;
    setIsDeleting(id);
    try {
      const response = await fetch(`/api/wiki/wiki?id=${id}`, {
        method: 'DELETE',
      });
      if (response.ok) {
        onDeleteDocument(id);
        onDocumentsChange();
      } else {
        console.error('Failed to delete document');
      }
    } catch (error) {
      console.error('Error deleting document:', error);
    } finally {
      setIsDeleting(null);
    }
  };

  return (
    <div className="h-full overflow-auto">
      <div className="p-4">
        <h2 className="text-xl font-bold mb-4">Categories</h2>
        {isLoading ? (
          <p>Loading categories...</p>
        ) : (
          <div className="space-y-2">
            {categories.map((category) => (
              <div key={category}>
                <Card
                  className="cursor-pointer"
                  onClick={() => toggleCategory(category)}
                >
                  <CardContent className="flex items-center justify-between p-2">
                    <div className="flex items-center">
                      {expandedCategories[category] ? <IconChevronDown size={20} /> : <IconChevronRight size={20} />}
                      <span className="font-medium ml-2">{category}</span>
                    </div>
                    <span>
                      {categoryIcons[category] || <IconFileText size={20} className="text-primary" />}
                    </span>
                  </CardContent>
                </Card>
                {expandedCategories[category] && (
                  <ul className="space-y-2 mt-2 ml-6">
                    {documents.filter(doc => doc.category === category).map((doc) => (
                      <li
                        key={doc.id}
                        className={`border rounded-md overflow-hidden shadow-sm ${
                          doc.restricted && !isUnlocked ? 'opacity-50' : ''
                        } ${selectedDocumentId === doc.id ? 'ring-2 ring-primary' : ''}`}
                      >
                        <div
                          className={`flex items-center justify-between p-2 ${
                            doc.restricted && !isUnlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:bg-accent/50'
                          }`}
                          onClick={() => {
                            if (!(doc.restricted && !isUnlocked)) {
                              onDocumentSelect(doc.id);
                            }
                          }}
                        >
                          <span className={`${
                            doc.restricted && !isUnlocked ? 'text-muted-foreground' : 'text-foreground'
                          }`}>
                            {doc.title}
                          </span>
                          <div className="flex items-center space-x-2">
                            {doc.restricted && (
                              <IconKey size={16} className="text-warning" />
                            )}
                            {canEditDocument(doc) && (
                              <>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    onEditDocument(doc.id);
                                  }}
                                >
                                  <IconEdit size={16} />
                                  <span className="sr-only">Edit</span>
                                </Button>
                                {isUnlocked && (
                                  <AlertDialog>
                                    <AlertDialogTrigger asChild>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={(e) => e.stopPropagation()}
                                      >
                                        <IconTrash size={16} />
                                        <span className="sr-only">Delete</span>
                                      </Button>
                                    </AlertDialogTrigger>
                                    <AlertDialogContent>
                                      <AlertDialogHeader>
                                        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                                        <AlertDialogDescription>
                                          This action cannot be undone. This will permanently delete the document
                                          "{doc.title}" and remove it from our servers.
                                        </AlertDialogDescription>
                                      </AlertDialogHeader>
                                      <AlertDialogFooter>
                                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                                        <AlertDialogAction 
                                          onClick={() => handleDeleteDocument(doc.id)} 
                                          disabled={isDeleting === doc.id}
                                        >
                                          {isDeleting === doc.id ? 'Deleting...' : 'Delete'}
                                        </AlertDialogAction>
                                      </AlertDialogFooter>
                                    </AlertDialogContent>
                                  </AlertDialog>
                                )}
                              </>
                            )}
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
=== FILE: ./src/components/wiki/WikiSearchModal.tsx ===

// src/components/wiki/WikiSearchModal.tsx
import React, { useEffect, useRef, useState } from 'react';
import { Input } from "@/components/ui/input";
import { Search, FileText } from "lucide-react";
import { motion, AnimatePresence } from 'framer-motion';
import FocusLock from 'react-focus-lock';
import { cn } from "@/lib/utils";

interface SearchResult {
  item: {
    id: number;
    title: string;
    content: string;
    category: string;
  };
  matches: Array<{
    key: string;
    value: string;
    indices: number[][];
  }>;
  score: number;
}

interface WikiSearchModalProps {
  isOpen: boolean;
  onClose: () => void;
  searchResults: SearchResult[];
  onResultSelect: (id: number) => void;
  expandToDocument?: (id: number) => void;
  onSearch: (query: string) => void;
}

export default function WikiSearchModal({
  isOpen,
  onClose,
  searchResults,
  onResultSelect,
  expandToDocument,
  onSearch
}: WikiSearchModalProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [inputValue, setInputValue] = useState('');
  const searchRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setInputValue('');
      setSelectedIndex(0);
      searchRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!isOpen) return;

    e.stopPropagation(); // Prevent event bubbling

    switch (e.key) {
      case 'Tab':
        e.preventDefault();
        if (e.shiftKey) {
          setSelectedIndex(prev => 
            prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
          );
        } else {
          setSelectedIndex(prev => 
            (prev + 1) % Math.min(searchResults.length, 10)
          );
        }
        break;

      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          (prev + 1) % Math.min(searchResults.length, 10)
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev === 0 ? Math.min(searchResults.length - 1, 9) : prev - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (searchResults.length > 0 && selectedIndex >= 0) {
          const result = searchResults[selectedIndex];
          if (result) {
            onResultSelect(result.item.id);
            expandToDocument?.(result.item.id);
            onClose();
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        e.stopPropagation();
        onClose();
        break;
    }
  };

  // Add event listener for keyboard navigation
  useEffect(() => {
    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown, true); // Use capture phase
      return () => window.removeEventListener('keydown', handleKeyDown, true);
    }
  }, [isOpen, searchResults.length, selectedIndex]);

  // Scroll selected item into view
  useEffect(() => {
    if (resultsRef.current) {
      const selectedElement = resultsRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
  }, [selectedIndex]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    onSearch(value);
    setSelectedIndex(0);
  };

  // Prevent event bubbling
  const stopPropagation = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const highlightMatches = (text: string, indices: number[][]) => {
    let result = [];
    let lastIndex = 0;

    indices.forEach(([start, end]) => {
      if (start > lastIndex) {
        result.push(<span key={`text-${start}`}>{text.slice(lastIndex, start)}</span>);
      }
      result.push(
        <span key={`highlight-${start}`} className="bg-yellow-200 text-black font-medium">
          {text.slice(start, end + 1)}
        </span>
      );
      lastIndex = end + 1;
    });

    if (lastIndex < text.length) {
      result.push(<span key={`text-end`}>{text.slice(lastIndex)}</span>);
    }

    return result;
  };

  const getMatchContext = (content: string, indices: number[][]) => {
    const CONTEXT_SIZE = 40;
    const MAX_SNIPPETS = 3;

    let snippets: { text: string; indices: number[][] }[] = [];
    
    indices.sort((a, b) => a[0] - b[0]);

    for (let i = 0; i < indices.length && snippets.length < MAX_SNIPPETS; i++) {
      const [start, end] = indices[i];
      const snippetStart = Math.max(0, start - CONTEXT_SIZE);
      const snippetEnd = Math.min(content.length, end + CONTEXT_SIZE);
      
      let snippet = content.slice(snippetStart, snippetEnd);
      
      if (snippetStart > 0) snippet = '...' + snippet;
      if (snippetEnd < content.length) snippet = snippet + '...';
      
      snippets.push({
        text: snippet,
        indices: [[
          start - snippetStart + (snippetStart > 0 ? 3 : 0),
          end - snippetStart + (snippetStart > 0 ? 3 : 0)
        ]]
      });
    }

    return snippets;
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm"
          onClick={onClose}
        >
          <FocusLock returnFocus>
            <div className="container max-w-2xl mx-auto mt-[20vh]">
              <motion.div
                ref={modalRef}
                initial={{ scale: 0.95, opacity: 0 }}
                animate={{ scale: 1, opacity: 1 }}
                exit={{ scale: 0.95, opacity: 0 }}
                className="bg-background rounded-lg shadow-xl overflow-hidden"
                onClick={stopPropagation}
              >
                <div className="p-4 border-b">
                  <div className="relative">
                    <Input
                      ref={searchRef}
                      type="text"
                      value={inputValue}
                      onChange={handleInputChange}
                      placeholder="Search documents... ( to navigate)"
                      className="pl-10"
                      autoFocus
                    />
                    <Search className="w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
                  </div>
                </div>

                <div 
                  ref={resultsRef}
                  className="max-h-[60vh] overflow-y-auto"
                >
                  {searchResults.length === 0 && inputValue.trim() !== '' && (
                    <div className="p-4 text-center text-muted-foreground">
                      No results found
                    </div>
                  )}
                  {searchResults.slice(0, 10).map((result, index) => (
                    <div
                      key={result.item.id}
                      className={cn(
                        "border-b last:border-b-0 hover:bg-muted/50 cursor-pointer p-3",
                        selectedIndex === index && "bg-muted"
                      )}
                      onClick={() => {
                        onResultSelect(result.item.id);
                        expandToDocument?.(result.item.id);
                        onClose();
                      }}
                    >
                      <div className="flex items-center gap-2 mb-1">
                        <FileText className="w-4 h-4 text-muted-foreground" />
                        <span className="font-medium">
                          {result.matches.find(m => m.key === 'title')
                            ? highlightMatches(
                                result.item.title,
                                result.matches.find(m => m.key === 'title')!.indices
                              )
                            : result.item.title}
                        </span>
                        <span className="text-xs text-muted-foreground">
                          {result.item.category}
                        </span>
                      </div>
                      {result.matches.find(m => m.key === 'content') && (
                        <div className="text-sm text-muted-foreground space-y-1">
                          {getMatchContext(
                            result.item.content,
                            result.matches.find(m => m.key === 'content')!.indices
                          ).map((snippet, i) => (
                            <div key={i} className="font-mono">
                              {highlightMatches(snippet.text, snippet.indices)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                  {searchResults.length > 10 && (
                    <div className="p-2 text-center text-sm text-muted-foreground">
                      {searchResults.length - 10} more results...
                    </div>
                  )}
                </div>

                <div className="p-3 border-t bg-muted/50">
                  <div className="flex gap-4 text-sm text-muted-foreground">
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20"></kbd> to navigate
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">enter</kbd> to select
                    </span>
                    <span>
                      <kbd className="px-2 py-1 rounded bg-muted-foreground/20">esc</kbd> to close
                    </span>
                  </div>
                </div>
              </motion.div>
            </div>
          </FocusLock>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
=== FILE: ./src/components/wiki/MarkdownEditor.tsx ===

import React, { useState, useEffect, useCallback, useMemo } from 'react'
import dynamic from 'next/dynamic'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import 'easymde/dist/easymde.min.css'

const SimpleMDE = dynamic(() => import('react-simplemde-editor'), { ssr: false })

interface MarkdownEditorProps {
  documentId: number
  initialTitle: string
  initialContent: string
  onSave: (title: string, content: string) => void
  onCancel: () => void
}

export default function MarkdownEditor({ documentId, initialTitle, initialContent, onSave, onCancel }: MarkdownEditorProps) {
  const [title, setTitle] = useState(initialTitle)
  const [content, setContent] = useState(initialContent)

  useEffect(() => {
    setTitle(initialTitle)
    setContent(initialContent)
  }, [initialTitle, initialContent])

  const handleSave = useCallback(() => {
    onSave(title, content)
  }, [title, content, onSave])

  const handleTitleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value)
  }, [])

  const handleContentChange = useCallback((value: string) => {
    setContent(value)
  }, [])

  const editorOptions = useMemo(() => ({
    spellChecker: false,
    status: false,
    minHeight: '400px',
    autofocus: true,
    autosave: {
      enabled: true,
      uniqueId: `document-${documentId}`,
      delay: 1000,
    },
  }), [documentId])

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input
          type="text"
          value={title}
          onChange={handleTitleChange}
          placeholder="Document Title"
          className="text-xl font-bold mb-2"
        />
      </div>
      <SimpleMDE
        value={content}
        onChange={handleContentChange}
        options={editorOptions}
      />
      <div className="p-4 border-t flex justify-end space-x-2">
        <Button variant="outline" onClick={onCancel}>Cancel</Button>
        <Button onClick={handleSave}>Save</Button>
      </div>
    </div>
  )
}

=== FILE: ./src/components/wiki/AddDocument.tsx ===

import React, { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"

interface AddDocumentProps {
  categories: string[]
  onCreateDocument: (title: string, category: string, restricted: boolean) => Promise<void>
  initialCategory?: string
  onClose?: () => void
}

export default function AddDocument({ categories, onCreateDocument, initialCategory = "", onClose }: AddDocumentProps) {
  const [title, setTitle] = useState("")
  const [category, setCategory] = useState(initialCategory)
  const [restricted, setRestricted] = useState(false)

  useEffect(() => {
    setCategory(initialCategory)
  }, [initialCategory])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    await onCreateDocument(title, category, restricted)
    setTitle("")
    setCategory("")
    setRestricted(false)
    if (onClose) onClose()
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <Label htmlFor="title">Title</Label>
        <Input
          id="title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>
      <div>
        <Label htmlFor="category">Category</Label>
        <Select value={category} onValueChange={setCategory} required>
          <SelectTrigger>
            <SelectValue placeholder="Select a category" />
          </SelectTrigger>
          <SelectContent>
            {categories.map((cat) => (
              <SelectItem key={cat} value={cat}>
                {cat}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
      <div className="flex items-center space-x-2">
        <Switch
          id="restricted"
          checked={restricted}
          onCheckedChange={setRestricted}
        />
        <Label htmlFor="restricted">Restricted</Label>
      </div>
      <Button type="submit">Create Document</Button>
    </form>
  )
}

=== FILE: ./src/components/wiki/PasswordPromptModal.tsx ===

import React, { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

interface PasswordPromptModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (password: string) => void
}

export function PasswordPromptModal({ isOpen, onClose, onSubmit }: PasswordPromptModalProps) {
  const [password, setPassword] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(password)
    setPassword('')
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enter Password</DialogTitle>
          <DialogDescription>
            Please enter the password to unlock the wiki.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <Input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter password"
            className="mb-4"
          />
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Submit</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}

=== FILE: ./src/components/ui/sidebar.tsx ===

"use client";

import React, { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHome, IconFileText, IconFolder, IconSettings, IconChevronRight, IconChevronLeft } from "@tabler/icons-react";
import { motion } from "framer-motion";

interface SidebarItem {
  name: string;
  icon: React.ElementType;
  link: string;
}

interface SidebarProps {
  items: SidebarItem[];
}

export const Sidebar: React.FC<SidebarProps> = ({ items }) => {
  const pathname = usePathname();
  const [open, setOpen] = useState(true);

  return (
    <aside
      className={`flex h-screen flex-col overflow-y-auto border-r bg-white px-5 py-8 transition-all duration-300 ${
        open ? "w-64" : "w-20"
      }`}
    >
      <div className="mt-6 flex flex-1 flex-col justify-between">
        <nav className="-mx-3 space-y-6">
          <div className="space-y-3">
            {items.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link
                  key={index}
                  href={item.link}
                  className={`flex transform items-center rounded-lg px-3 py-2 text-gray-600 transition-colors duration-300 hover:bg-gray-100 hover:text-gray-700 ${
                    pathname === item.link ? "bg-gray-100 text-gray-700" : ""
                  } group`}
                >
                  <Icon size={20} />
                  <motion.span
                    initial={open ? { opacity: 1 } : { opacity: 0 }}
                    animate={open ? { opacity: 1 } : { opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="mx-2 text-sm font-medium"
                  >
                    {item.name}
                  </motion.span>
                </Link>
              );
            })}
          </div>
        </nav>
      </div>
      <button
        onClick={() => setOpen(!open)}
        className="mt-6 flex items-center justify-center rounded-lg bg-gray-100 p-2 hover:bg-gray-200"
      >
        {open ? (
          <IconChevronLeft size={20} className="text-gray-600" />
        ) : (
          <IconChevronRight size={20} className="text-gray-600" />
        )}
      </button>
    </aside>
  );
};

// Example usage
export const SidebarDemo: React.FC = () => {
  const sidebarItems: SidebarItem[] = [
    { name: "Home", icon: IconHome, link: "/" },
    { name: "All Pages", icon: IconFileText, link: "/wiki" },
    { name: "Categories", icon: IconFolder, link: "#" },
    { name: "Settings", icon: IconSettings, link: "#" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar items={sidebarItems} />
      <div className="flex-1 p-10">
        <h1 className="text-2xl font-bold">Main Content Area</h1>
        <p>Your page content goes here.</p>
      </div>
    </div>
  );
};

=== FILE: ./src/pages/api/wiki/verify-password.ts ===

import type { NextApiRequest, NextApiResponse } from 'next'
import fs from 'fs'
import path from 'path'
import { decryptPassword } from '@/lib/encryption'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { password } = req.body

    // Read the encrypted password from the file
    const encryptedPasswordPath = path.join(process.cwd(), 'secret', 'encrypted_password.txt')
    const encryptedPassword = fs.readFileSync(encryptedPasswordPath, 'utf8').trim()

    // Decrypt the password
    const correctPassword = decryptPassword(encryptedPassword)

    if (password === correctPassword) {
      res.status(200).json({ message: 'Password correct' })
    } else {
      res.status(401).json({ message: 'Incorrect password' })
    }
  } else {
    res.setHeader('Allow', ['POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}

=== FILE: ./src/pages/api/wiki/wiki.ts ===

import { NextApiRequest, NextApiResponse } from 'next'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query

  if (req.method === 'GET') {
    if (id) {
      const document = await prisma.document.findUnique({
        where: { id: parseInt(id as string) },
      })

      if (document) {
        res.status(200).json(document)
      } else {
        res.status(404).json({ error: 'Document not found' })
      }
    } else {
      const documents = await prisma.document.findMany({
        orderBy: { title: 'asc' },
      })
      res.status(200).json(documents)
    }
  } else if (req.method === 'POST') {
    const { title, content, restricted, category } = req.body

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.create({
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(201).json(document)
    } catch (error) {
      console.error('Error creating document:', error)
      res.status(500).json({ error: 'Error creating document' })
    }
  } else if (req.method === 'PUT') {
    const { title, content, restricted, category } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: {
          title,
          content: content || '',
          restricted: restricted || false,
          category: category || 'General',
        },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'PATCH') {
    const { restricted } = req.body

    if (!id) {
      return res.status(400).json({ error: 'Document ID is required' })
    }

    try {
      const document = await prisma.document.update({
        where: { id: parseInt(id as string) },
        data: { restricted },
      })
      res.status(200).json(document)
    } catch (error) {
      console.error('Error updating document:', error)
      res.status(500).json({ error: 'Error updating document' })
    }
  } else if (req.method === 'DELETE') {
    if (id) {
      try {
        await prisma.document.delete({
          where: { id: parseInt(id as string) },
        })
        res.status(200).json({ message: 'Document deleted successfully' })
      } catch (error) {
        console.error('Error deleting document:', error)
        res.status(404).json({ error: 'Document not found or could not be deleted' })
      }
    } else {
      res.status(400).json({ error: 'Document ID is required' })
    }
  } else {
    res.status(405).end() // Method Not Allowed
  }
}

=== FILE: ./src/pages/wiki.tsx ===

// @/pages/wiki.tsx
import { useState, useCallback } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { WikiHeader } from '@/components/wiki/WikiHeader';
import WikiDocumentList from '@/components/wiki/WikiDocumentList';
import { WikiContent } from '@/components/wiki/WikiContent';
import { WikiDialogs } from '@/components/wiki/WikiDialogs';
import { useDocuments } from '@/lib/hooks/useDocuments';
import { useAuth } from '@/lib/hooks/useAuth';
import { useSearch } from '@/lib/hooks/useSearch';
import { Document } from '@/lib/types/wiki';

export default function WikiPage() {
  const {
    documents,
    categories,
    isLoading,
    createDocument,
    updateDocument,
    deleteDocument
  } = useDocuments();

  const {
    isUnlocked,
    isPasswordPromptOpen,
    setIsPasswordPromptOpen,
    handleUnlockToggle,
    handlePasswordSubmit
  } = useAuth();

  const {
    isSearchOpen,
    setIsSearchOpen,
    searchResults,
    setSearchResults,
    handleSearch
  } = useSearch(documents);

  const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
  const [isAddDocumentOpen, setIsAddDocumentOpen] = useState(false);
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState<{ [key: string]: boolean }>({});

  useHotkeys('ctrl+space', (e) => {
    e.preventDefault();
    setIsSearchOpen(true);
  }, []);

  const handleDocumentSelect = useCallback((id: number) => {
    const document = documents.find(doc => doc.id === id);
    if (document) {
      setSelectedDocument(document);
      setIsEditing(false);
    }
  }, [documents]);

  const canEditDocument = useCallback((document: Document) => {
    return isUnlocked || !document.restricted;
  }, [isUnlocked]);

  return (
    <div className="flex flex-col h-screen w-full bg-base-300 text-foreground">
      <WikiHeader
        isUnlocked={isUnlocked}
        onUnlockToggle={handleUnlockToggle}
        onAddDocument={() => setIsAddDocumentOpen(true)}
        onUploadDocument={() => setIsUploadDialogOpen(true)}
      />

      <div className="flex-1 overflow-hidden flex">
        <div className="w-1/4 border-r overflow-auto">
          {isLoading ? (
            <div className="p-4 text-center">Loading documents...</div>
          ) : (
            <WikiDocumentList
              documents={documents}
              onDocumentSelect={handleDocumentSelect}
              onEditDocument={(id) => {
                handleDocumentSelect(id);
                setIsEditing(true);
              }}
              onDeleteDocument={deleteDocument}
              isUnlocked={isUnlocked}
              selectedDocumentId={selectedDocument?.id}
              canEditDocument={canEditDocument}
              expandedCategories={expandedCategories}
              setExpandedCategories={setExpandedCategories}
            />
          )}
        </div>

        <div className="w-3/4 overflow-auto flex flex-col">
          <WikiContent
            selectedDocument={selectedDocument}
            isEditing={isEditing}
            isUnlocked={isUnlocked}
            onUpdateDocument={updateDocument}
            setIsEditing={setIsEditing}
          />
        </div>
      </div>

      <WikiDialogs
        isPasswordPromptOpen={isPasswordPromptOpen}
        isAddDocumentOpen={isAddDocumentOpen}
        isUploadDialogOpen={isUploadDialogOpen}
        isSearchOpen={isSearchOpen}
        searchResults={searchResults}
        categories={categories}
        documents={documents}
        onPasswordSubmit={handlePasswordSubmit}
        onCreateDocument={createDocument}
        onDocumentSelect={handleDocumentSelect}
        onSearch={handleSearch}
        setIsPasswordPromptOpen={setIsPasswordPromptOpen}
        setIsAddDocumentOpen={setIsAddDocumentOpen}
        setIsUploadDialogOpen={setIsUploadDialogOpen}
        setIsSearchOpen={setIsSearchOpen}
        setSearchResults={setSearchResults}
        setSelectedDocument={setSelectedDocument}
        setExpandedCategories={setExpandedCategories}
      />
    </div>
  );
}
=== FILE: ./docker-compose.yml ===

version: '3'
services:
  nextjs-app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
      - ./wiki.sqlite:/app/wiki.sqlite
      - ./prisma:/app/prisma
    environment:
      - NODE_ENV=development
      - DATABASE_URL=file:/app/prisma/dev.db
      - NEXT_PUBLIC_SCRIPT_SERVER_URL=http://node:5000
    command: npm run dev
    networks:
      - app-network

  tailwind:
    build: .
    volumes:
      - .:/app
    command: npx tailwindcss -i ./src/styles/globals.css -o ./src/styles/output.css --watch

  node:
    build:
      context: .
      dockerfile: Dockerfile.node
    volumes:
      - ${HOME}/karlshamn-energi-training/completions.csv:/app/completions.csv
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - PORT=5000
      - CSV_PATH=/app/completions.csv
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

=== FILE: ./wiki_files.txt ===


=== FILE: ./secret/wiki/1729146041082.json ===

80f75c69a864acb3a4633cb0e88defce9f2ec31e4907620fd32e95f58bd5ab91b73193976b19b253c2b7624f206d367568ac7590a607f72fc344cec0ff399736236843d2bf6fc04be081c5f164f409ddce810dea1bcdfb077f68370d3deeab73cf4bc6225e5cd9a7e86ba512c256dbcb103d841cfa633f852488ca975e4a0fa8bf4a98e51bf1c0fc01501142f12a0285