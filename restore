import fs from 'fs';
import path from 'path';

// Function to ensure directory exists
function ensureDirectoryExists(dirPath: string) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

// Function to write file with directory creation
function writeFileWithDirs(filePath: string, content: string) {
  const dir = path.dirname(filePath);
  ensureDirectoryExists(dir);
  fs.writeFileSync(filePath, content);
}

// Function to extract and write files
function extractAndWriteFiles(content: string) {
  const fileRegex = /=== FILE: (.*?) ===\n\n([\s\S]*?)(?=\n===|$)/g;
  let match;
  const processedFiles = [];

  while ((match = fileRegex.exec(content)) !== null) {
    const [, filePath, fileContent] = match;
    const normalizedPath = filePath.replace(/^\.\//, ''); // Remove leading ./
    
    try {
      writeFileWithDirs(normalizedPath, fileContent);
      processedFiles.push(normalizedPath);
      console.log(`‚úÖ Restored: ${normalizedPath}`);
    } catch (error) {
      console.error(`‚ùå Failed to restore ${normalizedPath}:`, error);
    }
  }

  return processedFiles;
}

// Main function to restore project
function restoreProject() {
  console.log('üöÄ Starting project restoration...\n');

  try {
    // Read the project files content
    // Note: You'll need to save the project_files content to this path
    const projectFilesContent = fs.readFileSync('./project_files.txt', 'utf8');
    
    // Extract and write files
    const processedFiles = extractAndWriteFiles(projectFilesContent);
    
    console.log('\n‚ú® Restoration complete!');
    console.log(`üìÅ Total files restored: ${processedFiles.length}`);
    
  } catch (error) {
    console.error('‚ùå Restoration failed:', error);
    process.exit(1);
  }
}

// Run the restoration
restoreProject();
